<!DOCTYPE html>
<html lang="de"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>XY-To-Dos</title>

<!-- Google Material Symbols (Icons) -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0">
<style>
  :root{
    --bg:#0f172a; --card:#0b1225; --muted:#94a3b8; --text:#e6eaf3;
    --accent:#7c3aed; --accent-2:#16a34a; --danger:#ef4444; --border:#1f2a44;
    --chip:#111b36; --progress:#16a34a; --hover:rgba(255,255,255,.06);
    --shadow:0 10px 24px rgba(0,0,0,.25); --row-sel:rgba(124,58,237,.18)
  }
  body.light{
    --bg:#f7fafc; --card:#ffffff; --muted:#475569; --text:#0f172a;
    --accent:#7c3aed; --accent-2:#16a34a; --danger:#b91c1c; --border:#e2e8f0;
    --chip:#f1f5f9; --progress:#16a34a; --hover:rgba(0,0,0,.04);
    --shadow:0 8px 18px rgba(2,6,23,.08); --row-sel:rgba(124,58,237,.14)
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font:15px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, Helvetica, Arial, sans-serif;
    color:var(--text); background:var(--bg)
  }

  /* Einheitliche Schrift für Formularelemente, damit Projekt‑Datum und Deadline identisch aussehen */
  input, select, button, textarea{
    font-family: inherit;
  }
  .container{max-width:1600px; margin:24px auto 120px; padding:0 20px}
.pathPreview{
  margin-top:8px; font-size:12px; color:var(--muted);
  cursor:pointer; text-decoration:underline dotted;
}
tr.collapsed .pathPreview{ display:none; } /* Vorschau im zugeklappten Zustand verstecken */


  /* Header */
  header{display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:14px}
  .title{font-weight:800; letter-spacing:.2px; font-size:28px; display:flex; align-items:center; gap:10px}
  .title [contenteditable]{padding:4px 8px; border-radius:10px}
  .title [contenteditable]:focus{outline:2px solid #334155; background:#0c1630}
  body.light .title [contenteditable]:focus{background:#f8fafc}
  .dirty{width:10px; height:10px; border-radius:999px; background:#f59e0b; display:none}
  .dirty.on{display:inline-block}
  .sub{color:var(--muted); font-size:13px}

  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border:1px solid var(--border); border-radius:18px; box-shadow:var(--shadow); overflow:hidden
  }

  /* Icon-Buttons (Nur Icons) */
  .actions-right{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .iconbtn{
    --bg1:rgba(255,255,255,.06); --bg2:rgba(255,255,255,.02);
    position:relative; display:inline-flex; align-items:center; justify-content:center;
    width:40px; height:40px; border-radius:12px; border:1px solid var(--border);
    background:linear-gradient(180deg,var(--bg1),var(--bg2)); box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
    cursor:pointer
  }
  .iconbtn:hover{background:var(--hover)}
  .ms{
  font-family: "Material Symbols Rounded";
  font-style: normal;
  font-weight: 400;
  font-size: 22px;      /* Icon-Größe */
  line-height: 1;
  display: inline-block;
  vertical-align: middle;
  font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
}
  .ic-save{color:#22c55e}
  .ic-print{color:#8b5cf6}
  .ic-undo{color:#f59e0b}
  .ic-redo{color:#06b6d4}
  .ic-backup{color:#0ea5e9}

  /* Top-Bars */
  .barTop{
    --topbar-item-height:42px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    border-bottom:1px solid var(--border);
    background:rgba(255,255,255,.02);
    gap:16px;
    padding:10px 18px 12px;
  }
  .leftTop{display:flex; flex-direction:column; gap:6px; flex:1; min-width:0}
  .rightTop{display:flex; gap:8px; align-items:center; flex-shrink:0}

  /* Tabs */
  .tabs-container{display:flex; flex-direction:column; gap:6px; position:relative}
  .tabs-scroll{
    display:flex;
    align-items:center;
    padding:8px 14px;
    gap:8px;
    overflow-x:auto;
    overflow-y:visible;
    scroll-behavior:smooth;
    scrollbar-width:none;
    position:relative;
    min-height:var(--topbar-item-height);
  }
  .tabs-scroll::-webkit-scrollbar{display:none}
  .tabs{display:flex; align-items:stretch; gap:8px; min-width:fit-content}
  .tab{
    --tab-bg: var(--card);
    --tab-fg: var(--text);
    display:inline-flex; align-items:center; gap:6px; padding:0 16px;
    border:1px solid var(--border); border-radius:12px;
    background:var(--tab-bg); color:var(--tab-fg);
    cursor:pointer; user-select:none; white-space:nowrap; position:relative;
    transition:transform .15s ease, box-shadow .15s ease;
    min-height:var(--topbar-item-height);
    height:var(--topbar-item-height);
  }
  .tab:focus-visible{outline:2px solid var(--accent); outline-offset:2px}
  .tab.active{outline:2px solid var(--accent); outline-offset:0}
  .tab.dragging{opacity:.6}
  .tab.drop-hint{box-shadow:0 0 0 2px rgba(124,58,237,.5)}
  .tab .name{max-width:220px; overflow:hidden; text-overflow:ellipsis}
  .tab .tab-more{
    background:transparent; border:none; color:inherit; cursor:pointer;
    display:inline-flex; align-items:center; justify-content:center;
    padding:4px; border-radius:8px; min-width:24px; height:24px;
  }
  .tab .tab-more:hover{background:color-mix(in srgb, currentColor 18%, transparent)}
  .tab .tab-more:focus-visible{outline:2px solid var(--accent)}
  .tab.in-dropdown{width:100%; justify-content:space-between; border-radius:10px; padding:8px 14px; min-height:34px; height:auto}
  .tab.in-dropdown .name{max-width:180px}
  .tab.in-dropdown .tab-more{margin-left:auto}
  .tab.add, .tab-add{
    border-style:dashed; font-weight:700; background:rgba(124,58,237,.12);
    color:var(--accent); display:inline-flex; align-items:center; justify-content:center;
  }
  .tab-add{padding:6px 14px; border-radius:12px; border:1px dashed var(--accent); cursor:pointer}
  .tab.is-group{padding-right:36px}
  .tab.is-group{border-radius:8px}
  .tab.is-group .name{
    padding-right:4px;
    font-weight:700;
    opacity:.92;
  }
  .tab-group-toggle{position:absolute; inset-inline-end:6px; top:6px; width:22px; height:22px;
    border-radius:8px; display:flex; align-items:center; justify-content:center;
    border:none; background:transparent; color:inherit; cursor:pointer;
  }
  .tab-group-toggle:hover{background:color-mix(in srgb, currentColor 18%, transparent)}
  .tab-group-toggle:focus-visible{outline:2px solid var(--accent)}
  .tab-group{position:relative; flex-shrink:0}
  .tab-group.open{z-index:1400}
  .tab-dropdown{
    position:absolute; top:calc(100% + 6px); inset-inline-start:0;
    background:var(--card); border:1px solid var(--border); border-radius:14px;
    padding:8px 10px; display:none; flex-direction:column; gap:6px; min-width:210px;
    box-shadow:var(--shadow); z-index:1500; pointer-events:auto;
  }
  .tab-dropdown.show{display:flex}
  .tab-dropdown.floating{position:fixed; inset-inline-start:auto;}
  .tab-dropdown::before{
    content:''; position:absolute; top:-6px; inset-inline-start:20px;
    width:12px; height:12px; transform:rotate(45deg);
    background:var(--card); border-inline-start:1px solid var(--border);
    border-block-start:1px solid var(--border);
  }
  .tab-dropdown.floating::before{inset-inline-start:var(--arrow-left, 24px);}
  .tab-dropdown.above::before{
    top:auto; bottom:-6px; transform:rotate(225deg);
  }
  .tab-group-layer{position:fixed; inset:0; pointer-events:none; z-index:2000;}
  .tab-group-layer .tab-dropdown{pointer-events:auto;}
  .tab-dropdown .tab{display:flex; width:100%;}
  .tab-group .group-drop-zone{
    border:1px dashed var(--border);
    border-radius:10px;
    padding:8px;
    text-align:center;
    font-size:12px;
    color:var(--muted);
    display:none;
    align-items:center;
    line-height:1.4;
  }
  .tab-group .group-drop-zone.show{display:flex; align-items:center; justify-content:center;}
  .tab-group .group-drop-zone.drag-over{border-color:var(--accent); color:var(--accent)}
  .tabs-scrollbar{
    position:relative; height:6px; margin:4px 10px 0; background:rgba(148,163,184,.24);
    border-radius:999px; display:none; flex-shrink:0;
  }
  .tabs-scrollbar.show{display:block}
  .tabs-thumb{
    position:absolute; inset-block-start:0; inset-inline-start:0; height:100%;
    width:64px; border-radius:inherit; background:rgba(124,58,237,.85);
    box-shadow:0 2px 6px rgba(124,58,237,.35); cursor:pointer;
    transition:background .2s ease;
  }
  .tabs-thumb:active{background:rgba(124,58,237,.95)}
  body.light .tabs-thumb{background:rgba(124,58,237,.75)}

  .tab-menu{
    position:absolute; min-width:200px; background:var(--card); border:1px solid var(--border);
    border-radius:12px; padding:6px 0; box-shadow:var(--shadow); display:none; z-index:1800;
  }
  .tab-menu.show{display:block}
  .tab-menu button{
    width:100%; padding:9px 14px; background:transparent; border:none; text-align:left;
    color:var(--text); font-size:14px; cursor:pointer; display:flex; align-items:center; gap:8px;
    position:relative;
  }
  .tab-menu button:hover{background:color-mix(in srgb, var(--accent) 18%, transparent)}
  .tab-menu button:disabled{opacity:.45; cursor:not-allowed}
  .tab-menu button .submenu-arrow{margin-inline-start:auto; font-size:18px; opacity:.7}

  .tab-submenu{
    position:absolute; min-width:200px; background:var(--card); border:1px solid var(--border);
    border-radius:12px; padding:6px 0; box-shadow:var(--shadow); display:none; z-index:1850;
  }
  .tab-submenu.show{display:block}
  .tab-submenu button{
    width:100%; padding:8px 14px; background:transparent; border:none; text-align:left;
    color:var(--text); font-size:14px; cursor:pointer; display:flex; align-items:center; gap:8px;
  }
  .tab-submenu button:hover{background:color-mix(in srgb, var(--accent) 18%, transparent)}

  .color-palette{
    position:absolute; display:none; background:var(--card); border:1px solid var(--border);
    border-radius:16px; padding:14px; box-shadow:var(--shadow); z-index:1900; width:220px;
  }
  .color-palette.show{display:block}
  .color-grid{display:grid; grid-template-columns:repeat(6, 1fr); gap:8px; margin-bottom:12px}
  .color-swatch{
    width:28px; height:28px; border-radius:10px; border:2px solid rgba(255,255,255,.2);
    cursor:pointer; transition:transform .15s ease, border-color .2s ease;
  }
  .color-swatch:hover{transform:scale(1.08)}
  .color-swatch.selected{border-color:#fff}
  body.light .color-swatch{border-color:rgba(15,23,42,.1)}
  .color-palette .custom-color{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:12px;
    font-size:13px;
    color:var(--muted);
  }
  .color-palette .custom-color input[type="color"]{
    -webkit-appearance:none;
    appearance:none;
    width:34px;
    height:26px;
    border:1px solid var(--border);
    border-radius:8px;
    padding:0;
    background:none;
    cursor:pointer;
  }
  .color-palette .custom-color input[type="color"]::-webkit-color-swatch,
  .color-palette .custom-color input[type="color"]::-moz-color-swatch{
    border:none;
    border-radius:6px;
  }
  .color-palette .custom-color input[type="text"]{
    flex:1;
    min-width:100px;
    padding:6px 8px;
    border-radius:8px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
  }
  .color-palette .custom-color input[type="text"].invalid{border-color:var(--danger);}
  .color-palette .custom-color button{
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    border-radius:8px;
    padding:6px 10px;
    cursor:pointer;
  }
  .color-palette .custom-color button:hover{background:color-mix(in srgb, var(--accent) 14%, transparent)}
  .color-palette .reset-btn{
    width:100%; border:1px solid var(--border); background:var(--card); color:var(--text);
    padding:8px 12px; border-radius:10px; cursor:pointer; font-size:14px;
  }
  .color-palette .reset-btn:hover{background:color-mix(in srgb, var(--accent) 14%, transparent)}

  /* Ansicht Toggle */
  .viewToggle{display:flex; gap:6px; padding-right:10px}
  .viewToggle button{
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    border-radius:10px;
    padding:0 12px;
    cursor:pointer;
    min-height:var(--topbar-item-height);
    display:inline-flex;
    align-items:center;
    justify-content:center;
  }
  .viewToggle .on{outline:2px solid var(--accent)}

  /* Eingabe-Toolbar */
  .toolbar{
    display:grid;
    grid-template-columns: minmax(90px,.9fr) minmax(0,1.5fr) minmax(110px,.9fr) 36px minmax(0,1.25fr) minmax(0,1.35fr) minmax(130px,.85fr);
    gap:10px; padding:14px; border-bottom:1px solid var(--border); background:rgba(255,255,255,.02);
    align-items:center;
  }
  .toolbar input[type="text"], .toolbar input[type="date"]{
    width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--border);
    background:#0c1630; color:var(--text); outline:none
  }
  body.light .toolbar input[type="text"], body.light .toolbar input[type="date"]{background:#ffffff}
  .toolbar .btnPrimary{justify-self:stretch; align-self:stretch; display:flex; align-items:center; justify-content:center;}
  .toolbar .todoField{display:flex; flex-direction:column; gap:6px}
  .toolbar .todoField input{width:100%}
  .btnPrimary{
    border:none; padding:10px 16px; border-radius:12px; color:#fff; cursor:pointer;
    background:linear-gradient(135deg, var(--accent), #4f46e5);
    justify-self:stretch;
    white-space:nowrap;
  }
  .btn{border:1px solid var(--border); background:var(--card); color:var(--text); border-radius:10px; padding:9px 12px; cursor:pointer; transition:color .2s, border-color .2s, background .2s}
  .barTop .btn{
    min-height:var(--topbar-item-height);
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:0 14px;
  }
  .btn.on{border-color:var(--accent); color:var(--accent); background:color-mix(in srgb, var(--accent) 12%, transparent);}

  /* Filter-Bar */
  .filterbar{
    /* Grid-Aufteilung: Suchfeld, Status, Prozentbereich, Sortierung
       sowie vier kleine Aktionsbuttons (Auswählen, Abwählen, Alle ausklappen, Alle zuklappen).

       Um Platz für die zusätzlichen Buttons zu schaffen, wurden die Breiten der Status‑
       und Sortierfelder leicht reduziert. Das Suchfeld behält flexible Breite. */
    display:grid;
    grid-template-columns: 1fr .7fr .7fr .8fr auto auto auto auto;
    gap:10px;
    padding:12px 14px;
    border-bottom:1px solid var(--border);
    background:rgba(255,255,255,.02);
    align-items:center;
  }
  .filterbar input[type="text"], .filterbar select{
    width:100%;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid var(--border);
    background:#0c1630;
    color:var(--text);
  }
  body.light .filterbar input[type="text"],
  body.light .filterbar select{
    background:#ffffff;
  }
  .miniBtn{
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    border-radius:10px;
    padding:8px 10px;
    cursor:pointer;
  }

  /* Bulkbar */
  .bulkbar{display:none; gap:10px; align-items:center; padding:10px 14px; border-bottom:1px solid var(--border); background:rgba(124,58,237,.08)}
  .bulkbar.show{display:flex}
  .bulkInfo{color:var(--muted)}

  /* Tabelle */
  table{width:100%; border-collapse:separate; border-spacing:0; table-layout:fixed}
  colgroup col:nth-child(1){width:120px} /* Pfeil + Auswahl + Farbe */
  colgroup col:nth-child(2){width:12%}
  colgroup col:nth-child(3){width:19%}
  /* Datum/Deadline reduziert, Notizen verbreitert. Insgesamt müssen 69% verteilt werden (nachdem 12+19=31% für Nummer und Name reserviert sind). */
  colgroup col:nth-child(4){width:14%} /* Datum & Deadline */
  colgroup col:nth-child(5){width:26%} /* To‑Dos & Fortschritt */
  colgroup col:nth-child(6){width:20%} /* Notizen */
  colgroup col:nth-child(7){width:9%}  /* Pfad */
  /* col7 width overridden above to 9% */
  thead th{
    text-align:left; font-weight:700; padding:12px 14px; color:var(--muted); background:rgba(255,255,255,.02);
    border-bottom:1px solid var(--border); user-select:none
  }
  tbody tr{border-bottom:none; position:relative}
  tbody tr::after{
    content:'';
    position:absolute;
    left:14px;
    right:14px;
    bottom:0;
    height:1px;
    background:rgba(148,163,184,.18);
    pointer-events:none;
  }
  tbody tr:last-child::after{background:transparent}
  #emptyRow .emptyRowCell{
    text-align:center;
    padding:28px 0;
    color:var(--muted);
    font-size:14px;
  }
  body.light tbody tr::after{background:rgba(148,163,184,.28)}
  td{vertical-align:top; padding:12px 14px; overflow:visible}
  td .editable{min-width:60px; padding:8px 10px; border:1px solid transparent; border-radius:10px}
  td .editable:focus{outline:none; border-color:#334155; background:#0c1630}
  body.light td .editable:focus{background:#f8fafc}
  .dateInput{width:100%; background:#0c1630; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:8px 10px}
  /* Einheitliche Schrift und kleinere Datumsanzeige */
  .dateInput, input[type="date"]{
    /* Gleiche Schriftart und kleinere Schriftgröße für alle Datumsfelder (Projektdatum, Deadlines) */
    font-family: inherit;
    font-size:12px;
  }
  body.light .dateInput{background:#ffffff}
  .row-selected{background:var(--row-sel)}
  tr{--pcolor: transparent}
  tr.colored{background:linear-gradient(90deg, color-mix(in srgb, var(--pcolor) 15%, transparent), transparent)}

/* Auswahl soll die Projektfarbe komplett überdecken */
tbody tr.row-selected{
  --pcolor: transparent;                 /* evtl. gesetzte Zeilenfarbe neutralisieren */
  background: var(--row-sel) !important; /* Auswahlfarbe hat Vorrang */
}
tbody tr.row-selected.colored{
  --pcolor: transparent;
  background: var(--row-sel) !important; /* auch falls die Zeile zusätzlich 'colored' hat */
}

  /* Linke Steuerzelle */
  .leftCell{display:flex; align-items:flex-start; gap:8px}
  .caret{cursor:pointer; background:transparent; border:1px solid var(--border); border-radius:10px; width:28px; height:28px; display:flex; align-items:center; justify-content:center}
  .selectCb{margin-top:2px}
  .colorBtn{width:28px; height:28px; border-radius:8px; border:1px solid var(--border); background:var(--pcolor, #7c3aed); cursor:pointer; position:relative}
  .colorBtn::after{content:""; position:absolute; inset:0; border-radius:8px; box-shadow:inset 0 1px 0 rgba(255,255,255,.3), 0 1px 4px rgba(0,0,0,.25) }

  /* Farb-Popover */
  .colorPopover{position:fixed; z-index:50; background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:var(--shadow); padding:12px; display:none}
  .colorRow{display:flex; gap:8px; margin:8px 0}
  .sw{width:24px; height:24px; border-radius:6px; border:1px solid var(--border); cursor:pointer}
  .popBtns{display:flex; gap:8px; justify-content:flex-end}

  /* Fortschritt + Todos (30% kompakter) + Reorder */
  .todoCol{display:flex; flex-direction:column; gap:8px}
  .progress{height:6px; border-radius:999px; background:#0c1630; border:1px solid #223055; overflow:hidden}
  body.light .progress{background:#e2e8f0; border-color:#cbd5e1}
  .progress > i{display:block; height:100%; width:0%}
  .todoHead{display:flex; align-items:center; gap:10px; margin-bottom:0; color:var(--muted); font-size:12px}
  .todoEmptyToggle{
    display:flex;
    align-items:center;
    gap:8px;
    font-size:12px;
    color:var(--muted);
  }
  .todoEmptyToggle input[type="checkbox"]{
    width:16px;
    height:16px;
    accent-color:var(--accent-2);
  }

  .todoList{display:flex; flex-direction:column; gap:6px}
  .todoItem{
    display:grid;
    /* Kompaktere Aufteilung: 16px Checkbox, flexibler Text, 90px Datum, 24px Kalenderbutton, 24px Löschen */
    grid-template-columns: 16px 1fr 90px 24px 24px;
    align-items:center;
    gap:6px;
    background:var(--chip);
    padding:4px 6px;
    border-radius:10px;
    border:1px solid #1b2643;
    font-size:12px;
    cursor:grab;
  }
  body.light .todoItem{border-color:#e2e8f0}
  .todoItem.dragging{opacity:.6; outline:2px dashed #64748b}
  .todoItem input[type="checkbox"]{accent-color:var(--accent-2)}
  .todoItem.done{opacity:.65}
  .todoText{min-height:16px}
  .todoDel{background:transparent; border:none; color:#93a1c8; cursor:pointer; padding:2px 4px; border-radius:8px}
  .todoDel:hover{color:#cbd5e1}

  /* Mini‑Kalenderbutton in To‑Do‑Zeilen */
  .miniCal{
    width:24px;
    height:24px;
    background:transparent;
    border:none;
    color:#93a1c8;
    cursor:pointer;
    padding:0;
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .miniCal:hover{ color:#cbd5e1; }

  .badge{display:inline-flex; align-items:center; gap:6px; border-radius:999px; padding:2px 8px; font-size:11px; border:1px solid var(--border)}
  .b-red{background:#7f1d1d; color:#fecaca; border-color:#7f1d1d}
  .b-amber{background:#78350f; color:#fde68a; border-color:#78350f}
  .b-yellow{background:#3f3f0f; color:#fef08a; border-color:#3f3f0f}
  .b-green{background:#064e3b; color:#bbf7d0; border-color:#064e3b}
  /* Im eingeklappten Zustand nur die Notizen ausblenden – der Fortschrittsbalken bleibt sichtbar. */
  .collapsed .note{display:none}
  /* In collapsed rows, hide the detailed todo list and add area but keep summary and progress visible */
  /* In zusammengeklappten Projektzeilen werden detaillierte To‑Do‑Listen und das Eingabefeld ausgeblendet. */
  .collapsed .todoList,
  .collapsed .todoAdd{
    display:none;
  }
  .collapsed .todoEmptyToggle{
    display:none;
  }
  /* Spezifischer: auch innerhalb der Tabelle sicherstellen, dass Listen und Eingabe bei collapsed‑Zeilen verborgen werden */
  tbody tr.collapsed .todoList,
  tbody tr.collapsed .todoAdd{
    display:none;
  }

  /* Collapsed rows: kleinere Höhe, Notizen und Editier-Icons ausblenden */
  tbody tr.collapsed > td{
    padding-top:6px;
    padding-bottom:6px;
  }

  /* Hinweisleiste für bevorstehende Deadlines wurde entfernt */

  /* Timeline‑Ansicht */
  .timelineShell{display:none; padding:14px 14px 22px;}
  .timelineShell.show{display:block}
  .timeline{
    --timeline-px-day:22px;
    --timeline-row-height:40px;
    --timeline-bar-height:14px;
    --timeline-label-width:220px;
    --timeline-grid-step:var(--timeline-px-day);
    padding:0;
    overflow-x:auto;
    overflow-y:auto;
    max-height:600px;
    scroll-behavior:smooth;
    position:relative;
  }
  /* Kopfzeile der Timeline: getrennte Zeilen für Monate und Tage */
  .timelineMonths,
  .timelineWeeks,
  .timelineDays{
    display:flex;
    position:relative;
    margin-left:var(--timeline-label-width);
    min-width:max-content;
    gap:0;
  }
  .timelineMonths{ margin-bottom:2px; }
  .timelineWeeks{ margin-bottom:2px; }
  .timeline-month{
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    color:var(--muted);
    border-left:1px solid var(--border);
    white-space:nowrap;
    height:20px;
    flex:0 0 auto;
    min-width:var(--timeline-px-day);
  }
  .timeline-month:first-child{ border-left:none; }
  .timeline-day{
    flex:0 0 var(--timeline-px-day);
    font-size:9px;
    color:var(--muted);
    text-align:center;
    border-left:1px solid var(--border);
    padding-top:2px;
    white-space:nowrap;
    min-width:var(--timeline-px-day);
  }
  .timeline-week{
    flex:0 0 auto;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
    color:var(--muted);
    border-left:1px solid var(--border);
    border-right:1px solid var(--border);
    min-width:calc(var(--timeline-px-day) * 7);
    height:22px;
    white-space:nowrap;
  }
  .timeline-week:first-child{border-left:none;}
  .timeline-week:last-child{border-right:none;}
  .timeline[data-zoom="weeks"] .timelineDays{display:none;}

  /* Popover für Datumsauswahl (benutzerdefinierter DatePicker) */
  .datePicker{
    position: fixed;
    background: var(--card);
    color: var(--fg);
    border: 1px solid var(--border);
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    padding: 6px;
    font-size: 12px;
    z-index: 10000;
    display:none;
    pointer-events:auto;
    width:236px;
    max-width:236px;
  }
  .datePicker.show{display:block;}
  .datePicker.above{transform:translateY(-4px);}
  .datePicker header{
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
    font-weight: 600;
  }
  .datePicker .navBtn{
    cursor: pointer;
    padding: 0 4px;
    user-select: none;
  }
  .datePicker table{
    border-collapse: collapse;
    width:100%;
    table-layout:fixed;
  }
  .datePicker th, .datePicker td{
    width: 24px;
    height: 22px;
    text-align: center;
    cursor: pointer;
  }
  .datePicker td.disabled{
    color: var(--muted);
    cursor: default;
  }
  .datePicker td:hover:not(.disabled){
    background: var(--chip);
  }
  .datePicker td.selected{
    background: var(--accent);
    color: #fff;
    border-radius: 50%;
  }
  .timeline-day:first-child{ border-left:none; }
  .timelineChart{
    position:relative;
    margin-left:var(--timeline-label-width);
    background-image:
      repeating-linear-gradient(to right, var(--border) 0, var(--border) 1px, transparent 1px, transparent var(--timeline-grid-step)),
      repeating-linear-gradient(to bottom, rgba(148,163,184,.18) 0, rgba(148,163,184,.18) 1px, transparent 1px, transparent var(--timeline-row-height));
    min-width:max-content;
  }
  .timeline-week-boundaries{position:absolute; inset:0; pointer-events:none;}
  .timeline-week-line{position:absolute; top:0; bottom:0; width:1px; background:rgba(148,163,184,.28);}
  body.light .timeline-week-line{background:rgba(148,163,184,.35);}
  .timelineControls{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:16px;
    margin-bottom:12px;
  }
  .timelineFilter{display:flex; flex-direction:column; gap:4px; min-width:180px;}
  .timelineFilter label{font-size:12px; color:var(--muted);}
  .timelineFilter select{
    padding:8px 10px;
    border-radius:10px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
  }
  body.light .timelineFilter select{background:#ffffff;}
  .timelineZoomWrap{display:flex; flex-direction:column; align-items:flex-end; gap:6px; min-width:220px;}
  .timelineZoomWrap span{color:var(--muted); font-size:12px;}
  .timelineZoomWrap input[type="range"]{width:200px; accent-color:var(--accent);}
  .timelineZoomLabels{display:flex; width:200px; justify-content:space-between; font-size:11px; color:var(--muted); gap:4px;}
  .timelineZoomLabels span{flex:1; text-align:center; transition:color .2s, font-weight .2s;}
  .timelineZoomLabels span.active{color:var(--text); font-weight:600;}

  /* Erlaube horizontales Scrollen in der Timeline, damit weit entfernte Deadlines erreichbar sind */
  #timelineView{
    overflow-x:auto;
    overflow-y:auto;
    padding-bottom:8px;
  }
  .timeline-row{
    position:absolute;
    left:0;
    right:0;
    height:var(--timeline-row-height);
  }
  .timeline-row::after{
    content:'';
    position:absolute;
    left:calc(var(--timeline-label-width) * -1);
    right:0;
    bottom:0;
    height:1px;
    background:rgba(148,163,184,.18);
    pointer-events:none;
  }
  body.light .timeline-row::after{background:rgba(148,163,184,.26)}
  .timeline-label{
    position:sticky;
    left:0;
    top:0;
    bottom:0;
    width:var(--timeline-label-width);
    margin-left:calc(var(--timeline-label-width) * -1);
    display:flex;
    align-items:center;
    justify-content:flex-start;
    white-space:nowrap;
    overflow:visible;
    font-size:13px;
    padding:10px 16px 10px 16px;
    background:none;
    z-index:3;
    border-right:1px solid var(--border);
    min-height:var(--timeline-row-height);
  }
  .timeline-label-text{
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    position:relative;
    z-index:2;
    max-width:100%;
    flex:1;
  }
  .timeline-label::before{
    content:'';
    position:absolute;
    inset:-6px -2px;
    background:rgba(15,23,42,.98);
    z-index:-1;
  }
  .timeline-label-bubble{
    position:absolute;
    left:16px;
    top:50%;
    transform:translateY(-50%);
    display:none;
    padding:10px 16px;
    align-items:center;
    line-height:1.4;
    background:rgba(15,23,42,.98);
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:var(--shadow);
    white-space:nowrap;
    pointer-events:none;
    z-index:5;
    max-width:calc(100vw - 60px);
    min-width:calc(var(--timeline-label-width) * 0.9);
  }
  .timeline-label:hover .timeline-label-bubble,
  .timeline-label:focus-within .timeline-label-bubble{
    display:inline-flex;
  }
  .timeline-label:hover .timeline-label-text,
  .timeline-label:focus-within .timeline-label-text{
    visibility:hidden;
  }
  body.light .timeline-label::before{
    background:rgba(255,255,255,.98);
  }
  body.light .timeline-label-bubble{
    background:rgba(255,255,255,.98);
  }
  .timeline-bar{
    position:absolute;
    height:var(--timeline-bar-height);
    border-radius:999px;
    top:calc((var(--timeline-row-height) - var(--timeline-bar-height))/2);
    /* Balkenfarbe wird im Script gesetzt (accent, danger oder muted) */
  }
  .timeline-row.overdue .timeline-label{color:var(--danger); font-weight:600;}
  .timeline-bar.overdue{
    background:linear-gradient(270deg, rgba(239,68,68,1) 0%, rgba(239,68,68,.82) 72%, rgba(239,68,68,.6) 100%) !important;
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0 12px;
    font-weight:700;
    letter-spacing:.3px;
    text-transform:uppercase;
  }
  .timeline-bar.overdue span{
    font-size:11px;
    white-space:nowrap;
  }
  .today-line{
    position:absolute;
    width:2px;
    background:var(--danger);
    top:0;
    bottom:0;
    z-index:5;
  }

  .note{min-height:140px; background:linear-gradient(180deg,#0c1630,#0a132a); border:1px dashed #314064; border-radius:12px; padding:10px 12px; outline:none}
  body.light .note{background:#ffffff; border-color:#e2e8f0}

  .folderWrap{display:flex; align-items:center; gap:8px}
  .folderInput{width:100%; background:#0c1630; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:8px 10px}
  body.light .folderInput{background:#ffffff}
  /* Floating Save */
  .fab{position:fixed; right:24px; bottom:24px; z-index:10}
  .toast{position:fixed; left:24px; bottom:24px; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; box-shadow:var(--shadow); opacity:0; transform:translateY(8px); transition:.25s}
  .toast.show{opacity:1; transform:translateY(0)}

  /* Kanban */
  .kanban{display:none; padding:14px}
  .kanban.show{display:block}
  .kbWrap{display:grid; grid-template-columns: repeat(3, 1fr); gap:12px}
  .kbCol{border:1px solid var(--border); border-radius:14px; background:var(--card); min-height:240px; padding:10px}
  .kbHead{font-weight:700; color:var(--muted); margin:4px 6px 10px}
  .kbList{display:flex; flex-direction:column; gap:10px; min-height:200px; position:relative}
  .kbCard{border:1px solid var(--border); border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); padding:10px; cursor:grab; transition:border-color .2s, box-shadow .2s}
  .kbCard.drop-before{box-shadow:0 -2px 0 var(--accent) inset; border-color:color-mix(in srgb, var(--accent) 40%, var(--border));}
  .kbCard.drop-after{box-shadow:0 2px 0 var(--accent) inset; border-color:color-mix(in srgb, var(--accent) 40%, var(--border));}
  .kbTitle{font-weight:700; margin-bottom:6px}
  .kbMeta{display:flex; gap:8px; align-items:center; color:var(--muted); font-size:12px}
  .kbProg{height:6px; border-radius:999px; background:#0c1630; border:1px solid #223055; overflow:hidden; margin-top:8px}
  .kbProg > i{display:block; height:100%; width:0%}
  .kbPlaceholder{height:6px; background:color-mix(in srgb, var(--accent) 75%, transparent); border-radius:999px; margin:2px 0; pointer-events:none;}

  /* Wenn es viele Projekte gibt, soll jede Kanban‑Spalte selbst scrollen. Ab 10 Karten wird der Bereich begrenzt. */
  .kbList{
    max-height:480px;
    overflow-y:auto;
  }

  /* Dispo */
  .dispo{display:none; padding:18px;}
  .dispo.show{display:block;}
    .dispoControls{display:flex; flex-wrap:wrap; align-items:flex-end; gap:12px; margin-bottom:18px;}
    .dispoField{display:flex; flex-direction:column; gap:6px; min-width:160px;}
    .dispoField label{font-size:12px; color:var(--muted);}
    .dispoField input, .dispoField textarea{padding:9px 12px; border-radius:12px; border:1px solid var(--border); background:#0c1630; color:var(--text);}
    body.light .dispoField input, body.light .dispoField textarea{background:#ffffff;}
    .dispoExplorer{display:flex; flex-direction:column; gap:14px;}
    .dispoBreadcrumbs{display:flex; align-items:center; flex-wrap:wrap; gap:6px; font-size:12px; color:var(--muted);}
    .dispoBreadcrumbs button{border:none; background:transparent; color:inherit; cursor:pointer; padding:4px 8px; border-radius:8px; font:inherit;}
    .dispoBreadcrumbs button:disabled{cursor:default; opacity:.85;}
    .dispoBreadcrumbs button:hover{background:var(--hover); color:var(--text);}
    .dispoBreadcrumbs button.active{background:var(--hover); color:var(--text); font-weight:600;}
    .dispoBreadcrumbs .sep{opacity:.6;}
    .dispoList{display:flex; flex-direction:column; gap:16px;}
    .dispoList.chooser{display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); gap:12px;}
    .dispoCard{border:1px solid var(--border); border-radius:14px; padding:14px 16px; background:var(--card); display:flex; flex-direction:column; gap:6px; cursor:pointer; transition:border-color .2s, transform .2s;}
    .dispoCard:hover{border-color:color-mix(in srgb, var(--accent) 55%, var(--border)); transform:translateY(-2px);}
    .dispoCard strong{font-size:16px;}
    .dispoCard span{color:var(--muted); font-size:12px;}
  .dispoEntry{border:1px solid var(--border); border-radius:16px; background:var(--card); overflow:hidden;}
  .dispoEntry summary{list-style:none; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 18px; cursor:pointer; font-weight:600;}
  .dispoEntry summary::-webkit-details-marker{display:none;}
  .dispoEntry[open] summary{border-bottom:1px solid var(--border);}
  .dispoSummaryTitle{display:flex; flex-direction:column; gap:4px;}
  .dispoRange{color:var(--muted); font-size:12px; font-weight:500;}
  .dispoSummaryMeta{color:var(--muted); font-size:12px; margin-left:auto;}
  .dispoSummaryActions{display:flex; gap:6px; align-items:center;}
  .dispoSummaryActions button{border:none; background:transparent; color:var(--muted); cursor:pointer; padding:4px 6px; border-radius:8px;}
  .dispoSummaryActions button:hover{color:var(--danger); background:var(--hover);}
  .dispoBody{padding:18px; display:flex; flex-direction:column; gap:16px;}
  .dispoNotes textarea{min-height:90px; resize:vertical;}
  .dispoItems{display:flex; flex-direction:column; gap:10px;}
  .dispoItemHead{display:grid; grid-template-columns:minmax(0,1.1fr) minmax(0,0.9fr) minmax(0,1.6fr) 140px 40px; gap:8px; font-size:12px; color:var(--muted); padding:0 4px;}
  .dispoItemRow{display:grid; grid-template-columns:minmax(0,1.1fr) minmax(0,0.9fr) minmax(0,1.6fr) 140px 40px; gap:8px; align-items:center;}
  .dispoItemRow input{padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:#0c1630; color:var(--text);}
  body.light .dispoItemRow input{background:#ffffff;}
  .dispoItemRow button{border:none; background:transparent; color:var(--muted); cursor:pointer; font-size:18px; line-height:1; padding:4px;}
  .dispoItemRow button:hover{color:var(--danger);}
  .dispoAddItem{display:grid; grid-template-columns:minmax(0,1.1fr) minmax(0,0.9fr) minmax(0,1.6fr) 140px 120px; gap:8px; align-items:center; margin-top:6px;}
  .dispoAddItem input{padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:#0c1630; color:var(--text);}
  body.light .dispoAddItem input{background:#ffffff;}
  .dispoAddItem button{height:38px;}
  .dispoEmpty{padding:28px 12px; text-align:center; color:var(--muted); border:1px dashed var(--border); border-radius:14px;}

  /* Print */
  @media print{
    @page{ size:A4 landscape; margin:12mm; }
    header, .barTop, .viewToggle, .toolbar, .filterbar, .bulkbar, .footer, .fab, .actions-right,
    .caret, .leftCell .selectCb, .colorBtn, .todoDel, .miniCal { display:none !important; }
    body{ background:#ffffff; color:#0f172a; font-size:11px; }
    .container{ margin:0; max-width:100%; padding:0 12mm; }
    .tableView, .kanban, .dispo{ display:none !important; }
    .timelineShell{ display:block !important; padding:0 !important; }
    #timelineView{ overflow:visible !important; padding-bottom:0 !important; }
    .timelineControls{ display:none !important; }
    .timeline{ --timeline-label-width:240px; }
    .timelineMonths, .timelineWeeks, .timelineDays{ display:none !important; }
    .timelineChart{ margin-left:0; background-image:none; border:1px solid #d1d5db; border-radius:10px; padding:12px 16px 16px; }
    .timeline-row{ position:relative !important; top:auto !important; height:auto !important; padding:14px 0; page-break-inside:avoid; }
    .timeline-row::after{ left:0 !important; right:0 !important; }
    .timeline-label{ position:relative; left:auto; top:auto; bottom:auto; margin:0 0 8px; width:auto; padding:0; background:none !important; border:none !important; font-size:12px; font-weight:700; color:#0f172a; }
    .timeline-bar{ position:relative !important; top:auto !important; height:14px; margin-top:6px; border-radius:6px; box-shadow:none; }
    .timeline-bar.overdue{ padding-right:10px; }
    .timeline-bar.overdue span{ font-size:10px; }
    .today-line{ display:none !important; }
    table{ width:100%; table-layout:auto; border-collapse:collapse; }
    thead th, tbody td{ white-space:normal; word-break:break-word; padding:4px 6px; font-size:11px; border:none !important; }
    tbody tr{ page-break-inside:avoid; border-bottom:1px solid #d1d5db; }
    tbody tr::after{ display:none !important; }
    .progress{ height:4px; }
    input[type="date"], input[type="text"], .folderInput{ border:none !important; padding:0 !important; background:none !important; color:#0f172a !important; width:auto !important; }
    .todoAdd{ display:none !important; }
    .note{ display:none !important; }
    body.print-detailed .note{ display:block !important; background:none !important; border:none !important; padding:0 !important; min-height:auto; }
    .todoList{ display:none !important; }
    body.print-detailed .todoList{ display:block !important; margin-top:6px; }
    body.print-detailed .todoItem{ display:flex; align-items:center; gap:6px; padding:2px 0; border:none; background:none; box-shadow:none; }
    body.print-detailed .todoItem input[type="checkbox"]{ display:none; }
    body.print-detailed .todoItem .todoText{ font-weight:600; }
    body.print-detailed .todoItem.done .todoText{ text-decoration:line-through; color:#475569; }
    body.print-detailed .dateInput{ border:none !important; background:none !important; padding:0 !important; color:#0f172a !important; }
    td:nth-child(7), th:nth-child(7){ display:table-cell !important; }
    .pathPreview{ display:block !important; white-space:normal; position:relative; color:transparent; }
    .pathPreview::after{ content:attr(data-full); color:#0f172a; display:block; font-size:10px; font-weight:600; }
    body.print-detailed .pathPreview::after{ font-weight:700; }
    .dispoControls, .dispoSummaryActions, .dispoAddItem{ display:none !important; }
  }
</style>
<style id="ce-placeholder-rule">.title [contenteditable]:empty::before{content:attr(data-placeholder); color:var(--muted);}</style></head>
<body>
  <!-- eingebetteter Zustand -->
  <script id="APP_STATE" type="application/json">{
  "title": "XY-To-Dos",
  "projects": [
    {
      "id": "ct8ogtd",
      "number": "dsafewr",
      "name": "343434",
      "date": "",
      "deadline": "",
      "showDeadline": false,
      "todos": [],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    },
    {
      "id": "9scywmt",
      "number": "5467q2345135",
      "name": "dbndfghdfgh",
      "date": "",
      "deadline": "",
      "showDeadline": false,
      "todos": [],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    },
    {
      "id": "bwadcix",
      "number": "23451341",
      "name": "dsfgdfsgdswgdsfg",
      "date": "",
      "deadline": "",
      "showDeadline": false,
      "todos": [],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    },
    {
      "id": "bdlykea",
      "number": "sdfgdfsg34",
      "name": "534523452345",
      "date": "",
      "deadline": "",
      "showDeadline": false,
      "todos": [],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    },
    {
      "id": "jvv9n9x",
      "number": "3452345234",
      "name": "dsfdsdfdfgs",
      "date": "",
      "deadline": "",
      "showDeadline": false,
      "todos": [],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    },
    {
      "id": "zri8cf4",
      "number": "234234456456",
      "name": "sdfgdsfgdfsgsdf",
      "date": "2025-09-27",
      "deadline": "",
      "showDeadline": false,
      "todos": [
        {
          "text": "dsfghsdfgsdg",
          "done": false,
          "due": ""
        }
      ],
      "notes": "",
      "tab": "Alle",
      "folder": "C:\\Users\\magomed.harkimov\\Desktop\\3005328 -Systemzentrale, Reinigung\\Zeichnungen",
      "color": "",
      "collapsed": false
    },
    {
      "id": "a2g6fws",
      "number": "2341234",
      "name": "adsadsfsa",
      "date": "",
      "deadline": "",
      "showDeadline": false,
      "todos": [],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    },
    {
      "id": "gfsvizm",
      "number": "123123",
      "name": "sdaadsf",
      "date": "",
      "deadline": "",
      "showDeadline": false,
      "todos": [],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    },
    {
      "id": "p1",
      "number": "001",
      "name": "Projekt A",
      "date": "2025-09-23",
      "deadline": "",
      "showDeadline": false,
      "todos": [
        {
          "text": "Aufgabe 2025",
          "done": false,
          "due": "2025-09-23"
        },
        {
          "text": "Aufgabe 2027",
          "done": false,
          "due": "2027-09-23"
        },
        {
          "text": "Aufgabe 2030",
          "done": false,
          "due": "2030-09-23"
        }
      ],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    },
    {
      "id": "p2",
      "number": "002",
      "name": "Projekt B",
      "date": "2025-09-23",
      "deadline": "",
      "showDeadline": false,
      "todos": [],
      "notes": "",
      "tab": "Alle",
      "folder": "",
      "color": "",
      "collapsed": false
    }
  ],
  "filters": {
    "q": "",
    "status": "all",
    "sort": "date_desc",
    "pctMin": 0,
    "pctMax": 100
  },
  "trash": [],
  "tabs": [
    "Alle"
  ],
  "currentTab": "Alle",
  "theme": "dark",
  "view": "table",
  "timelineTab": "Alle",
  "timelineZoom": "days",
  "order": [],
  "dispo": []
}</script>

  <script>
  // Fehlerdiagnose: Alle JavaScript-Fehler im Fenster auf der Seite anzeigen.
  window.onerror = function(msg, url, line, col, error){
    const div = document.createElement('pre');
    div.style.color = 'red';
    div.style.whiteSpace = 'pre-wrap';
    div.textContent = 'JS-Fehler: ' + msg + ' at ' + line + ':' + col;
    document.body.appendChild(div);
  };
  window.addEventListener('unhandledrejection', function(event){
    const div = document.createElement('pre');
    div.style.color = 'red';
    div.style.whiteSpace = 'pre-wrap';
    div.textContent = 'Unhandled promise rejection: ' + (event.reason && event.reason.message || event.reason);
    document.body.appendChild(div);
  });
  </script>

  <script>
  // Beim Laden der Datei die gespeicherten Autosave-Daten entfernen, um eine saubere Testumgebung zu gewährleisten.
  try{
    localStorage.removeItem('autosaveState');
  }catch(e){}
  </script>

  <!-- Autosave Toast -->
  <div class="toast" id="toast">Gespeichert</div>

  <!-- Floating Save -->
  <div class="fab">
    <button class="iconbtn" id="saveFab" title="Speichern"><span class="ms ic-save">save</span></button>
  </div>

  <div class="container">
    <header>
      <div>
        <div class="title">
          <span class="dirty on" id="dirtyDot"></span>
          <span id="titleText" contenteditable="true" spellcheck="false" data-placeholder="Titel hier ändern …">XY-To-Dos</span>
        </div>
        <div class="sub">Tabs • Drag &amp; Drop • Deadlines &amp; Fällig-Badges • CSV / Export für Kalender • Kanban (Beta) • Datei-Speicherung</div>
      </div>
      <div class="actions-right" role="toolbar" aria-label="Aktionen">
        <!-- Nur Icons (ohne Text) -->
        <button class="iconbtn" id="saveBtn" title="Speichern"><span class="ms ic-save">save</span></button>
        <button class="iconbtn" id="printBtn" title="Drucken"><span class="ms ic-print">print</span></button>
        <button class="btn" id="printDetailToggle" title="To-Dos in der Druckansicht einblenden">Druck-Details</button>
        <button class="iconbtn" id="undoBtn" title="Rückgängig"><span class="ms ic-undo">undo</span></button>
        <button class="iconbtn" id="redoBtn" title="Wiederholen"><span class="ms ic-redo">redo</span></button>
        <button class="iconbtn" id="backupBtn" title="Backup"><span class="ms ic-backup">backup</span></button>
        <!-- Farbmodus Switch -->
        <label class="iconbtn" title="Farbmodus umschalten" style="width:auto; gap:8px">
          <input id="modeToggle" type="checkbox" role="switch" aria-checked="false" style="accent-color:#64748b; width:18px; height:18px">
          <span class="ms">dark_mode</span>
        </label>
        <!-- Papierkorb (ständig verfügbar) -->
        <button class="btn" id="trashOpenBtn" title="Papierkorb öffnen">Papierkorb</button>
      </div>
    </header>

    <div class="card">
      <!-- Tabs + Ansicht -->
      <div class="barTop">
        <div class="leftTop">
          <div class="tabs-container">
            <div class="tabs-scroll" id="tabsScroll">
              <div class="tabs" id="tabs"></div>
            </div>
            <div class="tabs-scrollbar" id="tabsScrollbar">
              <div class="tabs-thumb" id="tabsThumb"></div>
            </div>
          </div>
        </div>
        <div class="rightTop">
          <div class="viewToggle">
            <button id="viewTable" class="on">Tabelle</button>
            <button id="viewKanban">Kanban</button>
            <button id="viewTimeline">Timeline</button>
            <button id="viewDispo">Dispo</button>
          </div>
          <!-- Text‑Buttons für restliche Funktionen. Die Option "Öffnen" wurde entfernt. -->
          <button class="btn" id="saveAsBtn" title="Speichern unter">Speichern unter</button>
          <button class="btn" id="csvImportBtn" title="CSV importieren">CSV import</button>
          <button class="btn" id="csvExportBtn" title="CSV exportieren">CSV export</button>
          <button class="btn" id="calendarExportBtn" title="Export für Kalender">Export für Kalender</button>
        </div>
      </div>

      <!-- Eingabezeile -->
      <div class="toolbar" id="addForm">
        <input id="inNr" type="text" placeholder="Projektnummer">
        <input id="inName" type="text" placeholder="Projektname">
        <input id="inDate" type="text" placeholder="tt.mm.jjjj">
        <!-- Kalenderbutton für Projektdatum -->
        <button class="iconbtn miniCal" id="inDateCalBtn" title="Datum auswählen"><span class="ms">event</span></button>
        <input id="inFolder" type="text" placeholder="Pfad (file://, C:\\..., /mnt/...)">
        <div class="todoField">
          <input id="inTodos" type="text" placeholder="To-Dos mit ; trennen">
        </div>
        <button class="btnPrimary" id="addBtn" type="button">Projekt hinzufügen</button>
      </div>

      <!-- Filter -->
      <div class="filterbar">
        <input id="q" type="text" placeholder="Suchen in Nr. und Name">
        <select id="status">
          <option value="all">Status Alle</option>
          <option value="open">Nur offen</option>
          <option value="done">Nur erledigt</option>
          <option value="partial">Teilweise erledigt</option>
        </select>
        <div class="pct">
          <span>% von</span>
          <input id="pctMin" type="number" min="0" max="100" step="1" value="0">
          <span>bis</span>
          <input id="pctMax" type="number" min="0" max="100" step="1" value="100">
        </div>
        <select id="sort">
          <option value="date_desc">Sortieren Datum ↓</option>
          <option value="date_asc">Datum ↑</option>
          <option value="name_asc">Name A → Z</option>
          <option value="name_desc">Name Z → A</option>
          <option value="nr_asc">Nummer ↑</option>
          <option value="nr_desc">Nummer ↓</option>
          <option value="prog_desc">Fortschritt ↓</option>
          <option value="prog_asc">Fortschritt ↑</option>
          <option value="manual">Manuell (Drag &amp; Drop)</option>
        </select>
        <!-- Anzahl der Tage bis zum Fälligkeitsdatum, ab dem eine Warnung angezeigt wird -->
        <button class="miniBtn" id="selectAllBtn">Alle auswählen</button>
        <button class="miniBtn" id="clearSelBtn">Alle abwählen</button>
        <!-- Neue Buttons zum gleichzeitigen Auf- und Zuklappen aller Projekte -->
        <button class="miniBtn" id="expandAllBtn" title="Alle Projekte ausklappen">Alle ausklappen</button>
        <button class="miniBtn" id="collapseAllBtn" title="Alle Projekte zuklappen">Alle zuklappen</button>
      </div>

      <!-- Bulk Aktionen -->
      <div class="bulkbar" id="bulkbar">
        <span class="bulkInfo" id="selCount">0 ausgewählt</span>
        <select id="bulkAction">
          <option value="">Aktion wählen</option>
          <option value="delete">Löschen → Papierkorb</option>
          <option value="move">Verschieben in Tab</option>
          <option value="export_csv">Export CSV</option>
          <option value="export_ics">Export Kalender</option>
        </select>
        <select id="bulkTarget" style="display:none"><option value="Alle">Alle</option></select>
        <button class="btnPrimary" id="bulkGo">Ausführen</button>
      </div>

      <!-- Hinweisleiste für kommende Deadlines entfernt -->

      <!-- Tabellenansicht -->
      <div id="tableView" style="display: block;">
        <table>
          <colgroup><col><col><col><col><col><col><col></colgroup>
          <thead>
            <tr>
              <th><!-- leer (Pfeil, Auswahl, Farbe) --></th>
              <th>Projektnummer</th>
              <th>Projektname</th>
              <th>Datum · Deadline</th>
              <th>To-Dos · Fortschritt</th>
              <th>Notizen</th>
              <th>Pfad</th>
            </tr>
          </thead>
          <tbody id="tbody"><tr data-id="zri8cf4"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">234234456456</div></td><td><div class="editable" contenteditable="true">sdfgdsfgdfsgsdf</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 1 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"><div class="todoItem" draggable="true"><input type="checkbox"><div class="todoText editable" contenteditable="true">dsfghsdfgsdg</div><input type="text" class="dateInput" title="Deadline" placeholder="tt.mm.jjjj"><button class="iconbtn miniCal" title="Datum auswählen"><span class="ms">event</span></button><button class="todoDel" title="Aufgabe entfernen">✕</button></div></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: block;">C:\Users\magomed.h… Reinigung\Zeichnungen</div></td></tr><tr data-id="p1"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">001</div></td><td><div class="editable" contenteditable="true">Projekt A</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 3 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"><div class="todoItem" draggable="true" style="box-shadow: rgba(239, 68, 68, 0.7) 0px 0px 0px 2px inset;"><input type="checkbox"><div class="todoText editable" contenteditable="true">Aufgabe 2025</div><input type="text" class="dateInput" title="Deadline" placeholder="tt.mm.jjjj"><button class="iconbtn miniCal" title="Datum auswählen"><span class="ms">event</span></button><button class="todoDel" title="Aufgabe entfernen">✕</button></div><div class="todoItem" draggable="true" style="box-shadow: rgba(16, 185, 129, 0.45) 0px 0px 0px 2px inset;"><input type="checkbox"><div class="todoText editable" contenteditable="true">Aufgabe 2027</div><input type="text" class="dateInput" title="Deadline" placeholder="tt.mm.jjjj"><button class="iconbtn miniCal" title="Datum auswählen"><span class="ms">event</span></button><button class="todoDel" title="Aufgabe entfernen">✕</button></div><div class="todoItem" draggable="true" style="box-shadow: rgba(16, 185, 129, 0.45) 0px 0px 0px 2px inset;"><input type="checkbox"><div class="todoText editable" contenteditable="true">Aufgabe 2030</div><input type="text" class="dateInput" title="Deadline" placeholder="tt.mm.jjjj"><button class="iconbtn miniCal" title="Datum auswählen"><span class="ms">event</span></button><button class="todoDel" title="Aufgabe entfernen">✕</button></div></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr><tr data-id="p2"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">002</div></td><td><div class="editable" contenteditable="true">Projekt B</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 0 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr><tr data-id="ct8ogtd"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">dsafewr</div></td><td><div class="editable" contenteditable="true">343434</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 0 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr><tr data-id="9scywmt"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">5467q2345135</div></td><td><div class="editable" contenteditable="true">dbndfghdfgh</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 0 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr><tr data-id="bwadcix"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">23451341</div></td><td><div class="editable" contenteditable="true">dsfgdfsgdswgdsfg</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 0 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr><tr data-id="bdlykea"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">sdfgdfsg34</div></td><td><div class="editable" contenteditable="true">534523452345</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 0 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr><tr data-id="jvv9n9x"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">3452345234</div></td><td><div class="editable" contenteditable="true">dsfdsdfdfgs</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 0 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr><tr data-id="a2g6fws"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">2341234</div></td><td><div class="editable" contenteditable="true">adsadsfsa</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 0 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr><tr data-id="gfsvizm"><td class="leftCell" draggable="true"><button class="caret" title="Einklappen"><span class="ms">expand_more</span></button><input type="checkbox" class="selectCb"><button class="colorBtn" title="Projektfarbe" style="--pcolor: #7c3aed;"></button></td><td><div class="editable" contenteditable="true">123123</div></td><td><div class="editable" contenteditable="true">sdaadsf</div></td><td><div style="display: flex; flex-direction: column; gap: 8px;"><input type="date" class="dateInput" title="Projekt‑Datum" lang="de" placeholder="tt.mm.jjjj"><div style="display: flex; gap: 8px; align-items: center;"><input type="text" class="dateInput" placeholder="tt.mm.jjjj" style="display: none;"><button class="btn" title="Deadline anzeigen"><span class="ms">event</span></button></div></div></td><td><div class="todoCol"><div class="todoHead"><span>0 von 0 erledigt</span><span style="margin-left:auto">0%</span></div><div class="progress"><i style="background: linear-gradient(90deg, var(--progress), #34d399); width: 0%;"></i></div><div class="todoList"></div><div class="todoAdd" style="display: flex; gap: 8px;"><input type="text" placeholder="To-Do hinzufügen"><button class="btnPrimary">+</button></div></div></td><td><div class="note" contenteditable="true"></div></td><td><div class="folderWrap"><input type="text" class="folderInput" placeholder="Pfad oder URL"></div><div class="pathPreview" style="display: none;"></div></td></tr></tbody>
        </table>
      </div>

      <!-- Kanban -->
      <div id="kanbanView" class="kanban">
        <div class="kbWrap">
          <div class="kbCol" data-col="open">
            <div class="kbHead">Offen</div>
            <div class="kbList" id="kbOpen"></div>
          </div>
          <div class="kbCol" data-col="partial">
            <div class="kbHead">Teilweise</div>
            <div class="kbList" id="kbPartial"></div>
          </div>
          <div class="kbCol" data-col="done">
            <div class="kbHead">Erledigt</div>
            <div class="kbList" id="kbDone"></div>
          </div>
        </div>
      </div>

      <!-- Timeline Ansicht -->
      <div id="timelineShell" class="timelineShell">
        <div class="timelineControls">
          <div class="timelineFilter">
            <label for="timelineTabSelect">Tab-Auswahl</label>
            <select id="timelineTabSelect"></select>
          </div>
          <div class="timelineZoomWrap">
            <span>Zoom</span>
            <input id="timelineZoom" type="range" min="0" max="2" step="1">
            <div class="timelineZoomLabels" id="timelineZoomLabels"></div>
          </div>
        </div>
        <div id="timelineView" class="timeline"></div>
      </div>

      <!-- Dispo Ansicht -->
      <div id="dispoView" class="dispo">
        <div class="dispoControls">
          <div class="dispoField">
            <label for="dispoWeekInput">Kalenderwoche</label>
            <input type="week" id="dispoWeekInput">
          </div>
          <div class="dispoField" style="min-width:220px;">
            <label for="dispoTitleInput">Titel / Fokus</label>
            <input type="text" id="dispoTitleInput" placeholder="z. B. Schwerpunkte der Woche">
          </div>
          <button class="btnPrimary" id="dispoAddWeek">Neue Woche erfassen</button>
        </div>
        <div class="dispoExplorer">
          <div id="dispoBreadcrumbs" class="dispoBreadcrumbs"></div>
          <div id="dispoList" class="dispoList"></div>
        </div>
      </div>

      <div class="footer" style="display:flex; justify-content:space-between; padding:12px 14px; color:var(--muted); font-size:12px; border-top:1px solid var(--border)">
        <div>Speichern schreibt alle Daten in diese HTML-Datei. Tastenkürzel: <span class="kbd">Strg+S</span>, <span class="kbd">Strg+Z</span>, <span class="kbd">Strg+Y</span></div>
        <div><span class="kbd">Strg+P</span> öffnet die kompakte Druckansicht</div>
      </div>
    </div>
  </div>

  <!-- Farb-Popover -->
  <div class="colorPopover" id="colorPop">
    <div style="font-weight:700; margin-bottom:6px">Projektfarbe</div>
    <input type="color" id="colorPicker" value="#7c3aed" style="width:100%; height:36px; border:1px solid var(--border); border-radius:10px; background:transparent">
    <div class="colorRow">
      <div class="sw" data-v="#7c3aed" style="background:#7c3aed"></div>
      <div class="sw" data-v="#06b6d4" style="background:#06b6d4"></div>
      <div class="sw" data-v="#22c55e" style="background:#22c55e"></div>
      <div class="sw" data-v="#f59e0b" style="background:#f59e0b"></div>
      <div class="sw" data-v="#ef4444" style="background:#ef4444"></div>
    </div>
    <div class="popBtns">
      <button class="btn" id="colorCancel">Abbrechen</button>
      <button class="btnPrimary" id="colorOk">OK</button>
    </div>
  </div>

  <!-- Papierkorb-Dialog -->
  <dialog id="trashDlg">
    <div style="display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid var(--border)">
      <div>Papierkorb</div>
      <button class="btn" id="trashClose">Schließen</button>
    </div>
    <div style="padding:16px">
      <div class="trash-list" id="trashList" style="max-height:360px; overflow:auto"></div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:10px">
        <button class="btn" id="trashEmpty">Papierkorb leeren</button>
      </div>
    </div>
  </dialog>

<dialog id="pathDlg">
  <div style="display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border)">
    <div>Voller Pfad</div>
    <button class="btn" onclick="document.getElementById('pathDlg').close()">Schließen</button>
  </div>
  <div style="padding:14px">
    <pre id="pathFull" style="white-space:pre-wrap;word-break:break-all;margin:0"></pre>
  </div>
</dialog>


<script>
  // ===== Zustand =====
  const embedded = document.getElementById('APP_STATE').textContent
  let state = JSON.parse(embedded || '{}')
  if(!state.timelineTab) state.timelineTab = 'Alle'
  if(!state.timelineZoom) state.timelineZoom = 'days'
  // Verwende einen zufälligen Autosave-Key, damit keine alte Speicherung aus dem
  // localStorage geladen wird. Dies verhindert, dass beim Testen zuvor gespeicherte
  // Zustände automatisch wiederhergestellt werden und beeinflusst die aktuelle Anzeige.
  if(!Array.isArray(state.order)) state.order = []
  if(!state.orderByTab || typeof state.orderByTab !== 'object') state.orderByTab = {}
  if(Array.isArray(state.projects)){
    const seen = new Set()
    state.order = state.order.filter(id => {
      if(!id || seen.has(id)) return false
      seen.add(id)
      return true
    })
    state.projects.forEach(p => {
      if(p && p.id && !seen.has(p.id)){
        state.order.push(p.id)
        seen.add(p.id)
      }
    })
  }
  if(!Array.isArray(state.orderByTab['Alle'])) state.orderByTab['Alle'] = state.order.slice()

  const autosaveKey = 'projekttodos_autosave_' + Math.random().toString(36).slice(2);
  const dirtyDot = document.getElementById('dirtyDot')
  let unsaved = false, fileHandle = null
  const history = [], future = [], selected = new Set()
  const toast = document.getElementById('toast')
  const DAY_MS = 86400000
  let draggingProjectId = null
  let draggingTabName = null
  let draggingGroupId = null
  const TAB_COLOR_PRESETS = [
    '#7C3AED', '#6366F1', '#8B5CF6', '#A855F7', '#EC4899', '#FB7185',
    '#F97316', '#F59E0B', '#FACC15', '#22C55E', '#10B981', '#0EA5E9',
    '#38BDF8', '#14B8A6', '#0F766E', '#2563EB', '#4338CA', '#94A3B8',
    '#64748B', '#1E293B'
  ]
  const DEFAULT_TAB_COLOR = '#7C3AED'

  // ===== Theme / Title =====
  function applyTheme(){
    const isLight = state.theme === 'light'
    document.body.classList.toggle('light', isLight)
    const modeToggle = document.getElementById('modeToggle')
    modeToggle.checked = isLight
    modeToggle.setAttribute('aria-checked', String(isLight))
  }
 function setTitle(){
  const t = (state.title || '').trim() || 'XY-To-Dos';
  document.getElementById('titleText').textContent = t;
  document.title = t;                   // ← Tab-Titel aktualisieren
}

  function snapshot(){ return JSON.parse(JSON.stringify(state)) }
  function setDirty(v){
    unsaved = !!v; dirtyDot.classList.toggle('on', unsaved)
    try{ localStorage.setItem(autosaveKey, JSON.stringify(state)) }catch(e){}
  }
  function showToast(msg){
    toast.textContent = msg
    toast.classList.add('show')
    setTimeout(()=>toast.classList.remove('show'), 1800)
  }
  function parseGermanDate(str){
    if(!str) return null
    const m = String(str).trim().match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/)
    if(!m) return null
    const [, dd, mm, yyyy] = m
    const d = new Date(Date.UTC(Number(yyyy), Number(mm) - 1, Number(dd)))
    return Number.isNaN(d.getTime()) ? null : d
  }
  function parseIsoDate(str){
    if(!str) return null
    const m = String(str).trim().match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/)
    if(!m) return null
    const [, yyyy, mm, dd] = m
    const d = new Date(Date.UTC(Number(yyyy), Number(mm) - 1, Number(dd)))
    return Number.isNaN(d.getTime()) ? null : d
  }
  function formatGermanDate(date){
    if(!(date instanceof Date) || Number.isNaN(date.getTime())) return ''
    const dd = String(date.getUTCDate()).padStart(2,'0')
    const mm = String(date.getUTCMonth()+1).padStart(2,'0')
    const yyyy = date.getUTCFullYear()
    return `${dd}.${mm}.${yyyy}`
  }
  function formatIsoDate(date){
    if(!(date instanceof Date) || Number.isNaN(date.getTime())) return ''
    const dd = String(date.getUTCDate()).padStart(2,'0')
    const mm = String(date.getUTCMonth()+1).padStart(2,'0')
    const yyyy = date.getUTCFullYear()
    return `${yyyy}-${mm}-${dd}`
  }
  function startOfIsoWeek(date){
    const base = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()))
    const dow = base.getUTCDay() || 7
    base.setUTCDate(base.getUTCDate() - (dow - 1))
    return base
  }
  function endOfIsoWeek(date){
    const start = startOfIsoWeek(date)
    const end = new Date(start.getTime())
    end.setUTCDate(start.getUTCDate() + 6)
    return end
  }
  const DATE_PICKER_MONTHS = ['Januar','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember']
  const DATE_PICKER_WEEKDAYS = ['Mo','Di','Mi','Do','Fr','Sa','So']
  const datePickerState = { el:null, anchor:null, year:0, month:0, selected:null, onSelect:null }

  function ensureDatePicker(){
    if(datePickerState.el) return datePickerState.el
    const el = document.createElement('div')
    el.className = 'datePicker'
    el.setAttribute('role','dialog')
    el.setAttribute('aria-modal','true')
    datePickerState.el = el
    document.body.appendChild(el)
    return el
  }
  function renderDatePicker(){
    const picker = ensureDatePicker()
    picker.innerHTML = ''
    const header = document.createElement('header')
    const prev = document.createElement('span')
    prev.className = 'navBtn'
    prev.textContent = '‹'
    prev.addEventListener('click', () => shiftDatePickerMonth(-1))
    const next = document.createElement('span')
    next.className = 'navBtn'
    next.textContent = '›'
    next.addEventListener('click', () => shiftDatePickerMonth(1))
    const title = document.createElement('div')
    title.textContent = `${DATE_PICKER_MONTHS[datePickerState.month]} ${datePickerState.year}`
    header.appendChild(prev)
    header.appendChild(title)
    header.appendChild(next)
    picker.appendChild(header)

    const table = document.createElement('table')
    const thead = document.createElement('thead')
    const headRow = document.createElement('tr')
    DATE_PICKER_WEEKDAYS.forEach(label => {
      const th = document.createElement('th')
      th.textContent = label
      headRow.appendChild(th)
    })
    thead.appendChild(headRow)
    table.appendChild(thead)

    const tbody = document.createElement('tbody')
    const firstOfMonth = new Date(Date.UTC(datePickerState.year, datePickerState.month, 1))
    let cursor = startOfIsoWeek(firstOfMonth)
    for(let w=0; w<6; w++){
      const row = document.createElement('tr')
      for(let d=0; d<7; d++){
        const cellDate = new Date(cursor.getTime())
        const td = document.createElement('td')
        td.textContent = cellDate.getUTCDate()
        if(cellDate.getUTCMonth() !== datePickerState.month){ td.classList.add('disabled') }
        if(datePickerState.selected && cellDate.getTime() === datePickerState.selected.getTime()){
          td.classList.add('selected')
        }
        td.addEventListener('click', () => {
          const cb = datePickerState.onSelect
          const chosen = new Date(cellDate.getTime())
          closeDatePicker()
          if(typeof cb === 'function'){
            cb(chosen)
          }
        })
        row.appendChild(td)
        cursor.setUTCDate(cursor.getUTCDate() + 1)
      }
      tbody.appendChild(row)
    }
    table.appendChild(tbody)
    picker.appendChild(table)
  }
  function positionDatePicker(){
    const picker = datePickerState.el
    if(!picker || !picker.classList.contains('show') || !datePickerState.anchor) return
    picker.style.visibility = 'hidden'
    const rect = datePickerState.anchor.getBoundingClientRect()
    const width = picker.offsetWidth
    const height = picker.offsetHeight
    let left = rect.left
    let top = rect.bottom + 8
    let above = false
    if(top + height > window.innerHeight - 12){
      const potentialTop = rect.top - height - 8
      if(potentialTop >= 12){
        top = potentialTop
        above = true
      }else{
        top = Math.max(12, window.innerHeight - height - 12)
      }
    }
    if(top < 12){ top = 12 }
    if(left + width > window.innerWidth - 12){ left = window.innerWidth - width - 12 }
    if(left < 12){ left = 12 }
    picker.style.left = `${Math.round(left)}px`
    picker.style.top = `${Math.round(top)}px`
    picker.classList.toggle('above', above)
    const anchorCenter = rect.left + rect.width / 2
    const arrowLeft = Math.min(width - 20, Math.max(20, anchorCenter - left))
    picker.style.setProperty('--arrow-left', `${arrowLeft}px`)
    picker.style.visibility = ''
  }
  function shiftDatePickerMonth(delta){
    datePickerState.month += delta
    while(datePickerState.month < 0){ datePickerState.month += 12; datePickerState.year -= 1 }
    while(datePickerState.month > 11){ datePickerState.month -= 12; datePickerState.year += 1 }
    renderDatePicker()
    positionDatePicker()
  }
  function handleDatePickerOutside(ev){
    const picker = datePickerState.el
    if(!picker || !picker.classList.contains('show')) return
    if(picker.contains(ev.target)) return
    if(datePickerState.anchor && datePickerState.anchor.contains(ev.target)) return
    closeDatePicker()
  }
  function handleDatePickerKey(ev){
    if(ev.key === 'Escape') closeDatePicker()
  }
  function closeDatePicker(){
    const picker = datePickerState.el
    if(!picker) return
    picker.classList.remove('show','above')
    picker.style.removeProperty('visibility')
    picker.style.removeProperty('--arrow-left')
    datePickerState.anchor = null
    datePickerState.onSelect = null
    window.removeEventListener('resize', positionDatePicker, true)
    window.removeEventListener('scroll', positionDatePicker, true)
    document.removeEventListener('mousedown', handleDatePickerOutside, true)
    document.removeEventListener('keydown', handleDatePickerKey, true)
  }
  function openDatePicker(anchor, opts = {}){
    if(datePickerState.el && datePickerState.el.classList.contains('show')){
      if(datePickerState.anchor === anchor){
        closeDatePicker()
        return
      }
    }
    const picker = ensureDatePicker()
    const provided = (opts.value instanceof Date && !Number.isNaN(opts.value.getTime())) ? new Date(opts.value.getTime()) : null
    const base = provided || new Date()
    datePickerState.anchor = anchor
    datePickerState.selected = provided
    datePickerState.year = base.getUTCFullYear()
    datePickerState.month = base.getUTCMonth()
    datePickerState.onSelect = typeof opts.onSelect === 'function' ? opts.onSelect : null
    renderDatePicker()
    picker.classList.add('show')
    picker.style.visibility = 'hidden'
    positionDatePicker()
    picker.style.visibility = ''
    document.addEventListener('mousedown', handleDatePickerOutside, true)
    document.addEventListener('keydown', handleDatePickerKey, true)
    window.addEventListener('resize', positionDatePicker, true)
    window.addEventListener('scroll', positionDatePicker, true)
  }
  function ensureTabGroupLayer(){
    let layer = document.getElementById('tabGroupLayer')
    if(!layer){
      layer = document.createElement('div')
      layer.id = 'tabGroupLayer'
      layer.className = 'tab-group-layer'
      document.body.appendChild(layer)
    }
    return layer
  }
  function positionGroupDropdown(anchor, dropdown){
    const layer = ensureTabGroupLayer()
    if(dropdown.parentElement !== layer){
      layer.appendChild(dropdown)
    }
    dropdown.classList.add('floating','show')
    dropdown.style.visibility = 'hidden'
    const rect = anchor.getBoundingClientRect()
    const width = dropdown.offsetWidth
    const height = dropdown.offsetHeight
    let left = rect.left
    let top = rect.bottom + 8
    let above = false
    if(top + height > window.innerHeight - 12){
      const potentialTop = rect.top - height - 8
      if(potentialTop >= 12){
        top = potentialTop
        above = true
      }else{
        top = Math.max(12, window.innerHeight - height - 12)
      }
    }
    if(left + width > window.innerWidth - 12){ left = window.innerWidth - width - 12 }
    if(left < 12){ left = 12 }
    dropdown.style.left = `${Math.round(left)}px`
    dropdown.style.top = `${Math.round(top)}px`
    dropdown.classList.toggle('above', above)
    const anchorCenter = rect.left + rect.width / 2
    const arrowLeft = Math.min(width - 24, Math.max(24, anchorCenter - left))
    dropdown.style.setProperty('--arrow-left', `${arrowLeft}px`)
    dropdown.style.visibility = ''
  }
  function resetGroupDropdown(dropdown, container){
    dropdown.classList.remove('floating','above','show')
    dropdown.style.removeProperty('left')
    dropdown.style.removeProperty('top')
    dropdown.style.removeProperty('--arrow-left')
    dropdown.style.removeProperty('visibility')
    const layer = document.getElementById('tabGroupLayer')
    if(layer && dropdown.parentElement === layer){
      layer.removeChild(dropdown)
    }
    if(container && dropdown.parentElement !== container){
      container.appendChild(dropdown)
    }
  }
  const openTabGroupDropdowns = new Set()
  function closeAllGroupDropdowns(){
    const current = Array.from(openTabGroupDropdowns)
    current.forEach(drop => {
      if(typeof drop.__close === 'function'){
        drop.__close()
      }else{
        resetGroupDropdown(drop, drop.__home || null)
        openTabGroupDropdowns.delete(drop)
      }
    })
  }

  // Die automatische Wiederherstellung des zuletzt gespeicherten Zustands wird deaktiviert.
  // Dadurch kann diese HTML-Datei ohne Beeinflussung durch frühere Session‑Daten getestet werden.
  /*
  try{
    const auto = localStorage.getItem(autosaveKey)
    if(auto && JSON.stringify(JSON.parse(auto)) !== JSON.stringify(state)){
      if(confirm('Nicht gespeicherte Änderungen gefunden. Wiederherstellen?')) state = JSON.parse(auto)
    }
  }catch(e){}
  */

  window.addEventListener('beforeunload', e => { if(unsaved){ e.preventDefault(); e.returnValue = '' } })
  window.addEventListener('unhandledrejection', ev => {
    if(isAbortError(ev.reason)){
      ev.preventDefault()
    }
  })

  // ===== Utils =====
  const tbody = document.getElementById('tbody')
  let emptyRow = document.getElementById('emptyRow')
  if(!emptyRow){
    emptyRow = document.createElement('tr')
    emptyRow.id = 'emptyRow'
    const td = document.createElement('td')
    td.colSpan = 7
    td.className = 'emptyRowCell'
    td.textContent = 'Keine Projekte gefunden'
    emptyRow.appendChild(td)
  }
  if(tbody){
    tbody.addEventListener('dragover', e => {
      if(state.filters.sort !== 'manual') return
      if(!getDragProjectId(e)) return
      e.preventDefault()
      e.dataTransfer.dropEffect = 'move'
    })
    tbody.addEventListener('drop', e => {
      e.preventDefault()
      if(state.filters.sort !== 'manual'){
        showToast('Sortierung auf „Manuell“ stellen, um die Reihenfolge zu ändern.');
        return
      }
      const dragId = getDragProjectId(e)
      if(!dragId) return
      pushHistory()
      const activeTab = state.currentTab || 'Alle'
      const order = ensureManualOrder(projectIdsForTab(activeTab), activeTab)
      const from = order.indexOf(dragId)
      if(from >= 0) order.splice(from,1)
      const rows = Array.from(tbody.querySelectorAll('tr[data-id]'))
      const pointerY = e.clientY
      let beforeId = ''
      for(const row of rows){
        const rect = row.getBoundingClientRect()
        if(pointerY < rect.top + rect.height / 2){
          beforeId = row.dataset.id || ''
          break
        }
      }
      let insertIdx = order.length
      if(beforeId){
        const idx = order.indexOf(beforeId)
        if(idx >= 0) insertIdx = idx
      }
      if(insertIdx < 0) insertIdx = 0
      if(insertIdx > order.length) insertIdx = order.length
      order.splice(insertIdx, 0, dragId)
      if(activeTab === 'Alle'){
        state.order = order
        state.orderByTab['Alle'] = order.slice()
      }else{
        state.orderByTab[activeTab] = order
      }
      setDirty(true)
      render()
      draggingProjectId = null
    })
  }
  const tabsEl = document.getElementById('tabs')
  const tabsScroll = document.getElementById('tabsScroll')
  const tabsScrollbar = document.getElementById('tabsScrollbar')
  const tabsThumb = document.getElementById('tabsThumb')
  const tabMenu = document.createElement('div')
  tabMenu.className = 'tab-menu'
  document.body.appendChild(tabMenu)
  const tabSubmenu = document.createElement('div')
  tabSubmenu.className = 'tab-submenu'
  document.body.appendChild(tabSubmenu)
  const colorPalette = document.createElement('div')
  colorPalette.className = 'color-palette'
  const colorGrid = document.createElement('div')
  colorGrid.className = 'color-grid'
  colorPalette.appendChild(colorGrid)
  const customColorRow = document.createElement('div')
  customColorRow.className = 'custom-color'
  const customColorLabel = document.createElement('span')
  customColorLabel.textContent = 'Eigene Farbe'
  const customColorPicker = document.createElement('input')
  customColorPicker.type = 'color'
  customColorPicker.value = DEFAULT_TAB_COLOR
  const customColorInput = document.createElement('input')
  customColorInput.type = 'text'
  customColorInput.placeholder = '#RRGGBB'
  customColorInput.autocomplete = 'off'
  customColorInput.spellcheck = false
  const customColorApply = document.createElement('button')
  customColorApply.type = 'button'
  customColorApply.textContent = 'Übernehmen'
  customColorRow.appendChild(customColorLabel)
  customColorRow.appendChild(customColorPicker)
  customColorRow.appendChild(customColorInput)
  customColorRow.appendChild(customColorApply)
  colorPalette.appendChild(customColorRow)
  const resetColorBtn = document.createElement('button')
  resetColorBtn.type = 'button'
  resetColorBtn.className = 'reset-btn'
  resetColorBtn.textContent = 'Standardfarbe verwenden'
  colorPalette.appendChild(resetColorBtn)
  document.body.appendChild(colorPalette)

  let activeMenuAnchor = null
  let activeSubmenuAnchor = null
  let submenuHideTimer = null
  let colorPaletteCallback = null
  function setCustomColorInputs(hex){
    const normalized = normalizeHexColor(hex) || DEFAULT_TAB_COLOR
    customColorPicker.value = normalized
    customColorInput.value = normalized
    customColorInput.classList.remove('invalid')
  }

  function closeSubmenu(){
    tabSubmenu.classList.remove('show')
    tabSubmenu.innerHTML = ''
    activeSubmenuAnchor = null
  }

  function closeColorPalette(){
    colorPalette.classList.remove('show')
    customColorInput.classList.remove('invalid')
    colorPaletteCallback = null
  }

  function closeTabMenu(){
    if(tabMenu.classList.contains('show')){
      tabMenu.classList.remove('show')
      tabMenu.innerHTML = ''
    }
    closeSubmenu()
    activeMenuAnchor = null
  }

  function openTabSubmenu(anchor, items){
    if(!anchor || !Array.isArray(items) || !items.length) return
    tabSubmenu.innerHTML = ''
    items.forEach(item => {
      if(item && item.type === 'divider'){
        const hr = document.createElement('hr')
        hr.style.margin = '4px 0'
        hr.style.border = 'none'
        hr.style.borderTop = '1px solid ' + getComputedStyle(document.body).getPropertyValue('--border')
        tabSubmenu.appendChild(hr)
        return
      }
      const btn = document.createElement('button')
      btn.type = 'button'
      btn.textContent = item && item.label ? item.label : 'Option'
      if(item && item.icon){
        const icon = document.createElement('span')
        icon.className = 'ms'
        icon.textContent = item.icon
        btn.prepend(icon)
      }
      if(item && item.disabled) btn.disabled = true
      btn.addEventListener('click', e => {
        e.preventDefault(); e.stopPropagation()
        closeTabMenu()
        if(item && typeof item.action === 'function') item.action({ event:e, anchor:btn, close:closeTabMenu })
      })
      tabSubmenu.appendChild(btn)
    })
    const rect = anchor.getBoundingClientRect()
    const menuRect = tabSubmenu.getBoundingClientRect()
    const width = Math.max(menuRect.width || 0, 200)
    const left = Math.min(window.innerWidth - width - 12, rect.right + 8)
    tabSubmenu.style.left = left + 'px'
    tabSubmenu.style.top = rect.top + window.scrollY + 'px'
    tabSubmenu.classList.add('show')
    activeSubmenuAnchor = anchor
  }

  function openColorPalette(anchor, { currentColor = '', onSelect } = {}){
    if(!anchor) return
    colorPaletteCallback = typeof onSelect === 'function' ? onSelect : null
    colorGrid.innerHTML = ''
    const selected = normalizeHexColor(currentColor)
    const selectedLower = selected ? selected.toLowerCase() : ''
    TAB_COLOR_PRESETS.forEach(color => {
      const normalized = normalizeHexColor(color) || color
      const sw = document.createElement('button')
      sw.type = 'button'
      sw.className = 'color-swatch'
      sw.style.background = normalized
      if(selectedLower && selectedLower === normalized.toLowerCase()) sw.classList.add('selected')
      sw.addEventListener('click', e => {
        e.preventDefault(); e.stopPropagation()
        if(colorPaletteCallback) colorPaletteCallback(normalized)
        closeColorPalette()
      })
      colorGrid.appendChild(sw)
    })
    setCustomColorInputs(selected || DEFAULT_TAB_COLOR)
    const rect = anchor.getBoundingClientRect()
    const paletteRect = colorPalette.getBoundingClientRect()
    const width = Math.max(paletteRect.width || 0, 220)
    let left = rect.left
    if(left + width + 12 > window.innerWidth) left = window.innerWidth - width - 12
    if(left < 12) left = 12
    colorPalette.style.left = left + 'px'
    colorPalette.style.top = rect.bottom + window.scrollY + 8 + 'px'
    colorPalette.classList.add('show')
  }

  customColorPicker.addEventListener('input', () => {
    customColorInput.value = customColorPicker.value.toUpperCase()
    customColorInput.classList.remove('invalid')
  })
  customColorPicker.addEventListener('change', e => {
    e.preventDefault(); e.stopPropagation()
    if(colorPaletteCallback) colorPaletteCallback(customColorPicker.value.toUpperCase())
    closeColorPalette()
  })
  customColorInput.addEventListener('input', () => {
    customColorInput.classList.remove('invalid')
    const normalized = normalizeHexColor(customColorInput.value)
    if(normalized){
      customColorPicker.value = normalized
    }
  })
  customColorInput.addEventListener('keydown', e => {
    if(e.key === 'Enter'){
      e.preventDefault()
      customColorApply.click()
    }
  })
  customColorApply.addEventListener('click', e => {
    e.preventDefault(); e.stopPropagation()
    const normalized = normalizeHexColor(customColorInput.value)
    if(normalized){
      if(colorPaletteCallback) colorPaletteCallback(normalized)
      closeColorPalette()
    }else{
      customColorInput.classList.add('invalid')
    }
  })

  resetColorBtn.addEventListener('click', e => {
    e.preventDefault(); e.stopPropagation()
    if(colorPaletteCallback) colorPaletteCallback('')
    closeColorPalette()
  })

  tabSubmenu.addEventListener('mouseenter', () => { clearTimeout(submenuHideTimer) })
  tabSubmenu.addEventListener('mouseleave', () => {
    clearTimeout(submenuHideTimer)
    submenuHideTimer = setTimeout(() => closeSubmenu(), 120)
  })

  function openTabMenu(anchor, items){
    if(!anchor || !Array.isArray(items) || !items.length) return
    closeSubmenu()
    closeColorPalette()
    tabMenu.innerHTML = ''
    items.forEach(item => {
      if(item && item.type === 'divider'){
        const hr = document.createElement('hr')
        hr.style.margin = '4px 0'
        hr.style.border = 'none'
        hr.style.borderTop = '1px solid ' + getComputedStyle(document.body).getPropertyValue('--border')
        tabMenu.appendChild(hr)
        return
      }
      const btn = document.createElement('button')
      btn.type = 'button'
      btn.textContent = item && item.label ? item.label : 'Option'
      if(item && item.icon){
        const icon = document.createElement('span')
        icon.className = 'ms'
        icon.textContent = item.icon
        btn.prepend(icon)
      }
      if(item && item.disabled) btn.disabled = true
      const submenuItems = Array.isArray(item && item.submenu) ? item.submenu.filter(Boolean) : null
      if(submenuItems && submenuItems.length){
        btn.classList.add('has-submenu')
        const arrow = document.createElement('span')
        arrow.className = 'ms submenu-arrow'
        arrow.textContent = 'chevron_right'
        btn.appendChild(arrow)
        const showSub = () => {
          clearTimeout(submenuHideTimer)
          openTabSubmenu(btn, submenuItems)
        }
        const scheduleHide = () => {
          clearTimeout(submenuHideTimer)
          submenuHideTimer = setTimeout(() => {
            if(activeSubmenuAnchor === btn) closeSubmenu()
          }, 150)
        }
        btn.addEventListener('mouseenter', showSub)
        btn.addEventListener('focus', showSub)
        btn.addEventListener('mouseleave', scheduleHide)
      }else{
        btn.addEventListener('click', e => {
          e.preventDefault(); e.stopPropagation()
          const ctx = { event:e, anchor:btn, close:closeTabMenu, openColorPalette }
          const res = item && typeof item.action === 'function' ? item.action(ctx) : undefined
          if(res === false || (item && item.keepOpen)) return
          closeTabMenu()
        })
      }
      tabMenu.appendChild(btn)
    })
    const rect = anchor.getBoundingClientRect()
    const menuRect = tabMenu.getBoundingClientRect()
    const menuWidth = Math.max(menuRect.width || 0, 200)
    const left = Math.min(window.innerWidth - menuWidth - 12, Math.max(12, rect.left))
    tabMenu.style.left = left + 'px'
    tabMenu.style.right = 'auto'
    tabMenu.style.top = rect.bottom + window.scrollY + 6 + 'px'
    tabMenu.classList.add('show')
    activeMenuAnchor = anchor
  }

  document.addEventListener('click', e => {
    if(tabMenu.classList.contains('show')){
      if(tabMenu.contains(e.target) || (activeMenuAnchor && activeMenuAnchor.contains(e.target)) || tabSubmenu.contains(e.target)){
        return
      }
      closeTabMenu()
    }
    if(colorPalette.classList.contains('show') && !colorPalette.contains(e.target)){
      closeColorPalette()
    }
  })
  document.addEventListener('keydown', e => {
    if(e.key === 'Escape'){
      closeTabMenu()
      closeColorPalette()
    }
  })
  window.addEventListener('resize', () => { closeTabMenu(); closeColorPalette(); updateTabsOverflow() })
  window.addEventListener('scroll', () => { closeTabMenu(); closeColorPalette() }, true)

  let tabsThumbDragging = false
  let tabsThumbPointerId = null
  let tabsThumbDragStartX = 0
  let tabsThumbStartScroll = 0

  function updateTabsOverflow(){
    if(!tabsScroll || !tabsScrollbar || !tabsThumb) return
    const overflow = tabsScroll.scrollWidth - tabsScroll.clientWidth > 2
    tabsScrollbar.classList.toggle('show', overflow)
    tabsScroll.classList.toggle('is-overflowing', overflow)
    if(!overflow){
      tabsThumb.style.transform = 'translateX(0)'
      return
    }
    const trackWidth = tabsScrollbar.clientWidth || tabsScroll.clientWidth
    const ratio = tabsScroll.clientWidth / Math.max(tabsScroll.scrollWidth, 1)
    const thumbWidth = Math.min(Math.max(Math.round(trackWidth * ratio), 32), trackWidth)
    tabsThumb.style.width = thumbWidth + 'px'
    const maxScroll = Math.max(tabsScroll.scrollWidth - tabsScroll.clientWidth, 1)
    const maxOffset = Math.max(trackWidth - thumbWidth, 1)
    const offset = (tabsScroll.scrollLeft / maxScroll) * maxOffset
    tabsThumb.style.transform = `translateX(${Math.min(Math.max(offset, 0), maxOffset)}px)`
  }

  if(tabsScroll){
    tabsScroll.addEventListener('scroll', updateTabsOverflow)
    tabsScroll.addEventListener('wheel', e => {
      if(Math.abs(e.deltaY) <= Math.abs(e.deltaX)) return
      tabsScroll.scrollLeft += e.deltaY
      e.preventDefault()
    }, { passive:false })
  }

  if(tabsThumb){
    const stopThumbDrag = () => {
      if(!tabsThumbDragging) return
      tabsThumbDragging = false
      if(tabsThumbPointerId !== null){
        try{ tabsThumb.releasePointerCapture(tabsThumbPointerId) }catch(err){}
      }
      tabsThumbPointerId = null
    }
    tabsThumb.addEventListener('pointerdown', e => {
      if(!tabsScrollbar || !tabsScroll || !tabsScrollbar.classList.contains('show')) return
      tabsThumbDragging = true
      tabsThumbPointerId = e.pointerId
      tabsThumbDragStartX = e.clientX
      tabsThumbStartScroll = tabsScroll.scrollLeft
      try{ tabsThumb.setPointerCapture(e.pointerId) }catch(err){}
      e.preventDefault()
    })
    tabsThumb.addEventListener('pointermove', e => {
      if(!tabsThumbDragging || e.pointerId !== tabsThumbPointerId) return
      const trackWidth = tabsScrollbar.clientWidth || tabsScroll.clientWidth
      const thumbWidth = tabsThumb.offsetWidth || 1
      const maxOffset = Math.max(trackWidth - thumbWidth, 1)
      const delta = e.clientX - tabsThumbDragStartX
      const scrollMax = Math.max(tabsScroll.scrollWidth - tabsScroll.clientWidth, 1)
      const scrollDelta = (delta / maxOffset) * scrollMax
      tabsScroll.scrollLeft = Math.min(Math.max(tabsThumbStartScroll + scrollDelta, 0), scrollMax)
      e.preventDefault()
    })
    tabsThumb.addEventListener('pointerup', stopThumbDrag)
    tabsThumb.addEventListener('pointercancel', stopThumbDrag)
  }

  if(tabsScrollbar){
    tabsScrollbar.addEventListener('pointerdown', e => {
      if(!tabsScroll || !tabsScrollbar.classList.contains('show') || e.target === tabsThumb) return
      const rect = tabsScrollbar.getBoundingClientRect()
      const ratio = (e.clientX - rect.left) / rect.width
      const scrollMax = Math.max(tabsScroll.scrollWidth - tabsScroll.clientWidth, 0)
      tabsScroll.scrollLeft = Math.min(Math.max(ratio * scrollMax, 0), scrollMax)
      e.preventDefault()
    })
  }

  if(typeof ResizeObserver === 'function' && tabsScroll){
    const ro = new ResizeObserver(() => updateTabsOverflow())
    ro.observe(tabsScroll)
  }
  if(tabsScroll) requestAnimationFrame(() => updateTabsOverflow())

  function normalizeHexColor(value){
    if(value == null) return null
    let hex = String(value).trim()
    if(!hex) return null
    if(hex[0] !== '#') hex = '#' + hex
    if(/^#([0-9a-fA-F]{3})$/.test(hex)){
      hex = '#' + hex.slice(1).split('').map(ch => ch + ch).join('')
    }
    if(/^#([0-9a-fA-F]{6})$/.test(hex)) return hex.toUpperCase()
    return null
  }

  function contrastColor(hex){
    const match = /^#?([0-9a-fA-F]{6})$/.exec(hex || '')
    if(!match) return '#ffffff'
    const value = parseInt(match[1], 16)
    const r = (value >> 16) & 255
    const g = (value >> 8) & 255
    const b = value & 255
    const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255
    return luminance > 0.6 ? '#0f172a' : '#ffffff'
  }

  function detachTabFromGroups(name){
    if(!name || name === 'Alle') return
    state.tabGroups.forEach(group => {
      if(Array.isArray(group.tabs)) group.tabs = group.tabs.filter(t => t !== name)
    })
    if(state.tabMeta[name]) state.tabMeta[name].groupId = ''
  }

    function moveTabBefore(tabName, beforeName){
      if(!tabName || tabName === 'Alle') return
      detachTabFromGroups(tabName)
      const key = 'tab:' + tabName
      state.tabOrder = state.tabOrder.filter(entry => entry !== key)
      if(beforeName && beforeName !== 'Alle'){
        const beforeKey = 'tab:' + beforeName
        const idx = state.tabOrder.indexOf(beforeKey)
        if(idx >= 0) state.tabOrder.splice(idx, 0, key)
        else state.tabOrder.push(key)
      }else{
        state.tabOrder.push(key)
      }
      ensureTabs()
    }

    function moveTabToGroup(tabName, groupId, position){
      if(!tabName || tabName === 'Alle' || !groupId) return
      const group = state.tabGroups.find(g => g.id === groupId)
      if(!group) return
      detachTabFromGroups(tabName)
      state.tabOrder = state.tabOrder.filter(entry => entry !== 'tab:' + tabName)
      if(!state.tabMeta[tabName]) state.tabMeta[tabName] = {}
      state.tabMeta[tabName].groupId = groupId
      if(!Array.isArray(group.tabs)) group.tabs = []
      group.tabs = group.tabs.filter(t => t !== tabName)
      const insertAt = typeof position === 'number' && position >= 0 && position <= group.tabs.length ? position : group.tabs.length
      group.tabs.splice(insertAt, 0, tabName)
      if(!state.tabOrder.includes('group:' + groupId)) state.tabOrder.push('group:' + groupId)
      ensureTabs()
    }

    function moveTabWithinGroup(tabName, groupId, beforeName){
      if(!tabName || tabName === 'Alle' || !groupId) return
      const group = state.tabGroups.find(g => g.id === groupId)
      if(!group){ moveTabToGroup(tabName, groupId); return }
      const idx = beforeName ? group.tabs.indexOf(beforeName) : -1
      moveTabToGroup(tabName, groupId, idx >= 0 ? idx : group.tabs.length)
    }

    function moveGroupBefore(groupId, beforeGroupId){
      if(!groupId) return
      const key = 'group:' + groupId
      state.tabOrder = state.tabOrder.filter(entry => entry !== key)
      if(beforeGroupId){
        const idx = state.tabOrder.indexOf('group:' + beforeGroupId)
        if(idx >= 0) state.tabOrder.splice(idx, 0, key)
        else state.tabOrder.push(key)
      }else{
        state.tabOrder.push(key)
      }
      ensureTabs()
    }

    function assignProjectToTab(projectId, tabName){
      if(!projectId || !tabName) return
      const p = (state.projects || []).find(pr => pr.id === projectId)
      if(p) p.tab = tabName
    }

    function createTab(){
      const nn = prompt('Name des neuen Tabs')
      if(!nn) return
      const name = nn.trim()
      if(!name || name === 'Alle') return
      if(state.tabs.includes(name)){
        showToast('Tab existiert bereits.')
        return
      }
      pushHistory()
      state.tabs.push(name)
      state.tabMeta[name] = state.tabMeta[name] || { color:'', groupId:'' }
      moveTabBefore(name)
      state.currentTab = name
      if(state.view === 'timeline') state.timelineTab = name
      setDirty(true); render()
    }

    function createGroup(){
      const nn = prompt('Name der neuen Gruppe')
      if(!nn) return
      const name = nn.trim()
      if(!name) return
      pushHistory()
      const id = 'grp_' + uid()
      state.tabGroups.push({ id, name, color:'', tabs: [] })
      if(!state.tabOrder.includes('group:' + id)) state.tabOrder.push('group:' + id)
      ensureTabs()
      setDirty(true); render()
    }

    function renameTabPrompt(name){
      if(!name || name === 'Alle') return
      const nn = prompt('Neuer Name für Tab', name)
      if(!nn) return
      const trimmed = nn.trim()
      if(!trimmed || trimmed === 'Alle') return
      if(trimmed === name) return
      if(state.tabs.includes(trimmed)){
        showToast('Name bereits vergeben.')
        return
      }
      pushHistory()
      state.projects.forEach(p => { if(p.tab === name) p.tab = trimmed })
      state.tabGroups.forEach(group => {
        if(Array.isArray(group.tabs)) group.tabs = group.tabs.map(t => t === name ? trimmed : t)
      })
      state.tabOrder = state.tabOrder.map(entry => entry === 'tab:' + name ? 'tab:' + trimmed : entry)
      if(state.tabMeta[name]){
        state.tabMeta[trimmed] = { ...state.tabMeta[name] }
        delete state.tabMeta[name]
      }else{
        state.tabMeta[trimmed] = { color:'', groupId:'' }
      }
      state.tabs = state.tabs.map(t => t === name ? trimmed : t)
      if(state.currentTab === name) state.currentTab = trimmed
      if(state.timelineTab === name) state.timelineTab = trimmed
      ensureTabs()
      setDirty(true); render()
    }

    function deleteTabByName(name){
      if(!name || name === 'Alle') return
      if(!confirm('Tab löschen? Projekte werden nach „Alle“ verschoben.')) return
      pushHistory()
      state.projects.forEach(p => { if(p.tab === name) p.tab = 'Alle' })
      state.tabGroups.forEach(group => {
        if(Array.isArray(group.tabs)) group.tabs = group.tabs.filter(t => t !== name)
      })
      state.tabOrder = state.tabOrder.filter(entry => entry !== 'tab:' + name)
      delete state.tabMeta[name]
      state.tabs = state.tabs.filter(t => t !== name)
      if(state.currentTab === name) state.currentTab = 'Alle'
      if(state.timelineTab === name) state.timelineTab = 'Alle'
      ensureTabs()
      setDirty(true); render()
    }

    function changeTabColor(name, anchor){
      if(!name) return false
      const meta = state.tabMeta[name] || {}
      const anchorEl = anchor || document.querySelector(`.tab[data-name="${CSS && CSS.escape ? CSS.escape(name) : name}"] .tab-more`)
      if(!anchorEl){
        showToast('Farbauswahl nicht möglich')
        return false
      }
      openColorPalette(anchorEl, {
        currentColor: meta.color || '',
        onSelect: color => {
          pushHistory()
          state.tabMeta[name] = state.tabMeta[name] || {}
          state.tabMeta[name].color = (color || '').toLowerCase()
          setDirty(true); render()
          closeTabMenu()
        }
      })
      requestAnimationFrame(() => closeTabMenu())
      return false
    }

    function changeGroupColor(group, anchor){
      if(!group) return false
      const targetId = group.id
      const anchorEl = anchor || document.querySelector(`.tab.is-group[data-group-id="${CSS && CSS.escape ? CSS.escape(targetId) : targetId}"] .tab-group-toggle`)
      if(!anchorEl){
        showToast('Farbauswahl nicht möglich')
        return false
      }
      openColorPalette(anchorEl, {
        currentColor: group.color || '',
        onSelect: color => {
          pushHistory()
          group.color = (color || '').toLowerCase()
          setDirty(true); render()
          closeTabMenu()
        }
      })
      requestAnimationFrame(() => closeTabMenu())
      return false
    }

    function renameGroupPrompt(group){
      if(!group) return
      const nn = prompt('Neuer Name für Gruppe', group.name)
      if(!nn) return
      const trimmed = nn.trim()
      if(!trimmed) return
      pushHistory()
      group.name = trimmed
      setDirty(true); render()
    }

    function deleteGroup(group){
      if(!group) return
      if(!confirm('Gruppe löschen? Tabs werden oben einsortiert.')) return
      pushHistory()
      const tabs = Array.isArray(group.tabs) ? [...group.tabs] : []
      tabs.forEach(name => {
        detachTabFromGroups(name)
        moveTabBefore(name)
      })
      state.tabGroups = state.tabGroups.filter(g => g.id !== group.id)
      state.tabOrder = state.tabOrder.filter(entry => entry !== 'group:' + group.id)
      ensureTabs()
      setDirty(true); render()
    }
  const bulkbar = document.getElementById('bulkbar')
  const bulkTarget = document.getElementById('bulkTarget')
  const selCount = document.getElementById('selCount')
  const tableView = document.getElementById('tableView')
  const kanbanView = document.getElementById('kanbanView')
  const timelineShell = document.getElementById('timelineShell')
  const timelineViewEl = document.getElementById('timelineView')
  const timelineTabSelect = document.getElementById('timelineTabSelect')
  const timelineZoomInput = document.getElementById('timelineZoom')
  const timelineZoomLabelsEl = document.getElementById('timelineZoomLabels')
  const dispoView = document.getElementById('dispoView')
    const dispoListEl = document.getElementById('dispoList')
    const dispoBreadcrumbsEl = document.getElementById('dispoBreadcrumbs')
  const dispoWeekInput = document.getElementById('dispoWeekInput')
  const dispoTitleInput = document.getElementById('dispoTitleInput')
  const dispoAddWeekBtn = document.getElementById('dispoAddWeek')
  const toolbar = document.getElementById('addForm')
  const filterbar = document.querySelector('.filterbar')
  const kanbanPlaceholder = document.createElement('div')
  kanbanPlaceholder.className = 'kbPlaceholder'
    const TIMELINE_ZOOMS = [
      { value:'weeks',   label:'KW',       min:8,  max:16, showDays:false, labelStep:7, unitDays:7 },
      { value:'compact', label:'Kompakt',  min:14, max:26, showDays:true,  labelStep:2, unitDays:1 },
      { value:'days',    label:'Tage',     min:20, max:40, showDays:true,  labelStep:1, unitDays:1 }
    ]

    const MONTH_NAMES = ['Januar','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember']
    const dispoNavigator = { year:null, month:null }

  if(timelineZoomLabelsEl){
    timelineZoomLabelsEl.innerHTML = ''
    TIMELINE_ZOOMS.forEach(z => {
      const span = document.createElement('span')
      span.textContent = z.label
      timelineZoomLabelsEl.appendChild(span)
    })
  }
  if(timelineZoomInput){
    timelineZoomInput.max = String(Math.max(0, TIMELINE_ZOOMS.length - 1))
  }

  function updateTimelineZoomIndicator(value){
    const idx = TIMELINE_ZOOMS.findIndex(z => z.value === (value || state.timelineZoom))
    const activeIdx = idx >= 0 ? idx : Math.max(0, TIMELINE_ZOOMS.length - 1)
    if(timelineZoomInput){
      timelineZoomInput.value = String(activeIdx)
    }
    if(timelineZoomLabelsEl){
      Array.from(timelineZoomLabelsEl.children).forEach((node, i) => {
        node.classList.toggle('active', i === activeIdx)
      })
    }
  }

  function clampPct(n){ n = Number.isFinite(+n) ? +n : 0; return Math.max(0, Math.min(100, Math.round(n))) }
  function uid(){ return Math.random().toString(36).slice(2,9) }
  function todayYMD(){ return new Date().toISOString().slice(0,10) }
  function progressOf(p){
    const todos = Array.isArray(p.todos) ? p.todos : []
    const total = todos.length
    const done  = todos.filter(t => t.done).length
    const emptyComplete = !!p.emptyDone && total === 0
    let pct
    let status
    if(total === 0){
      pct = emptyComplete ? 100 : 0
      status = emptyComplete ? 'done' : 'open'
    }else{
      pct = Math.round((done/total)*100)
      status = done === 0 ? 'open' : done === total ? 'done' : 'partial'
    }
    return { total, done, pct, status, emptyComplete }
  }
  function orderKeyForTab(tab){
    return (tab && tab !== 'Alle') ? tab : 'Alle'
  }
  function projectIdsForTab(tab){
    const key = orderKeyForTab(tab)
    return (state.projects || [])
      .filter(p => key === 'Alle' ? true : (p.tab || 'Alle') === key)
      .map(p => p.id)
      .filter(Boolean)
  }
  function getManualOrderArray(tab){
    const key = orderKeyForTab(tab)
    if(key === 'Alle'){
      if(!Array.isArray(state.order)) state.order = []
      return state.order
    }
    if(!state.orderByTab || typeof state.orderByTab !== 'object') state.orderByTab = {}
    if(!Array.isArray(state.orderByTab[key])) state.orderByTab[key] = []
    const ids = projectIdsForTab(key)
    const allowed = new Set(ids)
    const unique = new Set()
    state.orderByTab[key] = state.orderByTab[key].filter(id => {
      if(!allowed.has(id) || unique.has(id)) return false
      unique.add(id)
      return true
    })
    ids.forEach(id => {
      if(!unique.has(id)){
        state.orderByTab[key].push(id)
        unique.add(id)
      }
    })
    return state.orderByTab[key]
  }
  function ensureManualOrder(idList, tab){
    const order = getManualOrderArray(tab)
    const key = orderKeyForTab(tab)
    const validIds = new Set(projectIdsForTab(key))
    const seen = new Set()
    for(let i = order.length - 1; i >= 0; i--){
      const id = order[i]
      if(!validIds.has(id) || seen.has(id)) order.splice(i,1)
      else seen.add(id)
    }
    const source = Array.isArray(idList) && idList.length ? idList : Array.from(validIds)
    source.forEach(id => {
      if(validIds.has(id) && !seen.has(id)){
        order.push(id)
        seen.add(id)
      }
    })
    if(key === 'Alle'){
      state.order = order
      if(Array.isArray(state.orderByTab['Alle'])) state.orderByTab['Alle'] = order.slice()
    }else{
      state.orderByTab[key] = order
    }
    return order
  }
  function getDragProjectId(evt){
    if(!evt || !evt.dataTransfer) return draggingProjectId
    const types = evt.dataTransfer.types || []
    let id = ''
    if(types.includes && types.includes('text/proj')){
      id = evt.dataTransfer.getData('text/proj')
    }
    if(!id){
      try{ id = evt.dataTransfer.getData('text/plain') }catch(err){ /* ignore */ }
    }
    if(!id){ id = draggingProjectId }
    return id || ''
  }
  function clearKanbanPlaceholder(){
    if(kanbanPlaceholder.parentElement) kanbanPlaceholder.parentElement.removeChild(kanbanPlaceholder)
    kanbanPlaceholder.dataset.before = ''
    kanbanPlaceholder.dataset.col = ''
  }
  function positionKanbanPlaceholder(list, clientY){
    if(!list) return
    const cards = Array.from(list.querySelectorAll('.kbCard'))
    let placed = false
    for(const card of cards){
      if(card.classList.contains('dragging')) continue
      const rect = card.getBoundingClientRect()
      if(clientY < rect.top + rect.height / 2){
        list.insertBefore(kanbanPlaceholder, card)
        kanbanPlaceholder.dataset.before = card.dataset.id || ''
        placed = true
        break
      }
    }
    if(!placed){
      list.appendChild(kanbanPlaceholder)
      kanbanPlaceholder.dataset.before = ''
    }
    const col = list.closest('.kbCol')
    kanbanPlaceholder.dataset.col = col ? (col.dataset.col || '') : (list.dataset.col || '')
  }
  function commitKanbanDrop(dragId, targetCol, beforeId){
    if(!dragId) return false
    const proj = (state.projects || []).find(p => p.id === dragId)
    if(!proj) return false
    pushHistory()
    applyKanbanStatus(proj, targetCol)
    state.filters.sort = 'manual'
    const sortSelect = document.getElementById('sort')
    if(sortSelect) sortSelect.value = 'manual'
    const order = ensureManualOrder((state.projects || []).map(p => p.id), 'Alle')
    const from = order.indexOf(dragId)
    if(from >= 0) order.splice(from, 1)
    let insertIdx = order.length
    if(beforeId){
      const idx = order.indexOf(beforeId)
      if(idx >= 0) insertIdx = idx
    }else{
      const desiredStatus = targetCol === 'done' ? 'done' : targetCol === 'partial' ? 'partial' : 'open'
      for(let i = order.length - 1; i >= 0; i--){
        const other = state.projects.find(x => x.id === order[i])
        if(other && progressOf(other).status === desiredStatus){ insertIdx = i + 1; break }
      }
    }
    if(insertIdx < 0) insertIdx = 0
    if(insertIdx > order.length) insertIdx = order.length
    order.splice(insertIdx, 0, dragId)
    state.order = order
    state.orderByTab['Alle'] = order.slice()
    setDirty(true)
    render()
    return true
  }
  function isoWeekOf(date){
    const target = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()))
    const day = target.getUTCDay() || 7
    target.setUTCDate(target.getUTCDate() + 4 - day)
    const yearStart = new Date(Date.UTC(target.getUTCFullYear(), 0, 1))
    const weekNo = Math.ceil(((target - yearStart) / DAY_MS + 1) / 7)
    return { week: weekNo, year: target.getUTCFullYear() }
  }
  function parseWeekValue(value){
    const match = /^\s*(\d{4})-W(\d{1,2})\s*$/.exec(value || '')
    if(match){
      const year = parseInt(match[1], 10)
      let week = parseInt(match[2], 10)
      if(Number.isFinite(year) && Number.isFinite(week)){
        week = Math.max(1, Math.min(53, week))
        return { year, week }
      }
    }
    return isoWeekOf(new Date())
  }
  function formatWeekValue(year, week){
    return `${year}-W${String(week).padStart(2,'0')}`
  }
  function weekRange(year, week){
    const simple = new Date(Date.UTC(year, 0, 4))
    const day = (simple.getUTCDay() + 6) % 7
    simple.setUTCDate(simple.getUTCDate() - day + (week - 1) * 7)
    const start = new Date(simple)
    const end = new Date(simple)
    end.setUTCDate(start.getUTCDate() + 6)
    return { start, end }
  }
  function formatWeekRange(year, week){
    const { start, end } = weekRange(year, week)
    const fmt = (d) => `${String(d.getUTCDate()).padStart(2,'0')}.${String(d.getUTCMonth()+1).padStart(2,'0')}.`
    return `${fmt(start)} – ${fmt(end)}${end.getUTCFullYear()}`
  }
  function ensureDispo(){ if(!Array.isArray(state.dispo)) state.dispo = [] }

  // Fällig-Badge
  function dueBadge(dateYMD){
    if(!dateYMD) return null;
    const d = new Date(dateYMD + 'T00:00:00');
    const t = new Date(); t.setHours(0,0,0,0);
    const diff = Math.round((d - t) / 86400000);
    // Hilfsfunktion: y-m-d → dd.mm.yyyy
    function formatGerman(ymd){
      const parts = (ymd||'').split('-');
      if(parts.length === 3){ return `${parts[2]}.${parts[1]}.${parts[0]}`; }
      return ymd;
    }
    if(diff < 0) return { cls:'b-red', label:'Überfällig' };
    if(diff === 0) return { cls:'b-amber', label:'Heute' };
    if(diff <= 3) return { cls:'b-yellow', label:`In ${diff} Tag${diff===1?'':'en'}` };
    return { cls:'b-green', label:`Am ${formatGerman(dateYMD)}` };
  }

  // ===== Eingabehilfe: Blur bei Enter =====
  // Einige Editierfelder (contenteditable und Inputs) sollen beim Drücken von Enter die Eingabe abschließen,
  // ohne eine neue Zeile zu erzeugen. Diese Hilfsfunktionen fangen die Enter‑Taste ab,
  // verhindern den Standard und entfernen den Fokus vom aktuellen Element.
  function blurOnEnter(e){
    if(e && e.key === 'Enter'){
      e.preventDefault();
      if(e.target && typeof e.target.blur === 'function') e.target.blur();
      // Selektion entfernen, damit Cursor ausgeblendet wird
      if(window.getSelection){
        const sel = window.getSelection();
        if(sel) sel.removeAllRanges();
      }
    }
  }
  function blurOnEnterInput(e){
    if(e && e.key === 'Enter'){
      e.preventDefault();
      if(e.target && typeof e.target.blur === 'function') e.target.blur();
    }
  }

  function applyFilters(list){
    const f = state.filters, min = clampPct(f.pctMin), max = clampPct(f.pctMax)
    let res = [...list]
    if(state.currentTab && state.currentTab !== 'Alle'){ res = res.filter(p => (p.tab || 'Alle') === state.currentTab) }
    res = res.filter(p => {
      const st = progressOf(p); const inRange = st.pct >= min && st.pct <= max
      if(!inRange) return false
      if(f.status === 'all') return true
      return st.status === f.status
    })
    if(f.q && f.q.trim()){
      const needle = f.q.trim().toLowerCase()
      res = res.filter(p => (p.number||'').toLowerCase().includes(needle) || (p.name||'').toLowerCase().includes(needle))
    }
    const activeTab = state.currentTab || 'Alle'
    const cmpMap = {
      date_desc: (a,b) => (b.date||'').localeCompare(a.date||''),
      date_asc:  (a,b) => (a.date||'').localeCompare(b.date||''),
      name_asc:  (a,b) => (a.name||'').localeCompare(b.name||''),
      name_desc: (a,b) => (b.name||'').localeCompare(a.name||''),
      nr_asc:    (a,b) => (a.number||'').localeCompare(b.number||'', undefined, {numeric:true}),
      nr_desc:   (a,b) => (b.number||'').localeCompare(a.number||'', undefined, {numeric:true}),
      prog_desc: (a,b) => progressOf(b).pct - progressOf(a).pct,
      prog_asc:  (a,b) => progressOf(a).pct - progressOf(b).pct,
      manual:    (a,b) => {
        const order = getManualOrderArray(activeTab)
        const ia = order.indexOf(a.id)
        const ib = order.indexOf(b.id)
        return (ia < 0 ? Number.MAX_SAFE_INTEGER : ia) - (ib < 0 ? Number.MAX_SAFE_INTEGER : ib)
      }
    }
    if(f.sort !== 'manual'){
      res.sort(cmpMap[f.sort] || cmpMap.date_desc)
    }
    else{
      ensureManualOrder(res.map(p => p.id), activeTab)
      res.sort(cmpMap.manual)
    }
    return res
  }

  function ensureTabs(){
    if(!Array.isArray(state.tabs)) state.tabs = []
    if(!Array.isArray(state.tabGroups)) state.tabGroups = []
    if(!Array.isArray(state.tabOrder)) state.tabOrder = []
    if(!state.tabMeta || typeof state.tabMeta !== 'object') state.tabMeta = {}

    const fromProjects = new Set((state.projects || []).map(p => (p.tab || '').trim()).filter(name => name && name !== 'Alle'))
    const cleaned = state.tabs
      .filter(name => typeof name === 'string')
      .map(name => name.trim())
      .filter(name => name && name !== 'Alle')
    const unique = Array.from(new Set([...cleaned, ...fromProjects]))

    unique.forEach(name => {
      if(!state.tabMeta[name]) state.tabMeta[name] = {}
      if(typeof state.tabMeta[name].groupId !== 'string') state.tabMeta[name].groupId = state.tabMeta[name].groupId || ''
      if(typeof state.tabMeta[name].color !== 'string') state.tabMeta[name].color = state.tabMeta[name].color || ''
    })
    Object.keys(state.tabMeta).forEach(name => {
      if(name === 'Alle') return
      if(!unique.includes(name)) delete state.tabMeta[name]
    })

    const groupIds = new Set()
    state.tabGroups = state.tabGroups
      .filter(g => g && typeof g.name === 'string')
      .map(g => {
        const id = g.id || ('grp_' + uid())
        groupIds.add(id)
        return {
          id,
          name: (g.name || '').trim() || 'Gruppe',
          color: typeof g.color === 'string' ? g.color : '',
          tabs: Array.isArray(g.tabs) ? g.tabs.filter(t => unique.includes(t)) : []
        }
      })
    state.tabGroups.forEach(group => {
      const seen = new Set()
      group.tabs = group.tabs.filter(name => {
        if(!unique.includes(name) || seen.has(name)) return false
        seen.add(name)
        return true
      })
      group.tabs.forEach(name => {
        state.tabMeta[name] = state.tabMeta[name] || {}
        state.tabMeta[name].groupId = group.id
      })
    })

    unique.forEach(name => {
      const meta = state.tabMeta[name]
      if(meta && meta.groupId && !groupIds.has(meta.groupId)) meta.groupId = ''
    })

    const orderSet = new Set()
    state.tabOrder = state.tabOrder.filter(entry => {
      if(typeof entry !== 'string') return false
      if(entry.startsWith('tab:')){
        const name = entry.slice(4)
        if(name === 'Alle' || !unique.includes(name)) return false
        const meta = state.tabMeta[name]
        if(meta && meta.groupId) return false
        if(orderSet.has(entry)) return false
        orderSet.add(entry)
        return true
      }
      if(entry.startsWith('group:')){
        const id = entry.slice(6)
        if(!groupIds.has(id) || orderSet.has(entry)) return false
        orderSet.add(entry)
        return true
      }
      return false
    })

    const topTabs = unique.filter(name => !(state.tabMeta[name] && state.tabMeta[name].groupId))
    topTabs.forEach(name => {
      const key = 'tab:' + name
      if(!orderSet.has(key)){
        state.tabOrder.push(key)
        orderSet.add(key)
      }
    })
    state.tabGroups.forEach(group => {
      const key = 'group:' + group.id
      if(!orderSet.has(key)){
        state.tabOrder.push(key)
        orderSet.add(key)
      }
    })

    const ordered = []
    const groupsById = new Map(state.tabGroups.map(g => [g.id, g]))
    state.tabOrder.forEach(entry => {
      if(entry.startsWith('tab:')){
        const name = entry.slice(4)
        if(unique.includes(name) && !ordered.includes(name)) ordered.push(name)
      }else if(entry.startsWith('group:')){
        const group = groupsById.get(entry.slice(6))
        if(group){
          group.tabs.forEach(name => {
            if(unique.includes(name) && !ordered.includes(name)) ordered.push(name)
          })
        }
      }
    })
    unique.forEach(name => { if(!ordered.includes(name)) ordered.push(name) })
    state.tabs = ['Alle', ...ordered]

    if(!state.currentTab || !state.tabs.includes(state.currentTab)) state.currentTab = 'Alle'
    if(!state.timelineTab || !state.tabs.includes(state.timelineTab)) state.timelineTab = 'Alle'
  }
  function pushHistory(){ history.push(snapshot()); if(history.length>400) history.shift(); future.length=0 }
  function undo(){ if(!history.length) return; future.push(snapshot()); state = history.pop(); setDirty(true); render() }
  function redo(){ if(!future.length) return; history.push(snapshot()); state = future.pop(); setDirty(true); render() }

  // ===== Tabs render + Reorder =====
  function renderTabs(){
    ensureTabs()
    closeTabMenu()
    closeAllGroupDropdowns()
    if(!tabsEl) return

    const groupsById = new Map(state.tabGroups.map(g => [g.id, g]))
    const topOrder = state.tabOrder.filter(entry => entry.startsWith('tab:')).map(entry => entry.slice(4))
    const firstTopTab = topOrder.length ? topOrder[0] : null

    const previousScrollLeft = tabsScroll ? tabsScroll.scrollLeft : 0

    tabsEl.innerHTML = ''
    const fragment = document.createDocumentFragment()
    const renderedTabs = new Set()
    const renderedGroups = new Set()

    const appendTab = (name, opts = {}) => {
      if(renderedTabs.has(name)) return
      fragment.appendChild(createTabElement(name, opts))
      renderedTabs.add(name)
    }
    const appendGroup = group => {
      if(!group || renderedGroups.has(group.id)) return
      if(Array.isArray(group.tabs)) group.tabs.forEach(name => renderedTabs.add(name))
      fragment.appendChild(createGroupElement(group))
      renderedGroups.add(group.id)
    }

    appendTab('Alle', { allowMenu:false, draggable:false, firstTopTab })

    state.tabOrder.forEach(entry => {
      if(entry.startsWith('tab:')){
        const name = entry.slice(4)
        if(name === 'Alle') return
        appendTab(name, { firstTopTab })
      }else if(entry.startsWith('group:')){
        const group = groupsById.get(entry.slice(6))
        if(group) appendGroup(group)
      }
    })

    state.tabGroups.forEach(group => appendGroup(group))
    state.tabs.forEach(name => {
      if(name === 'Alle') return
      appendTab(name, { firstTopTab })
    })

    tabsEl.appendChild(fragment)

    const addBtn = document.createElement('button')
    addBtn.type = 'button'
    addBtn.className = 'tab-add'
    addBtn.innerHTML = '<span class="ms">add</span>'
    addBtn.title = 'Tab oder Gruppe hinzufügen'
    addBtn.addEventListener('click', e => {
      e.stopPropagation()
      openTabMenu(addBtn, [
        { label:'Neuer Tab', icon:'add', action: () => createTab() },
        { label:'Neue Gruppe', icon:'folder', action: () => createGroup() }
      ])
    })
    tabsEl.appendChild(addBtn)

    if(tabsScroll){
      const maxScroll = Math.max(0, tabsScroll.scrollWidth - tabsScroll.clientWidth)
      tabsScroll.scrollLeft = Math.min(previousScrollLeft, maxScroll)
      requestAnimationFrame(() => updateTabsOverflow())
    }

    // Bulk Move Ziel
    if(bulkTarget){
      const opts = state.tabs.map(t => {
        const opt = document.createElement('option')
        opt.value = t
        opt.textContent = t
        return opt
      })
      if(typeof bulkTarget.replaceChildren === 'function') bulkTarget.replaceChildren(...opts)
      else {
        bulkTarget.innerHTML = ''
        opts.forEach(opt => bulkTarget.appendChild(opt))
      }
    }
    if(timelineTabSelect){
      const current = state.timelineTab && state.tabs.includes(state.timelineTab) ? state.timelineTab : 'Alle'
      state.timelineTab = current
      const opts = state.tabs.map(tabName => {
        const opt = document.createElement('option')
        opt.value = tabName
        opt.textContent = tabName
        return opt
      })
      if(typeof timelineTabSelect.replaceChildren === 'function') timelineTabSelect.replaceChildren(...opts)
      else {
        timelineTabSelect.innerHTML = ''
        opts.forEach(opt => timelineTabSelect.appendChild(opt))
      }
      timelineTabSelect.value = current
    }

    function createTabMenuButton(name, firstTop){
      const btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'tab-more'
      const icon = document.createElement('span')
      icon.className = 'ms'
      icon.textContent = 'more_vert'
      btn.appendChild(icon)
      btn.addEventListener('click', e => {
        e.stopPropagation()
        const meta = state.tabMeta[name] || {}
        const currentGroup = meta.groupId || ''
        const items = [
          { label:'Umbenennen', icon:'edit', action: () => renameTabPrompt(name) },
          {
            label:'Füllfarbe ändern',
            icon:'palette',
            action: ctx => changeTabColor(name, ctx && ctx.anchor ? ctx.anchor : btn),
            keepOpen:true
          }
        ]
        if(currentGroup){
          items.push({ label:'Aus Gruppe lösen', icon:'tab_unselected', action: () => {
            pushHistory()
            const before = firstTop && firstTop !== name ? firstTop : null
            moveTabBefore(name, before)
            setDirty(true); render()
          } })
        }
        const availableGroups = state.tabGroups.filter(group => group.id !== currentGroup)
        if(availableGroups.length){
          items.push({ type:'divider' })
          items.push({
            label:'Zu Gruppe hinzufügen',
            icon:'folder',
            submenu: availableGroups.map(group => ({
              label:`${group.name}`,
              icon:'folder',
              action: () => { pushHistory(); moveTabToGroup(name, group.id); setDirty(true); render() }
            }))
          })
        }
        items.push({ type:'divider' })
        items.push({ label:'Löschen', icon:'delete', action: () => deleteTabByName(name) })
        openTabMenu(btn, items)
      })
      return btn
    }

    function createTabElement(name, opts = {}){
      const inDropdown = !!opts.inDropdown
      const allowMenu = opts.allowMenu !== false
      const draggable = opts.draggable !== false && name !== 'Alle'
      const groupId = opts.groupId || (state.tabMeta[name] && state.tabMeta[name].groupId) || ''
      const firstTop = opts.firstTopTab || firstTopTab
      const onActivated = typeof opts.onActivated === 'function' ? opts.onActivated : null
      const onDropped = typeof opts.onDrop === 'function' ? opts.onDrop : null

      const el = document.createElement('div')
      el.className = 'tab' + (inDropdown ? ' in-dropdown' : '')
      if(state.currentTab === name) el.classList.add('active')
      el.dataset.name = name
      el.setAttribute('role', 'button')
      el.tabIndex = 0
      if(draggable) el.draggable = true

      const label = document.createElement('span')
      label.className = 'name'
      label.textContent = name
      el.appendChild(label)

      if(allowMenu && name !== 'Alle'){
        el.appendChild(createTabMenuButton(name, firstTop))
      }

      const color = state.tabMeta[name] && state.tabMeta[name].color
      if(color){
        el.style.setProperty('--tab-bg', color)
        el.style.setProperty('--tab-fg', contrastColor(color))
      }else{
        el.style.removeProperty('--tab-bg')
        el.style.removeProperty('--tab-fg')
      }

      const activate = () => {
        if(state.currentTab === name) return
        if(onActivated) onActivated()
        state.currentTab = name
        if(state.view === 'timeline') state.timelineTab = name
        render()
      }

      el.addEventListener('click', ev => {
        if(ev.target.closest('.tab-more')) return
        activate()
      })
      el.addEventListener('keydown', ev => {
        if(ev.key === 'Enter' || ev.key === ' '){
          ev.preventDefault()
          if(ev.target.closest('.tab-more')) return
          activate()
        }
      })

      if(draggable){
        el.addEventListener('dragstart', e => {
          draggingTabName = name
          el.classList.add('dragging')
          e.dataTransfer.setData('text/tab', name)
          e.dataTransfer.effectAllowed = 'move'
        })
        el.addEventListener('dragend', () => {
          draggingTabName = null
          el.classList.remove('dragging')
        })
      }

      el.addEventListener('dragover', e => {
        const projId = getDragProjectId(e)
        const hasTab = draggingTabName || e.dataTransfer.getData('text/tab')
        if(!projId && !hasTab) return
        e.preventDefault()
        el.classList.add('drop-hint')
      })
      el.addEventListener('dragleave', () => el.classList.remove('drop-hint'))
      el.addEventListener('drop', e => {
        e.preventDefault()
        el.classList.remove('drop-hint')
        closeTabMenu()
        const droppedTab = e.dataTransfer.getData('text/tab') || draggingTabName
        const projId = getDragProjectId(e)
        if(droppedTab){
          if(droppedTab !== name){
            if(onDropped) onDropped()
            pushHistory()
            if(inDropdown && groupId){
              moveTabWithinGroup(droppedTab, groupId, name)
            }else if(name === 'Alle'){
              const before = firstTop && firstTop !== droppedTab ? firstTop : null
              moveTabBefore(droppedTab, before)
            }else{
              moveTabBefore(droppedTab, name)
            }
            setDirty(true); render()
          }
        }else if(projId){
          if(onDropped) onDropped()
          pushHistory()
          assignProjectToTab(projId, name)
          setDirty(true); render()
        }
        draggingProjectId = null
      })

      return el
    }

    function createGroupElement(group){
      const container = document.createElement('div')
      container.className = 'tab-group'

      const header = document.createElement('div')
      header.className = 'tab is-group'
      header.dataset.groupId = group.id
      header.setAttribute('role', 'button')
      header.tabIndex = 0
      if(group.tabs && group.tabs.includes(state.currentTab)) header.classList.add('active')

      const nameSpan = document.createElement('span')
      nameSpan.className = 'name'
      nameSpan.textContent = group.name
      header.appendChild(nameSpan)

      const toggle = document.createElement('button')
      toggle.type = 'button'
      toggle.className = 'tab-group-toggle'
      const icon = document.createElement('span')
      icon.className = 'ms'
      icon.textContent = 'more_vert'
      toggle.appendChild(icon)
      toggle.addEventListener('click', e => {
        e.stopPropagation()
        openTabMenu(toggle, [
          { label:'Gruppe umbenennen', icon:'edit', action: () => renameGroupPrompt(group) },
          { label:'Füllfarbe ändern', icon:'palette', action: ctx => changeGroupColor(group, ctx && ctx.anchor ? ctx.anchor : toggle), keepOpen:true },
          { type:'divider' },
          { label:'Gruppe löschen', icon:'delete', action: () => deleteGroup(group) }
        ])
      })
      header.appendChild(toggle)

      if(group.color){
        header.style.setProperty('--tab-bg', group.color)
        header.style.setProperty('--tab-fg', contrastColor(group.color))
      }else{
        header.style.removeProperty('--tab-bg')
        header.style.removeProperty('--tab-fg')
      }

      container.appendChild(header)

      const dropdown = document.createElement('div')
      dropdown.className = 'tab-dropdown'
      dropdown.__home = container
      container.appendChild(dropdown)

      const syncExpanded = () => header.setAttribute('aria-expanded', container.classList.contains('open') ? 'true' : 'false')
      let hideTimer = null
      let floatingActive = false
      let showDropZoneFn = () => {}
      let hideDropZoneFn = () => {}
      const repositionDropdown = () => {
        if(container.classList.contains('open')){
          positionGroupDropdown(header, dropdown)
        }
      }
      const activateFloating = () => {
        if(floatingActive) return
        floatingActive = true
        window.addEventListener('resize', repositionDropdown, true)
        window.addEventListener('scroll', repositionDropdown, true)
      }
      const deactivateFloating = () => {
        if(!floatingActive) return
        floatingActive = false
        window.removeEventListener('resize', repositionDropdown, true)
        window.removeEventListener('scroll', repositionDropdown, true)
      }
      const openDropdown = () => {
        clearTimeout(hideTimer)
        hideTimer = null
        container.classList.add('open')
        syncExpanded()
        positionGroupDropdown(header, dropdown)
        activateFloating()
        openTabGroupDropdowns.add(dropdown)
        hideDropZoneFn()
      }
      const closeDropdownNow = () => {
        clearTimeout(hideTimer)
        hideTimer = null
        container.classList.remove('open')
        syncExpanded()
        deactivateFloating()
        hideDropZoneFn()
        resetGroupDropdown(dropdown, container)
        openTabGroupDropdowns.delete(dropdown)
      }
      dropdown.__close = closeDropdownNow
      const cancelClose = () => { clearTimeout(hideTimer); hideTimer = null }
      const requestClose = () => {
        cancelClose()
        hideTimer = setTimeout(closeDropdownNow, 220)
      }
      const withinSurface = target => {
        if(!target) return false
        return target === container || target === header || container.contains(target) ||
          target === dropdown || dropdown.contains(target)
      }
      container.addEventListener('pointerenter', () => {
        cancelClose()
        openDropdown()
      })
      container.addEventListener('pointerleave', e => {
        if(withinSurface(e.relatedTarget) || draggingTabName) return
        requestClose()
      })
      dropdown.addEventListener('pointerenter', cancelClose)
      dropdown.addEventListener('pointerleave', e => {
        if(withinSurface(e.relatedTarget) || draggingTabName) return
        requestClose()
      })
      header.addEventListener('click', e => {
        if(e.target.closest('.tab-group-toggle')) return
        if(container.classList.contains('open')) closeDropdownNow()
        else openDropdown()
      })
      header.addEventListener('keydown', e => {
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault()
          if(container.classList.contains('open')) closeDropdownNow()
          else openDropdown()
        }
      })
      syncExpanded()

      if(group.tabs && group.tabs.length){
        group.tabs.forEach(tabName => dropdown.appendChild(createTabElement(tabName, { inDropdown:true, groupId:group.id, firstTopTab, onActivated: closeDropdownNow, onDrop: closeDropdownNow })))
      }

      const dropZone = document.createElement('div')
      dropZone.className = 'group-drop-zone'
      const showDropZone = () => {
        dropZone.textContent = 'Hier ablegen'
        dropZone.classList.add('show')
      }
      const hideDropZone = () => {
        dropZone.textContent = ''
        dropZone.classList.remove('show', 'drag-over')
      }
      showDropZoneFn = showDropZone
      hideDropZoneFn = hideDropZone
      dropZone.addEventListener('dragover', e => {
        const tabName = e.dataTransfer.getData('text/tab') || draggingTabName
        if(!tabName) return
        e.preventDefault()
        showDropZone()
        dropZone.classList.add('drag-over')
      })
      dropZone.addEventListener('dragleave', () => hideDropZone())
      dropZone.addEventListener('drop', e => {
        e.preventDefault()
        hideDropZone()
        closeTabMenu()
        closeDropdownNow()
        const tabName = e.dataTransfer.getData('text/tab') || draggingTabName
        if(tabName){
          pushHistory()
          moveTabToGroup(tabName, group.id)
          setDirty(true); render()
        }
        draggingTabName = null
      })
      dropdown.appendChild(dropZone)
      closeDropdownNow()

      header.draggable = true
      header.addEventListener('dragstart', e => {
        draggingGroupId = group.id
        header.classList.add('dragging')
        e.dataTransfer.setData('text/tab-group', group.id)
        e.dataTransfer.effectAllowed = 'move'
      })
      header.addEventListener('dragend', () => {
        draggingGroupId = null
        header.classList.remove('dragging')
      })
      header.addEventListener('dragover', e => {
        const tabName = e.dataTransfer.getData('text/tab') || draggingTabName
        const groupMove = e.dataTransfer.getData('text/tab-group') || draggingGroupId
        if(tabName || (groupMove && groupMove !== group.id)){
          e.preventDefault()
          header.classList.add('drop-hint')
        }
      })
      header.addEventListener('dragleave', () => header.classList.remove('drop-hint'))
      header.addEventListener('drop', e => {
        e.preventDefault()
        header.classList.remove('drop-hint')
        closeTabMenu()
        closeDropdownNow()
        const tabName = e.dataTransfer.getData('text/tab') || draggingTabName
        const groupMove = e.dataTransfer.getData('text/tab-group') || draggingGroupId
        const projId = getDragProjectId(e)
        if(tabName){
          pushHistory()
          moveTabToGroup(tabName, group.id)
          setDirty(true); render()
        }else if(groupMove && groupMove !== group.id){
          pushHistory()
          moveGroupBefore(groupMove, group.id)
          setDirty(true); render()
        }else if(projId){
          showToast('Bitte Tab innerhalb der Gruppe wählen.')
        }
        draggingProjectId = null
        draggingGroupId = null
        draggingTabName = null
      })

      return container
    }
  }

  if(tabsEl){
    tabsEl.addEventListener('dragover', e => {
      const hasTab = draggingTabName || e.dataTransfer.getData('text/tab')
      const hasGroup = draggingGroupId || e.dataTransfer.getData('text/tab-group')
      if((hasTab || hasGroup) && e.target === tabsEl){
        e.preventDefault()
      }
    })
    tabsEl.addEventListener('drop', e => {
      if(e.target !== tabsEl) return
      e.preventDefault()
      closeTabMenu()
      const droppedTab = e.dataTransfer.getData('text/tab') || draggingTabName
      const droppedGroup = e.dataTransfer.getData('text/tab-group') || draggingGroupId
      if(droppedTab){
        pushHistory()
        moveTabBefore(droppedTab)
        setDirty(true); render()
      }else if(droppedGroup){
        pushHistory()
        moveGroupBefore(droppedGroup)
        setDirty(true); render()
      }
      draggingTabName = null
      draggingGroupId = null
    })
  }

  // ===== Rendering =====
  function render(){
    applyTheme(); setTitle(); renderTabs();
    const isKanban = state.view === 'kanban';
    const isTimeline = state.view === 'timeline';
    const isDispo = state.view === 'dispo';
    // Toggle view buttons
    document.getElementById('viewTable').classList.toggle('on', !isKanban && !isTimeline && !isDispo);
    document.getElementById('viewKanban').classList.toggle('on', isKanban);
    const viewTimelineBtn = document.getElementById('viewTimeline');
    if(viewTimelineBtn) viewTimelineBtn.classList.toggle('on', isTimeline);
    const viewDispoBtn = document.getElementById('viewDispo');
    if(viewDispoBtn) viewDispoBtn.classList.toggle('on', isDispo);
    // Show/hide main sections
    tableView.style.display = (!isKanban && !isTimeline && !isDispo) ? 'block' : 'none';
    kanbanView.classList.toggle('show', isKanban);
    if(timelineShell) timelineShell.classList.toggle('show', isTimeline);
    if(timelineViewEl) timelineViewEl.classList.toggle('show', isTimeline);
    if(dispoView) dispoView.classList.toggle('show', isDispo);
    if(toolbar) toolbar.style.display = (isTimeline || isDispo) ? 'none' : 'grid';
    if(filterbar) filterbar.style.display = (!isKanban && !isTimeline && !isDispo) ? 'grid' : 'none';
    if(timelineZoomInput || timelineZoomLabelsEl){
      updateTimelineZoomIndicator();
    }
    // Render per view
    if(isKanban){
      renderKanban();
      return;
    }
    if(isTimeline){
      renderTimeline();
      updateBulkUi();
      return;
    }
    if(isDispo){
      renderDispo();
      updateBulkUi();
      return;
    }
    // Table view
    tbody.innerHTML = '';
    const list = applyFilters(state.projects || []);
    if(list.length === 0){ tbody.appendChild(emptyRow); }
    else { list.forEach(p => tbody.appendChild(rowFor(p))); }
    updateBulkUi();
  }

  // ===== Zeilenaufbau =====
function rowFor(p){
  const tr = document.createElement('tr');
  // Row identifier
  tr.dataset.id = p.id;

// Auswahl/Farbe
  if (selected.has(p.id)) tr.classList.add('row-selected');
  if (p.color){ tr.classList.add('colored'); tr.style.setProperty('--pcolor', p.color); }

  // NEU: collapsed-Klasse initial setzen
  tr.classList.toggle('collapsed', !!p.collapsed);

    // Drag events: verwenden Sie die linke Steuerzelle als Drag‑Handle für Projektverschiebungen
    // Beim Dragstart wird die Projekt‑ID übermittelt. Das Ziehen auf einen Tab verschiebt das Projekt dorthin.
    // Beim Ziehen über eine Tabellenzeile wird die Reihenfolge geändert (manuelle Sortierung).

     // Linke Zelle: Pfeil, Auswahl, Farbe (mit Popover)
  const tdCtl = document.createElement('td'); tdCtl.className='leftCell';
  const caret = document.createElement('button'); caret.className='caret';
  caret.title = p.collapsed ? 'Aufklappen' : 'Einklappen';
  
// NEU: Icon initial nach Zustand
  caret.innerHTML = `<span class="ms">${p.collapsed ? 'chevron_right' : 'expand_more'}</span>`;
  caret.addEventListener('click', () => {
    pushHistory();
    p.collapsed = !p.collapsed;
    tr.classList.toggle('collapsed', p.collapsed);
    caret.innerHTML = `<span class="ms">${p.collapsed ? 'chevron_right' : 'expand_more'}</span>`;
    setDirty(true); render();
  });
  const select = document.createElement('input'); select.type='checkbox'; select.className='selectCb';
  select.checked = selected.has(p.id);
  select.addEventListener('change', () => { if(select.checked) selected.add(p.id); else selected.delete(p.id); render(); });
  const colorBtn = document.createElement('button'); colorBtn.className='colorBtn'; colorBtn.title='Projektfarbe';
  colorBtn.style.setProperty('--pcolor', p.color || '#7c3aed');
  colorBtn.addEventListener('click', (e)=> openColorPopover(e.currentTarget, p));
  tdCtl.appendChild(caret); tdCtl.appendChild(select); tdCtl.appendChild(colorBtn);

    // === Drag‑Handle auf der linken Zelle ===
    tdCtl.draggable = true;
    tdCtl.addEventListener('dragstart', e => {
      // Kennzeichne das aktuell gezogene Projekt
      e.dataTransfer.setData('text/proj', p.id);
      e.dataTransfer.setData('text/plain', p.id);
      draggingProjectId = p.id;
      // Erlaube Verschieben (statt Kopieren) im Browser
      e.dataTransfer.effectAllowed = 'move';
      if(state.filters.sort !== 'manual'){
        state.filters.sort = 'manual';
        showToast('Sortierung auf „Manuell“ umgeschaltet.');
        const sortSelect = document.getElementById('sort');
        if(sortSelect) sortSelect.value = 'manual';
      }
      // Leicht transparent bei manuellem Sortieren
      if(state.filters.sort === 'manual'){ tr.style.opacity = .5; }
    });
    tdCtl.addEventListener('dragend', () => {
      tr.style.opacity = '';
      draggingProjectId = null;
    });
    // Ziehen über Tabellenzeilen zum Reorden
    tr.addEventListener('dragover', e => {
      e.preventDefault();
      if(state.filters.sort !== 'manual'){
        e.dataTransfer.dropEffect = 'none';
        tr.style.outline = '';
        return;
      }
      // Zeige dem Browser, dass hier ein Verschieben erlaubt ist
      e.dataTransfer.dropEffect = 'move';
      tr.style.outline = '2px dashed #64748b';
    });
    tr.addEventListener('dragleave', () => {
      tr.style.outline = '';
    });
    tr.addEventListener('drop', e => {
      e.preventDefault();
      e.stopPropagation();
      tr.style.outline = '';
      const dragId = getDragProjectId(e);
      if(!dragId || dragId === p.id) return;
      if(state.filters.sort !== 'manual'){
        showToast('Sortierung auf „Manuell“ stellen, um die Reihenfolge zu ändern.');
        return;
      }
      pushHistory();
      const activeTab = state.currentTab || 'Alle';
      const order = ensureManualOrder(projectIdsForTab(activeTab), activeTab);
      const a = order.indexOf(dragId);
      const b = order.indexOf(p.id);
      if(a >= 0 && b >= 0){
        order.splice(a, 1);
        let targetIndex = b;
        // Wenn nach unten gezogen wird, muss das Ziel nach dem Entfernen angepasst werden
        if(a < b) targetIndex = b - 1;
        // Entscheide anhand der Cursorposition, ob vor oder nach der Zeile eingefügt wird
        const bounds = tr.getBoundingClientRect();
        const insertAfter = (e.clientY - bounds.top) > bounds.height / 2;
        order.splice(insertAfter ? targetIndex + 1 : targetIndex, 0, dragId);
        if(activeTab === 'Alle'){
          state.order = order;
          state.orderByTab['Alle'] = order.slice();
        }else{
          state.orderByTab[activeTab] = order;
        }
        setDirty(true);
        render();
      }
      draggingProjectId = null;
    });

    // Nummer
    const tdNr = document.createElement('td')
    const nr = document.createElement('div'); nr.className='editable'; nr.contentEditable='true'; nr.textContent = p.number || ''
    nr.addEventListener('keydown', blurOnEnter)
    nr.addEventListener('input', () => { pushHistory(); p.number = nr.textContent.trim(); setDirty(true) })
    tdNr.appendChild(nr)

    // Name
    const tdName = document.createElement('td')
    const name = document.createElement('div'); name.className='editable'; name.contentEditable='true'; name.textContent = p.name || ''
    name.addEventListener('keydown', blurOnEnter)
    name.addEventListener('input', () => { pushHistory(); p.name = name.textContent.trim(); setDirty(true) })
    tdName.appendChild(name)

    // Datum + Deadline (stacked, keine Überlappung)
    const tdDate = document.createElement('td')
    const stack = document.createElement('div'); stack.style.display='flex'; stack.style.flexDirection='column'; stack.style.gap='8px'
    const date = document.createElement('input');
    date.type = 'date';
    date.className = 'dateInput';
    date.value = p.date || '';
    date.title = 'Projekt‑Datum';
    // Deutsches Datumsformat in Browser (sofern unterstützt)
    date.lang = 'de';
    // Platzhalter als Hinweis auf deutsches Format
    date.placeholder = 'tt.mm.jjjj';
    date.addEventListener('keydown', blurOnEnterInput)
    date.addEventListener('change', () => { pushHistory(); p.date = date.value; setDirty(true) })
    const dRow = document.createElement('div'); dRow.style.display='flex'; dRow.style.gap='8px'; dRow.style.alignItems='center'
    const deadline = document.createElement('input');
    deadline.type = 'text';
    deadline.className = 'dateInput';
    deadline.placeholder = 'tt.mm.jjjj';
    deadline.style.display = p.showDeadline ? 'block' : 'none';
    deadline.addEventListener('keydown', blurOnEnterInput);
    const resetDeadlineInput = () => {
      const parsed = parseIsoDate(p.deadline);
      if(parsed){
        deadline.value = formatGermanDate(parsed);
      }else{
        deadline.value = p.deadline ? p.deadline : '';
      }
    };
    resetDeadlineInput();
    const commitProjectDeadline = (iso) => {
      if(p.deadline === iso) return;
      pushHistory();
      p.deadline = iso;
      setDirty(true);
      render();
    };
    const handleProjectDeadlineInput = () => {
      const raw = deadline.value.trim();
      if(!raw){
        if(p.deadline){
          commitProjectDeadline('');
        }else{
          deadline.value = '';
        }
        return;
      }
      const parsed = parseGermanDate(raw);
      if(!parsed){
        resetDeadlineInput();
        return;
      }
      commitProjectDeadline(formatIsoDate(parsed));
    };
    deadline.addEventListener('blur', handleProjectDeadlineInput);
    deadline.addEventListener('change', handleProjectDeadlineInput);
    const deadlineCal = document.createElement('button');
    deadlineCal.className = 'iconbtn miniCal';
    deadlineCal.title = 'Datum auswählen';
    deadlineCal.innerHTML = '<span class="ms">event</span>';
    deadlineCal.style.display = p.showDeadline ? 'flex' : 'none';
    deadlineCal.addEventListener('click', (ev) => {
      ev.preventDefault();
      const current = parseGermanDate(deadline.value.trim()) || parseIsoDate(p.deadline);
      openDatePicker(deadlineCal, {
        value: current,
        onSelect: (dateObj) => {
          if(!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return;
          commitProjectDeadline(formatIsoDate(dateObj));
        }
      });
    });
    const toggle = document.createElement('button');
    toggle.className = 'btn';
    toggle.innerHTML = `<span class="ms">${p.showDeadline ? 'event_busy' : 'event'}</span>`;
    toggle.title = p.showDeadline ? 'Deadline ausblenden' : 'Deadline anzeigen';
    toggle.addEventListener('click', () => {
      pushHistory();
      p.showDeadline = !p.showDeadline;
      setDirty(true);
      render();
    });
    dRow.appendChild(deadline);
    dRow.appendChild(deadlineCal);
    dRow.appendChild(toggle);
    // Fälligkeitsfeld für das Projekt: als Textfeld mit deutschem Format
    stack.appendChild(date);
    stack.appendChild(dRow);
    // Im Tabellenmodus wird kein Fälligkeits‑Badge unter dem Datum angezeigt. Die Kanban‑Ansicht zeigt Deadlines über dueBadge.
    // Wenn das Projekt zugeklappt ist, wird nur ein einzelnes Datum dargestellt. Deadline hat Vorrang vor dem Projektdatum.
    if(p.collapsed){
      let showVal = '';
      if(p.deadline && p.deadline.length){ showVal = p.deadline; }
      else if(p.date && p.date.length){ showVal = p.date; }
      let display = '';
      if(showVal){
        const parts = showVal.split('-');
        display = parts.length===3 ? `${parts[2]}.${parts[1]}.${parts[0]}` : showVal;
      }
      stack.innerHTML = '';
      const lab = document.createElement('span');
      lab.textContent = display || '—';
      lab.style.fontSize = '12px';
      stack.appendChild(lab);
    }
    tdDate.appendChild(stack);

    // To-Dos
    const tdTodos = document.createElement('td')
    const todoCol = document.createElement('div'); todoCol.className='todoCol'
    const stats = progressOf(p)
    const head = document.createElement('div'); head.className='todoHead'
    const headLeft = document.createElement('span')
    headLeft.textContent = stats.total === 0
      ? (stats.emptyComplete ? 'Projekt erledigt' : 'Keine To-Dos erfasst')
      : `${stats.done} von ${stats.total} erledigt`
    const headRight = document.createElement('span')
    headRight.style.marginLeft = 'auto'
    headRight.textContent = `${stats.pct}%`
    head.appendChild(headLeft)
    head.appendChild(headRight)
    const bar = document.createElement('div'); bar.className='progress'
    const fill = document.createElement('i'); fill.style.background=`linear-gradient(90deg, var(--progress), #34d399)`; fill.style.width=`${stats.pct}%`; bar.appendChild(fill)

    const list = document.createElement('div'); list.className='todoList'
    // Reorder Todos: dropzone
    list.addEventListener('dragover', e => e.preventDefault())
    list.addEventListener('drop', e => {
      e.preventDefault()
      const from = +e.dataTransfer.getData('text/todoIndex')
      const pid  = e.dataTransfer.getData('text/todoProj')
      if(pid !== p.id || isNaN(from)) return
      const to = p.todos.length
      if(from === to) return
      pushHistory()
      const [it] = p.todos.splice(from,1); p.todos.splice(to,0,it)
      setDirty(true); render()
    })

    p.todos.forEach((t, idx) => list.appendChild(todoItem(p, t, idx)))

    // Für zusammengeklappte Projekte zeigen wir nur die Statistik und den Fortschrittsbalken an.
    todoCol.appendChild(head);
    todoCol.appendChild(bar);
    if(stats.total === 0 && !p.collapsed){
      const noTodoToggle = document.createElement('label')
      noTodoToggle.className = 'todoEmptyToggle'
      const check = document.createElement('input')
      check.type = 'checkbox'
      check.checked = stats.emptyComplete
      check.addEventListener('change', () => {
        pushHistory()
        p.emptyDone = check.checked
        setDirty(true)
        render()
      })
      const caption = document.createElement('span')
      caption.textContent = 'Projekt als erledigt markieren'
      noTodoToggle.appendChild(check)
      noTodoToggle.appendChild(caption)
      todoCol.appendChild(noTodoToggle)
    }
    if(!p.collapsed){
      // Detaillierte Liste und Eingabe nur im ausgeklappten Zustand hinzufügen
      todoCol.appendChild(list);
      const add = document.createElement('div');
      add.className = 'todoAdd';
      add.style.display='flex';
      add.style.gap='8px';
      // Eingabefeld und Button für neue Aufgaben anlegen. Wir müssen den Button
      // vor dem Keydown-Handler erstellen, damit der Handler auf das richtige
      // Element zugreifen kann (siehe Temporal Dead Zone von const).
      const inTask = document.createElement('input');
      inTask.type = 'text';
      inTask.placeholder = 'To-Do hinzufügen';
      // Button zum Hinzufügen eines neuen To‑Dos
      const addBtn = document.createElement('button');
      addBtn.className = 'btnPrimary';
      addBtn.textContent = '+';
      // Klick-Handler: fügt das To‑Do hinzu und leert das Eingabefeld
      addBtn.addEventListener('click', () => {
        const txt = inTask.value.trim();
        if(!txt) return;
        pushHistory();
        p.todos.push({ text: txt, done: false, due: '' });
        setDirty(true);
        render();
        inTask.value = '';
      });
      // Wenn Enter im Eingabefeld gedrückt wird, simulieren wir einen Klick auf
      // den Button. Damit wird nicht der globale Button (#addBtn im Add‑Formular)
      // verwendet, sondern der gerade erstellte Button.
      inTask.addEventListener('keydown', e => {
        if(e.key === 'Enter'){
          e.preventDefault();
          addBtn.click();
        }
      });
      add.appendChild(inTask);
      add.appendChild(addBtn);
      todoCol.appendChild(add);
    } else {
      // Bei zusammengeklappten Projekten sollen die To‑Do Liste und das Eingabefeld nicht angezeigt werden
    }
    tdTodos.appendChild(todoCol)

    // Notizen
    const tdNote = document.createElement('td')
    const note = document.createElement('div'); note.className='note'; note.contentEditable='true'; note.innerHTML = p.notes || ''
    note.addEventListener('keydown', e => { if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); note.blur(); window.getSelection().removeAllRanges() } })
    note.addEventListener('input', () => { pushHistory(); p.notes = note.innerHTML; setDirty(true) })
    tdNote.appendChild(note)

    // Pfad (Eingabe + Vorschau + Dialog)
const tdFolder = document.createElement('td');
const fold = document.createElement('div'); fold.className='folderWrap';

const fin = document.createElement('input');
fin.type='text'; fin.className='folderInput';
fin.placeholder='Pfad oder URL';
fin.value = p.folder || '';
fin.addEventListener('keydown', blurOnEnterInput);
fin.addEventListener('input', () => {
  pushHistory(); p.folder = fin.value; setDirty(true); updatePathPreview();
});

fold.appendChild(fin);
tdFolder.appendChild(fold);

// Vorschau (nur sichtbar, wenn NICHT zugeklappt)
const preview = document.createElement('div');
preview.className = 'pathPreview';
function shorten(s){ s=String(s); return s.length<=44 ? s : (s.slice(0,18)+'…'+s.slice(-22)); }
function updatePathPreview(){
  preview.dataset.full = p.folder || '';
  preview.textContent = p.folder ? shorten(p.folder) : '';
  preview.style.display = (p.folder && !p.collapsed) ? 'block' : 'none';
}
preview.addEventListener('click', () => {
  const dlg = document.getElementById('pathDlg');
  document.getElementById('pathFull').textContent = p.folder || '(kein Pfad)';
  dlg.showModal();
});
updatePathPreview();
tdFolder.appendChild(preview);

  // To-Do Item (draggable)
  function todoItem(project, t, idx){
    const wrap = document.createElement('div'); wrap.className='todoItem' + (t.done ? ' done' : '')
    wrap.draggable = true
    wrap.addEventListener('dragstart', e => {
      wrap.classList.add('dragging')
      e.dataTransfer.setData('text/todoProj', project.id)
      e.dataTransfer.setData('text/todoIndex', String(idx))
    })
    wrap.addEventListener('dragend', ()=> wrap.classList.remove('dragging'))

    const cb = document.createElement('input'); cb.type='checkbox'; cb.checked=!!t.done
    cb.addEventListener('change', () => { pushHistory(); t.done = cb.checked; setDirty(true); render() })

    const txt = document.createElement('div'); txt.className='todoText editable'; txt.contentEditable='true'; txt.textContent = t.text || ''
    txt.addEventListener('keydown', blurOnEnter)
    txt.addEventListener('input', () => { pushHistory(); t.text = txt.textContent.trim(); setDirty(true) })

    // Erstelle das Fälligkeitsfeld als reines Texteingabefeld, damit der Benutzer deutsche Datumsformate frei eingeben kann.
    // Viele Browser unterstützen lediglich US‑Format (YYYY‑MM‑DD) in <input type="date">, wodurch es beim Tippen zu Problemen kam.
    const due = document.createElement('input');
    due.type = 'text';
    due.className = 'dateInput';
    const initialDueDate = parseIsoDate(t.due);
    due.value = initialDueDate ? formatGermanDate(initialDueDate) : '';
    due.title = 'Deadline';
    // Deutsches Datumsformat (tt.mm.jjjj)
    due.placeholder = 'tt.mm.jjjj';
    // Beim Drücken der Eingabetaste Eingabe abschließen
    due.addEventListener('keydown', blurOnEnterInput);
    const commitDue = (dateObj) => {
      const nextIso = dateObj ? formatIsoDate(dateObj) : '';
      if(t.due === nextIso) return;
      pushHistory();
      t.due = nextIso;
      setDirty(true);
      due.value = dateObj ? formatGermanDate(dateObj) : '';
    };
    const updateDueFromInput = () => {
      const raw = due.value.trim();
      const parsed = parseGermanDate(raw);
      if(!parsed && raw){
        const prevDate = parseIsoDate(t.due);
        due.value = prevDate ? formatGermanDate(prevDate) : '';
        return;
      }
      commitDue(parsed);
    };
    due.addEventListener('blur', updateDueFromInput);
    due.addEventListener('change', updateDueFromInput);
    // Button, um den Kalender direkt unter dem Icon zu öffnen
    const calBtn = document.createElement('button');
    calBtn.className = 'iconbtn miniCal';
    calBtn.title = 'Datum auswählen';
    calBtn.innerHTML = '<span class="ms">event</span>';
    calBtn.addEventListener('click', (ev) => {
      ev.preventDefault();
      const current = parseGermanDate(due.value.trim()) || parseIsoDate(t.due);
      openDatePicker(calBtn, {
        value: current,
        onSelect: (dateObj) => {
          commitDue(dateObj);
        }
      });
    });

    const del = document.createElement('button'); del.className='todoDel'; del.innerHTML='✕'; del.title='Aufgabe entfernen'
    del.addEventListener('click', () => { pushHistory(); project.todos.splice(idx,1); setDirty(true); render() })

    const b = dueBadge(t.due)
    if(b?.cls === 'b-red') wrap.style.boxShadow = 'inset 0 0 0 2px rgba(239,68,68,.7)'
    else if(b?.cls === 'b-amber') wrap.style.boxShadow = 'inset 0 0 0 2px rgba(245,158,11,.6)'
    else if(b?.cls === 'b-yellow') wrap.style.boxShadow = 'inset 0 0 0 2px rgba(234,179,8,.5)'
    else if(b?.cls === 'b-green') wrap.style.boxShadow = 'inset 0 0 0 2px rgba(16,185,129,.45)'

    // Reihenfolge: Checkbox, Text, Datum, Kalenderbutton, Entfernen
    wrap.appendChild(cb);
    wrap.appendChild(txt);
    wrap.appendChild(due);
    wrap.appendChild(calBtn);
    wrap.appendChild(del);
    return wrap;
  }

    // Alle aufgebauten Zellen zum Tabellen‑Row hinzufügen und Zeile zurückgeben
    tr.appendChild(tdCtl);
    tr.appendChild(tdNr);
    tr.appendChild(tdName);
    tr.appendChild(tdDate);
    tr.appendChild(tdTodos);
    tr.appendChild(tdNote);
    tr.appendChild(tdFolder);
    return tr;
  }

  // ===== Auswahlabhängige UI =====
  function updateBulkUi(){
    selCount.textContent = `${selected.size} ausgewählt`;
    const allow = state.view === 'table';
    bulkbar.classList.toggle('show', allow && selected.size > 0);
  }

  // ===== CSV / Kalender-Export =====
  function parseCSV(text){
    const rows=[]; let i=0, field='', row=[], inQ=false
    while(i<text.length){
      const ch=text[i]
      if(inQ){ if(ch === '"'){ if(text[i+1] === '"'){ field+='"'; i+=2 } else { inQ=false; i++ } } else { field+=ch; i++ } }
      else{
        if(ch === '"'){ inQ=true; i++ }
        else if(ch === ',' || ch === ';'){ row.push(field.trim()); field=''; i++ }
        else if(ch === '\n' || ch === '\r'){ if(field!=='' || row.length){ row.push(field.trim()); rows.push(row); row=[]; field='' } if(ch==='\r' && text[i+1]==='\n') i++; i++ }
        else { field+=ch; i++ }
      }
    }
    if(field!=='' || row.length){ row.push(field.trim()); rows.push(row) }
    return rows
  }
  function exportCSV(list, name){
    const rows = [['ID','Projektnummer','Projektname','Datum','Deadline','Deadline sichtbar','ToDos','NotizenHTML','Tab','Pfad','Farbe','Eingeklappt','Sortierung']]
    const manualOrder = (state.order && state.order.length) ? state.order.slice() : (state.projects || []).map(p => p.id)
    list.forEach(p => {
      const todos = p.todos.map(t => `${t.done?'[x]':'[ ]'} ${t.text}${t.due?' @'+t.due:''}`).join(' | ')
      const sortIndex = manualOrder.indexOf(p.id)
      rows.push([
        p.id,
        p.number||'',
        p.name||'',
        p.date||'',
        p.deadline||'',
        p.showDeadline ? 'true' : 'false',
        todos,
        p.notes || '',
        p.tab || 'Alle',
        p.folder || '',
        p.color || '',
        p.collapsed ? 'true' : 'false',
        sortIndex >= 0 ? String(sortIndex) : ''
      ])
    })
    const csv = rows.map(r => r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n')
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8'})
    const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href)
  }
  function ymdToICS(ymd){ return ymd.replaceAll('-','') }
  function foldLine(s){ const out=[]; for(let i=0;i<s.length;i+=70) out.push(s.slice(i,i+70)); return out.join('\r\n ') }
  function vevent({uid, summary, description, ymdDate}){
    const dtstamp = new Date().toISOString().replace(/[-:]/g,'').split('.')[0] + 'Z'
    const lines = ['BEGIN:VEVENT',`UID:${uid}`,`DTSTAMP:${dtstamp}`,`DTSTART;VALUE=DATE:${ymdToICS(ymdDate)}`, foldLine(`SUMMARY:${summary}`)]
    if(description) lines.push(foldLine(`DESCRIPTION:${description}`))
    lines.push('END:VEVENT'); return lines.join('\r\n')
  }
  function exportICS(list, name){
    const parts=['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//ProjektToDos//DE','CALSCALE:GREGORIAN','METHOD:PUBLISH']
    list.forEach(p => {
      const base = `Projekt ${p.number||''} – ${p.name||''}`.trim()
      if(p.deadline){ parts.push(vevent({ uid:`${p.id}-deadline@projtodos`, summary:`${base} (Deadline)`, description:`Tab: ${p.tab||'Alle'}`, ymdDate:p.deadline })) }
      p.todos.filter(t => t.due).forEach((t,i) => {
        parts.push(vevent({ uid:`${p.id}-todo-${i}@projtodos`, summary:`${t.text} — ${base}`, description:`To-Do ${t.done?'(erledigt)':'(offen)'} · Tab: ${p.tab||'Alle'}`, ymdDate:t.due }))
      })
    })
    parts.push('END:VCALENDAR')
    const blob = new Blob([parts.join('\r\n')], {type:'text/calendar;charset=utf-8'})
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href)
  }

  // ===== Kanban =====
  function applyKanbanStatus(project, column){
    if(column === 'done'){
      project.todos.forEach(t => t.done = true)
    }else if(column === 'open'){
      project.todos.forEach(t => t.done = false)
    }else if(column === 'partial'){
      if(project.todos.length){ project.todos.forEach((t,i) => t.done = i > 0) }
    }
  }
  function renderKanban(){
      clearKanbanPlaceholder()
      const wrapOpen = document.getElementById('kbOpen')
      const wrapPart = document.getElementById('kbPartial')
      const wrapDone = document.getElementById('kbDone')
      wrapOpen.innerHTML = wrapPart.innerHTML = wrapDone.innerHTML = ''
    const list = applyFilters(state.projects || [])
    list.forEach(p => {
      const st = progressOf(p)
      const card = document.createElement('div'); card.className='kbCard'; card.draggable = true; card.dataset.id = p.id; card.dataset.col = st.status
      if(p.color){ card.style.background = `linear-gradient(180deg, color-mix(in srgb, ${p.color} 20%, transparent), rgba(255,255,255,.02))` }
      const t = document.createElement('div'); t.className='kbTitle'; t.textContent = `${p.number || '—'} · ${p.name || 'Ohne Titel'}`
      const meta = document.createElement('div'); meta.className='kbMeta'
      const due = dueBadge(p.deadline); if(due){ const b=document.createElement('span'); b.className=`badge ${due.cls}`; b.textContent=due.label; meta.appendChild(b) }
      const prog = document.createElement('div'); prog.className='kbProg'; const fill=document.createElement('i'); fill.style.width=`${st.pct}%`; prog.appendChild(fill)
      card.appendChild(t); card.appendChild(meta); card.appendChild(prog)

        card.addEventListener('dragstart', e => {
          e.dataTransfer.setData('text/proj', p.id)
          e.dataTransfer.setData('text/plain', p.id)
          e.dataTransfer.effectAllowed = 'move'
          card.style.opacity=.6
          draggingProjectId = p.id
          clearKanbanPlaceholder()
        })
        card.addEventListener('dragend',   ()=> { card.style.opacity=''; clearKanbanPlaceholder(); draggingProjectId = null })
        card.addEventListener('dragover', e => {
          const id = getDragProjectId(e)
          if(!id) return
          e.preventDefault()
          positionKanbanPlaceholder(card.parentElement, e.clientY)
        })
        card.addEventListener('drop', e => {
          e.preventDefault()
          e.stopPropagation()
          const dragId = getDragProjectId(e)
          const targetCol = kanbanPlaceholder.dataset.col || card.parentElement?.dataset.col || card.dataset.col
          const beforeId = kanbanPlaceholder.dataset.before || card.dataset.id
          if(commitKanbanDrop(dragId, targetCol, beforeId)){
            clearKanbanPlaceholder()
            draggingProjectId = null
          }
        })

      const targetList = st.status==='done' ? wrapDone : st.status==='partial' ? wrapPart : wrapOpen
      targetList.appendChild(card)
    })
      ;[wrapOpen, wrapPart, wrapDone].forEach(listEl => {
        if(!listEl) return
        listEl.ondragover = (e) => {
          const id = getDragProjectId(e)
          if(!id) return
          e.preventDefault()
          positionKanbanPlaceholder(listEl, e.clientY)
        }
        listEl.ondragleave = (e) => {
          if(!listEl.contains(e.relatedTarget)){
            clearKanbanPlaceholder()
          }
        }
        listEl.ondrop = (e) => {
          e.preventDefault()
          e.stopPropagation()
          const dragId = getDragProjectId(e)
          const targetCol = kanbanPlaceholder.dataset.col || listEl.parentElement?.dataset.col || listEl.dataset.col
          const beforeId = kanbanPlaceholder.dataset.before || ''
          if(commitKanbanDrop(dragId, targetCol, beforeId)){
            clearKanbanPlaceholder()
            draggingProjectId = null
          }
        }
      })
  }

  // ===== Timeline (Gantt‑ähnliche Ansicht) =====
  /**
   * Rendert die Timeline‑Ansicht. Sie sammelt alle To‑Dos mit gesetzter Deadline
   * und sortiert sie nach dem Fälligkeitsdatum. Für jedes Element wird eine
   * horizontale Leiste positioniert, deren horizontale Position dem Datum
   * entspricht. Die heutige Linie wird als rote vertikale Linie dargestellt.
   */

  function renderTimeline(){
    const timeline = timelineViewEl;
    if(!timeline) return;
    timeline.innerHTML = '';

    const dayMs = 86400000;
    const timelineStyle = getComputedStyle(timeline);
    const labelWidth = parseInt(timelineStyle.getPropertyValue('--timeline-label-width'), 10) || 220;
    const parseDate = (ymd) => {
      if(!ymd) return null;
      const parts = ymd.split('-').map(Number);
      if(parts.length !== 3 || parts.some(n => Number.isNaN(n))) return null;
      return new Date(Date.UTC(parts[0], parts[1]-1, parts[2]));
    };
    const startOfToday = () => {
      const now = new Date();
      return new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
    };
    const diffDays = (later, earlier) => Math.floor((later.getTime() - earlier.getTime()) / dayMs);
    const clamp = (val, min, max) => Math.min(max, Math.max(min, val));
    const activeTab = (state.timelineTab && state.tabs?.includes(state.timelineTab)) ? state.timelineTab : 'Alle';

    const tasks = [];
    (state.projects || []).forEach(p => {
      const tabName = p.tab || 'Alle';
      if(activeTab !== 'Alle' && tabName !== activeTab) return;
      const projectStart = parseDate(p.date);
      (p.todos || []).forEach(t => {
        if(!t.due || t.done) return;
        const dueDate = parseDate(t.due);
        if(!dueDate) return;
        const todoStart = parseDate(t.start) || projectStart || dueDate;
        tasks.push({ project: p, todo: t, dueDate, startDate: todoStart });
      });
    });

    const today = startOfToday();
    tasks.forEach(task => {
      task.daysToDue = diffDays(task.dueDate, today);
      task.isOverdue = task.daysToDue < 0;
    });
    tasks.sort((a,b) => {
      if(a.isOverdue && !b.isOverdue) return -1;
      if(!a.isOverdue && b.isOverdue) return 1;
      if(a.isOverdue && b.isOverdue){
        return (a.dueDate?.getTime() || 0) - (b.dueDate?.getTime() || 0);
      }
      return (a.dueDate?.getTime() || 0) - (b.dueDate?.getTime() || 0);
    });
    if(tasks.length === 0){
      const msg = document.createElement('p');
      msg.textContent = 'Keine To‑Dos mit Deadline vorhanden';
      msg.style.color = 'var(--muted)';
      timeline.appendChild(msg);
      return;
    }

    const earliestStart = tasks.reduce((min, task) => Math.min(min, task.startDate.getTime()), today.getTime());
    const earliestDue = tasks.reduce((min, task) => Math.min(min, task.dueDate.getTime()), today.getTime());
    const latestDue = tasks.reduce((max, task) => Math.max(max, task.dueDate.getTime()), today.getTime());
    const overdueSpan = Math.max(0, diffDays(today, new Date(earliestDue)));
    const futureSpan = Math.max(0, diffDays(new Date(latestDue), today));
    const paddingPast = Math.min(120, Math.max(7, overdueSpan + 7));
    const paddingFuture = Math.min(120, Math.max(14, futureSpan + 14));
    let startDate = new Date(Math.min(earliestStart, earliestDue, today.getTime()) - paddingPast * dayMs);
    let maxDate = new Date(Math.max(latestDue, today.getTime()) + paddingFuture * dayMs);
    startDate = startOfIsoWeek(startDate);
    maxDate = endOfIsoWeek(maxDate);
    let rangeDays = Math.max(1, diffDays(maxDate, startDate) + 1);
    const timelineStartMs = startDate.getTime();
    const timelineEndMs = timelineStartMs + rangeDays * dayMs;

    const baseWidth = Math.max(timeline.clientWidth || timeline.offsetWidth || 0, 960);
    const targetDays = Math.min(rangeDays, 120);
    const zoomConfig = TIMELINE_ZOOMS.find(z => z.value === state.timelineZoom) || TIMELINE_ZOOMS[TIMELINE_ZOOMS.length - 1];
    if(state.timelineZoom !== zoomConfig.value){
      state.timelineZoom = zoomConfig.value;
      updateTimelineZoomIndicator(zoomConfig.value);
    } else {
      updateTimelineZoomIndicator(zoomConfig.value);
    }
    timeline.dataset.zoom = zoomConfig.value;
    let pxPerDay = Math.floor((baseWidth - labelWidth - 40) / Math.max(1, targetDays));
    if(!Number.isFinite(pxPerDay) || pxPerDay <= 0) pxPerDay = zoomConfig.min;
    pxPerDay = clamp(pxPerDay, zoomConfig.min, zoomConfig.max);
    timeline.style.setProperty('--timeline-px-day', `${pxPerDay}px`);
    timeline.style.setProperty('--timeline-grid-step', `${pxPerDay * (zoomConfig.unitDays || 1)}px`);
    const configuredRow = parseInt(timelineStyle.getPropertyValue('--timeline-row-height'), 10) || 40;
    const rowHeight = Math.max(40, configuredRow);
    const barHeight = Math.max(12, Math.round(rowHeight * 0.35));
    timeline.style.setProperty('--timeline-row-height', `${rowHeight}px`);
    timeline.style.setProperty('--timeline-bar-height', `${barHeight}px`);

    const monthNames = ['Jan','Feb','Mär','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez'];
    const monthsRow = document.createElement('div');
    monthsRow.className = 'timelineMonths';
    let iDay = 0;
    while(iDay < rangeDays){
      const current = new Date(startDate.getTime() + iDay * dayMs);
      const monthEnd = new Date(Date.UTC(current.getUTCFullYear(), current.getUTCMonth() + 1, 0));
      const endOffsetRaw = diffDays(monthEnd, startDate) + 1;
      const endOffset = Math.min(rangeDays, endOffsetRaw);
      let daysInSeg = endOffset - iDay;
      if(daysInSeg <= 0){ daysInSeg = 1; }
      const mCell = document.createElement('div');
      mCell.className = 'timeline-month';
      mCell.style.width = `${daysInSeg * pxPerDay}px`;
      const y = current.getUTCFullYear();
      mCell.textContent = `${monthNames[current.getUTCMonth()]} ${String(y).slice(-2)}`;
      monthsRow.appendChild(mCell);
      iDay += daysInSeg;
    }
    timeline.appendChild(monthsRow);

    const weeksRow = document.createElement('div');
    weeksRow.className = 'timelineWeeks';
    const totalWeeks = Math.ceil(rangeDays / 7);
    for(let w=0; w<totalWeeks; w++){
      const weekStartDate = new Date(startDate.getTime() + w * 7 * dayMs);
      const iso = isoWeekOf(weekStartDate);
      const segDays = Math.min(7, rangeDays - w * 7);
      const wCell = document.createElement('div');
      wCell.className = 'timeline-week';
      wCell.style.width = `${Math.max(segDays, 1) * pxPerDay}px`;
      const label = `KW ${String(iso.week).padStart(2,'0')}`;
      wCell.textContent = label;
      wCell.title = `${label} / ${iso.year}`;
      weeksRow.appendChild(wCell);
    }
    timeline.appendChild(weeksRow);

    if(zoomConfig.showDays){
      const daysRow = document.createElement('div');
      daysRow.className = 'timelineDays';
      for(let i=0; i<rangeDays; i++){
        const d = new Date(startDate.getTime() + i * dayMs);
        const cell = document.createElement('div');
        cell.className = 'timeline-day';
        cell.style.width = `${pxPerDay}px`;
        let label = '';
        if(zoomConfig.value === 'days'){
          label = d.getUTCDate();
        }else if(zoomConfig.value === 'compact'){
          const dow = d.getUTCDay();
          if(dow === 1){
            label = `Mo ${d.getUTCDate()}`;
          }else if(dow === 3){
            label = 'Mi';
          }else if(dow === 5){
            label = 'Fr';
          }
        }
        cell.textContent = label;
        daysRow.appendChild(cell);
      }
      timeline.appendChild(daysRow);
    }

    timeline.setAttribute('data-taskcount', tasks.length);

    const chart = document.createElement('div');
    chart.className = 'timelineChart';
    chart.style.height = `${tasks.length * rowHeight}px`;
    const chartWidth = rangeDays * pxPerDay;
    chart.style.width = `${chartWidth}px`;
    timeline.appendChild(chart);

    const weekLines = document.createElement('div');
    weekLines.className = 'timeline-week-boundaries';
    let lastBoundary = null;
    for(let offset = 0; offset <= rangeDays; offset += 7){
      const left = offset * pxPerDay;
      if(left > chartWidth + 1) break;
      const line = document.createElement('div');
      line.className = 'timeline-week-line';
      line.style.left = `${left}px`;
      weekLines.appendChild(line);
      lastBoundary = left;
    }
    if(lastBoundary === null || Math.abs(lastBoundary - chartWidth) > 1){
      const endLine = document.createElement('div');
      endLine.className = 'timeline-week-line';
      endLine.style.left = `${chartWidth}px`;
      weekLines.appendChild(endLine);
    }
    chart.appendChild(weekLines);

    const todayLine = document.createElement('div');
    todayLine.className = 'today-line';
    const todayOffsetDays = clamp(diffDays(today, startDate), 0, rangeDays);
    const isDayLikeZoom = zoomConfig.value === 'days' || zoomConfig.value === 'compact';
    let todayLeftPx = todayOffsetDays * pxPerDay;
    if(isDayLikeZoom){
      todayLeftPx += pxPerDay / 2;
    }
    const todayMarkerPx = Math.max(0, Math.min(todayLeftPx, chartWidth));
    todayLine.style.left = `${todayMarkerPx}px`;
    todayLine.style.height = `${tasks.length * rowHeight}px`;
    chart.appendChild(todayLine);

    tasks.forEach((task, idx) => {
      const row = document.createElement('div');
      row.className = 'timeline-row';
      row.style.top = `${idx * rowHeight}px`;

      const label = document.createElement('div');
      label.className = 'timeline-label';
      const projNum = task.project.number || '';
      const labelText = `${projNum} – ${task.todo.text}`;
      const textSpan = document.createElement('span');
      textSpan.className = 'timeline-label-text';
      textSpan.textContent = labelText;
      const bubble = document.createElement('div');
      bubble.className = 'timeline-label-bubble';
      bubble.textContent = labelText;
      label.appendChild(textSpan);
      label.appendChild(bubble);
      label.title = `${projNum ? projNum + ' · ' : ''}${task.project.name || ''}`.trim();
      row.appendChild(label);
      const { dueDate, startDate: start } = task;
      const effectiveStart = task.isOverdue
        ? (start <= dueDate ? start : dueDate)
        : today;
      const startMs = effectiveStart.getTime();
      const inclusiveSpanDays = Math.max(1, diffDays(dueDate, effectiveStart) + 1);
      const startVisibleMs = Math.min(Math.max(startMs, timelineStartMs), timelineEndMs);
      const dueOffsetDays = diffDays(dueDate, startDate);
      const clampedDueDays = clamp(dueOffsetDays, 0, rangeDays);
      const dueCenterPx = clampedDueDays * pxPerDay + (pxPerDay / 2);
      let leftPxRaw = ((startVisibleMs - timelineStartMs) / dayMs) * pxPerDay;
      if(!task.isOverdue && isDayLikeZoom){
        leftPxRaw += pxPerDay / 2;
      }
      let leftPx = Math.max(0, Math.min(chartWidth, leftPxRaw));
      let endPx = clamp(dueCenterPx, 0, chartWidth);
      if(endPx > leftPx){
        const gapPx = Math.min(Math.max(pxPerDay * 0.1, 2), endPx - leftPx);
        endPx -= gapPx;
      }
      if(endPx < leftPx){
        endPx = leftPx;
      }
      let widthPx = Math.max(0, endPx - leftPx);

      const formatDate = (d) => `${String(d.getUTCDate()).padStart(2,'0')}.${String(d.getUTCMonth()+1).padStart(2,'0')}.${d.getUTCFullYear()}`;
      const rangeLabel = inclusiveSpanDays > 1 ? `${inclusiveSpanDays} Tage` : '1 Tag';
      const tooltip = `${formatDate(effectiveStart)} → ${formatDate(dueDate)} (${rangeLabel})\n` + (task.daysToDue >= 0 ? `Noch ${task.daysToDue} Tag${task.daysToDue===1?'':'e'}` : `Überfällig seit ${Math.abs(task.daysToDue)} Tag${Math.abs(task.daysToDue)===1?'':'en'}`);

      row.classList.toggle('overdue', task.isOverdue);
      if(task.isOverdue){
        const overdueBar = document.createElement('div');
        overdueBar.className = 'timeline-bar overdue';
        const overdueDays = Math.abs(task.daysToDue);
        const dueOffset = diffDays(dueDate, startDate);
        const overdueStartDays = clamp(dueOffset, 0, rangeDays);
        let overdueLeftPx = dueOffset < 0 ? 0 : overdueStartDays * pxPerDay;
        let clampedLeft = Math.max(0, Math.min(overdueLeftPx, chartWidth));
        let overdueWidthPx = todayMarkerPx - clampedLeft;
        if(overdueWidthPx <= 0){
          overdueWidthPx = pxPerDay * 0.75;
          clampedLeft = Math.max(0, Math.min(todayMarkerPx - overdueWidthPx, chartWidth));
        }
        if(clampedLeft + overdueWidthPx > chartWidth){
          overdueWidthPx = Math.max(chartWidth - clampedLeft, pxPerDay * 0.5);
        }
        overdueWidthPx = Math.max(overdueWidthPx, pxPerDay * 0.5);
        overdueBar.style.left = `${clampedLeft}px`;
        overdueBar.style.width = `${overdueWidthPx}px`;
        const span = document.createElement('span');
        span.textContent = `${overdueDays} Tag${overdueDays === 1 ? '' : 'e'} überfällig`;
        overdueBar.appendChild(span);
        overdueBar.title = tooltip;
        row.appendChild(overdueBar);
      }else{
        const bar = document.createElement('div');
        bar.className = 'timeline-bar';
        bar.style.left = `${leftPx}px`;
        bar.style.width = `${widthPx}px`;
        bar.title = tooltip;
        if(task.todo.done){ bar.style.background = 'var(--muted)'; }
        else if(task.daysToDue < 0){ bar.style.background = 'var(--danger)'; }
        else { bar.style.background = task.project.color || 'var(--accent)'; }
        row.appendChild(bar);
      }

      chart.appendChild(row);
    });

    const visibleWidth = (timeline.clientWidth || 0) - labelWidth;
    const scrollTarget = todayMarkerPx - (visibleWidth > 0 ? visibleWidth / 2 : 0);
    timeline.scrollLeft = scrollTarget > 0 ? scrollTarget : 0;
  }


  function renderDispo(){
    if(!dispoView || !dispoListEl) return;
    ensureDispo();
    if(dispoBreadcrumbsEl) dispoBreadcrumbsEl.innerHTML = '';
    dispoListEl.innerHTML = '';
    const entries = (state.dispo || []).slice();
    let normalized = false;
    const structure = new Map();
    const currentWeek = isoWeekOf(new Date());

    entries.forEach(entry => {
      if(!entry || typeof entry !== 'object') return;
      if(!entry.id){ entry.id = uid(); normalized = true; }
      const rawYear = Number(entry.year);
      if(Number.isFinite(rawYear)){ entry.year = rawYear; }
      else { entry.year = currentWeek.year; normalized = true; }
      let rawWeek = Number(entry.week);
      if(!Number.isFinite(rawWeek)) rawWeek = currentWeek.week;
      rawWeek = Math.max(1, Math.min(53, rawWeek));
      if(rawWeek !== entry.week){ entry.week = rawWeek; normalized = true; }
      if(!Array.isArray(entry.items)){ entry.items = []; normalized = true; }
      entry.items.forEach(item => { if(item && !item.id){ item.id = uid(); normalized = true; } });
    });

    if(!entries.length){
      dispoListEl.classList.remove('chooser');
      const empty = document.createElement('div');
      empty.className = 'dispoEmpty';
      empty.textContent = 'Noch keine Dispo-Einträge erfasst.';
      dispoListEl.appendChild(empty);
      if(dispoBreadcrumbsEl){
        const hint = document.createElement('span');
        hint.textContent = 'Noch keine Dispo-Einträge vorhanden.';
        dispoBreadcrumbsEl.appendChild(hint);
      }
      if(normalized) setDirty(true);
      return;
    }

    entries.sort((a,b) => {
      if(b.year !== a.year) return b.year - a.year;
      return (b.week || 0) - (a.week || 0);
    });

    entries.forEach(entry => {
      const yr = entry.year;
      const wk = entry.week || 1;
      const { start } = weekRange(yr, wk);
      const month = start.getUTCMonth();
      if(!structure.has(yr)) structure.set(yr, new Map());
      const months = structure.get(yr);
      if(!months.has(month)) months.set(month, []);
      months.get(month).push(entry);
    });

    structure.forEach(months => {
      months.forEach(list => {
        list.sort((a,b) => (a.week || 0) - (b.week || 0));
      });
    });

    if(dispoNavigator.year && !structure.has(dispoNavigator.year)){
      dispoNavigator.year = null;
      dispoNavigator.month = null;
    }
    if(dispoNavigator.year && dispoNavigator.month !== null){
      const months = structure.get(dispoNavigator.year);
      if(!months || !months.has(dispoNavigator.month)){
        dispoNavigator.month = null;
      }
    }

    const renderBreadcrumbs = () => {
      if(!dispoBreadcrumbsEl) return;
      dispoBreadcrumbsEl.innerHTML = '';
      const addSep = () => {
        const sep = document.createElement('span');
        sep.className = 'sep';
        sep.textContent = '›';
        dispoBreadcrumbsEl.appendChild(sep);
      };
      const addBtn = (label, active, handler) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = label;
        if(active) btn.classList.add('active');
        if(handler){ btn.addEventListener('click', handler); }
        else { btn.disabled = true; }
        dispoBreadcrumbsEl.appendChild(btn);
      };
      addBtn('Jahre', !dispoNavigator.year, () => {
        dispoNavigator.year = null;
        dispoNavigator.month = null;
        renderDispo();
      });
      if(dispoNavigator.year){
        addSep();
        addBtn(String(dispoNavigator.year), dispoNavigator.month === null, () => {
          dispoNavigator.month = null;
          renderDispo();
        });
        if(dispoNavigator.month !== null){
          addSep();
          const monthLabel = MONTH_NAMES[dispoNavigator.month] || `Monat ${dispoNavigator.month + 1}`;
          addBtn(`${monthLabel} ${dispoNavigator.year}`, true, null);
        }
      }
    };

    const showYearSelection = () => {
      dispoListEl.classList.add('chooser');
      const years = Array.from(structure.keys()).sort((a,b) => b - a);
      years.forEach(year => {
        const months = structure.get(year);
        let weekCount = 0;
        months.forEach(list => { weekCount += list.length; });
        const monthCount = months.size;
        const card = document.createElement('div');
        card.className = 'dispoCard';
        const title = document.createElement('strong');
        title.textContent = String(year);
        const info = document.createElement('span');
        info.textContent = `${weekCount} Woche${weekCount === 1 ? '' : 'n'} in ${monthCount} Monat${monthCount === 1 ? '' : 'en'}`;
        card.appendChild(title);
        card.appendChild(info);
        card.addEventListener('click', () => {
          dispoNavigator.year = year;
          dispoNavigator.month = null;
          renderDispo();
        });
        dispoListEl.appendChild(card);
      });
    };

    const showMonthSelection = year => {
      dispoListEl.classList.add('chooser');
      const months = structure.get(year);
      const monthKeys = Array.from(months.keys()).sort((a,b) => a - b);
      monthKeys.forEach(month => {
        const list = months.get(month) || [];
        const card = document.createElement('div');
        card.className = 'dispoCard';
        const title = document.createElement('strong');
        title.textContent = `${MONTH_NAMES[month] || 'Monat'} ${year}`;
        const info = document.createElement('span');
        info.textContent = `${list.length} Woche${list.length === 1 ? '' : 'n'}`;
        card.appendChild(title);
        card.appendChild(info);
        card.addEventListener('click', () => {
          dispoNavigator.month = month;
          renderDispo();
        });
        dispoListEl.appendChild(card);
      });
    };

    const showWeekEntries = (year, month) => {
      dispoListEl.classList.remove('chooser');
      const months = structure.get(year);
      const list = months ? months.get(month) || [] : [];
      if(!list.length){
        const empty = document.createElement('div');
        empty.className = 'dispoEmpty';
        empty.textContent = 'Für diesen Monat wurden noch keine Wochen erfasst.';
        dispoListEl.appendChild(empty);
        return;
      }
      list.forEach(entry => {
        dispoListEl.appendChild(buildDispoEntry(entry));
      });
    };

    renderBreadcrumbs();

    dispoListEl.classList.remove('chooser');

    if(!dispoNavigator.year){
      showYearSelection();
    }else if(dispoNavigator.month === null){
      showMonthSelection(dispoNavigator.year);
    }else{
      showWeekEntries(dispoNavigator.year, dispoNavigator.month);
    }

    if(normalized) setDirty(true);
  }
  function buildDispoEntry(entry){
    const details = document.createElement('details');
    details.className = 'dispoEntry';
    details.open = entry.collapsed ? false : true;
    details.addEventListener('toggle', () => {
      entry.collapsed = !details.open;
      setDirty(true);
    });
    const summary = document.createElement('summary');
    const titleWrap = document.createElement('div'); titleWrap.className = 'dispoSummaryTitle';
    const weekInfo = isoWeekOf(new Date());
    const year = entry.year || weekInfo.year;
    const week = entry.week || weekInfo.week;
    const heading = document.createElement('span');
    heading.textContent = `KW ${String(week).padStart(2,'0')} · ${formatWeekRange(year, week)}`;
    titleWrap.appendChild(heading);
    if(entry.title){
      const sub = document.createElement('span'); sub.className = 'dispoRange'; sub.textContent = entry.title; titleWrap.appendChild(sub);
    }
    summary.appendChild(titleWrap);
    const meta = document.createElement('span'); meta.className = 'dispoSummaryMeta'; meta.textContent = `${(entry.items||[]).length} To-Dos`;
    summary.appendChild(meta);
    const actions = document.createElement('div'); actions.className = 'dispoSummaryActions';
    const del = document.createElement('button'); del.type = 'button'; del.textContent = 'Löschen'; del.title = 'Dispo-Eintrag entfernen';
    del.addEventListener('click', e => {
      e.preventDefault(); e.stopPropagation();
      if(confirm('Diesen Dispo-Eintrag wirklich löschen?')){
        pushHistory();
        state.dispo = (state.dispo || []).filter(d => d.id !== entry.id);
        setDirty(true);
        render();
      }
    });
    actions.appendChild(del);
    summary.appendChild(actions);
    details.appendChild(summary);

    const body = document.createElement('div'); body.className = 'dispoBody';

    const titleField = document.createElement('div'); titleField.className = 'dispoField';
    const titleLabel = document.createElement('label'); titleLabel.textContent = 'Titel / Fokus';
    const titleInput = document.createElement('input'); titleInput.type = 'text'; titleInput.value = entry.title || '';
    titleInput.placeholder = 'z. B. Themen der Dispo';
    titleInput.addEventListener('change', () => {
      pushHistory();
      entry.title = titleInput.value.trim();
      setDirty(true);
      render();
    });
    titleField.appendChild(titleLabel); titleField.appendChild(titleInput);
    body.appendChild(titleField);

    const notesWrap = document.createElement('div'); notesWrap.className = 'dispoNotes dispoField';
    const notesLabel = document.createElement('label'); notesLabel.textContent = 'Notizen';
    const notesArea = document.createElement('textarea'); notesArea.value = entry.notes || '';
    notesArea.placeholder = 'Protokollnotizen für das Team…';
    notesArea.addEventListener('change', () => {
      pushHistory();
      entry.notes = notesArea.value.trim();
      setDirty(true);
      render();
    });
    notesWrap.appendChild(notesLabel); notesWrap.appendChild(notesArea);
    body.appendChild(notesWrap);

    const itemsWrap = document.createElement('div'); itemsWrap.className = 'dispoItems';
    const head = document.createElement('div'); head.className = 'dispoItemHead';
    head.innerHTML = '<span>Projekt</span><span>Bearbeiter/in</span><span>To-Do</span><span>Deadline</span><span></span>';
    itemsWrap.appendChild(head);
    (entry.items || []).forEach(item => itemsWrap.appendChild(buildDispoItemRow(entry, item)));

    const addRow = document.createElement('div'); addRow.className = 'dispoAddItem';
    const addProject = document.createElement('input'); addProject.type='text'; addProject.placeholder='Projekt / Bereich';
    const addAssignee = document.createElement('input'); addAssignee.type='text'; addAssignee.placeholder='Bearbeiter/in';
    const addTodo = document.createElement('input'); addTodo.type='text'; addTodo.placeholder='To-Do';
    const addDue = document.createElement('input'); addDue.type='date';
    const addBtn = document.createElement('button'); addBtn.type='button'; addBtn.className='btnPrimary'; addBtn.textContent='+ Hinzufügen';
    const submitNew = () => {
      const todoText = addTodo.value.trim();
      if(!todoText){
        addTodo.focus();
        return;
      }
      pushHistory();
      entry.items.push({ id: uid(), project: addProject.value.trim(), assignee: addAssignee.value.trim(), todo: todoText, due: addDue.value });
      setDirty(true);
      addProject.value = addAssignee.value = addTodo.value = '';
      addDue.value = '';
      render();
    };
    addBtn.addEventListener('click', submitNew);
    addTodo.addEventListener('keydown', e => { if(e.key === 'Enter'){ e.preventDefault(); submitNew(); }});
    addDue.addEventListener('keydown', e => { if(e.key === 'Enter'){ e.preventDefault(); submitNew(); }});
    addRow.appendChild(addProject);
    addRow.appendChild(addAssignee);
    addRow.appendChild(addTodo);
    addRow.appendChild(addDue);
    addRow.appendChild(addBtn);
    itemsWrap.appendChild(addRow);

    body.appendChild(itemsWrap);
    details.appendChild(body);
    return details;
  }
  function buildDispoItemRow(entry, item){
    const row = document.createElement('div'); row.className = 'dispoItemRow';
    const project = document.createElement('input'); project.type='text'; project.value = item.project || ''; project.placeholder='Projekt / Bereich';
    project.addEventListener('change', () => { pushHistory(); item.project = project.value.trim(); setDirty(true); render(); });
    const assignee = document.createElement('input'); assignee.type='text'; assignee.value = item.assignee || ''; assignee.placeholder='Bearbeiter/in';
    assignee.addEventListener('change', () => { pushHistory(); item.assignee = assignee.value.trim(); setDirty(true); render(); });
    const todo = document.createElement('input'); todo.type='text'; todo.value = item.todo || ''; todo.placeholder='Aufgabe';
    todo.addEventListener('change', () => { pushHistory(); item.todo = todo.value.trim(); setDirty(true); render(); });
    const due = document.createElement('input'); due.type='date'; due.value = item.due || '';
    due.addEventListener('change', () => { pushHistory(); item.due = due.value; setDirty(true); render(); });
    const remove = document.createElement('button'); remove.type='button'; remove.innerHTML='&times;'; remove.title='To-Do entfernen';
    remove.addEventListener('click', () => {
      pushHistory();
      entry.items = entry.items.filter(it => it.id !== item.id);
      setDirty(true);
      render();
    });
    row.appendChild(project);
    row.appendChild(assignee);
    row.appendChild(todo);
    row.appendChild(due);
    row.appendChild(remove);
    return row;
  }

  // ===== Warnung für nahe Deadlines =====
  // Die Warnleiste für nahe Deadlines wurde entfernt. Deadlines werden nun über die Timeline sichtbar gemacht.

  // ===== Farb-Popover (OK/Abbrechen) =====
  const colorPop = document.getElementById('colorPop')
  const colorPicker = document.getElementById('colorPicker')
  const colorCancel = document.getElementById('colorCancel')
  const colorOk = document.getElementById('colorOk')
  let colorTarget = { project:null, original:'#7c3aed' }

  function openColorPopover(anchor, project){
    colorTarget.project = project
    colorTarget.original = project.color || '#7c3aed'
    colorPicker.value = colorTarget.original
    colorPop.style.display='block'
    // Position neben dem Button
    const r = anchor.getBoundingClientRect()
    colorPop.style.left = (r.left) + 'px'
    colorPop.style.top  = (r.bottom + 8) + 'px'
  }
  document.querySelectorAll('.colorPopover .sw').forEach(sw => sw.addEventListener('click', () => colorPicker.value = sw.dataset.v ))
  colorCancel.addEventListener('click', () => { colorPop.style.display='none' })
  colorOk.addEventListener('click', () => {
    if(!colorTarget.project) return
    const v = colorPicker.value
    pushHistory(); colorTarget.project.color = v; setDirty(true); colorPop.style.display='none'; render()
  })
  window.addEventListener('resize', () => { if(colorPop.style.display==='block') colorPop.style.display='none' })
  window.addEventListener('scroll', () => { if(colorPop.style.display==='block') colorPop.style.display='none' })

  // ===== Datei Save/Open (mit AutoSave-to-file) =====
  function buildSelfContainedHTML(){
    const html = document.documentElement.cloneNode(true)
    html.querySelector('#APP_STATE').textContent = JSON.stringify(state)
    try{ localStorage.removeItem(autosaveKey) }catch(e){}
    return '<!DOCTYPE html>\n' + html.outerHTML
  }
  const isAbortError = (err) => err && (err.name === 'AbortError' || err.code === 20)
  async function requestSaveHandle(opts){
    try{
      return await window.showSaveFilePicker(opts)
    }catch(err){
      if(isAbortError(err)) return null
      throw err
    }
  }
  async function requestOpenHandles(opts){
    try{
      return await window.showOpenFilePicker(opts)
    }catch(err){
      if(isAbortError(err)) return []
      throw err
    }
  }
  async function saveToHandle(handle, silent=false){
    const writable = await handle.createWritable()
    await writable.write(new Blob([buildSelfContainedHTML()], {type:'text/html'}))
    await writable.close(); setDirty(false); if(!silent) showToast('Gespeichert')
  }
  async function save(){
    if(window.showSaveFilePicker && fileHandle){ await saveToHandle(fileHandle); return }
    if(window.showSaveFilePicker){
      const handle = await requestSaveHandle({ suggestedName:'projekte.html', types:[{ description:'HTML', accept:{'text/html':['.html']} }] })
      if(!handle) return
      fileHandle = handle; await saveToHandle(fileHandle)
    }else{
      const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([buildSelfContainedHTML()],{type:'text/html'})); a.download='projekte.html'; a.click(); URL.revokeObjectURL(a.href); setDirty(false); showToast('Datei gespeichert')
    }
  }
  async function saveAs(){
    if(window.showSaveFilePicker){
      const handle = await requestSaveHandle({ suggestedName:'projekte.html', types:[{ description:'HTML', accept:{'text/html':['.html']} }] })
      if(!handle) return
      fileHandle = handle; await saveToHandle(fileHandle)
    }else{
      const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([buildSelfContainedHTML()],{type:'text/html'})); a.download='projekte.html'; a.click(); URL.revokeObjectURL(a.href); setDirty(false); showToast('Datei gespeichert')
    }
  }
  async function openFile(){
    if(!window.showOpenFilePicker){ alert('Öffnen erfordert einen aktuellen Chromium-Browser'); return }
    const handles = await requestOpenHandles({ types:[{ description:'HTML oder JSON', accept:{ 'text/html':['.html'], 'application/json':['.json'] } }] })
    if(!handles || !handles.length) return
    const [handle] = handles
    const file = await handle.getFile(); const text = await file.text()
    let loaded=null
    if(file.type==='application/json' || file.name.endsWith('.json')) loaded=JSON.parse(text)
    else{ const tmp=document.createElement('div'); tmp.innerHTML=text; const tag=tmp.querySelector('#APP_STATE'); if(tag) loaded=JSON.parse(tag.textContent||'{}') }
    if(loaded){ fileHandle=handle; pushHistory(); state={...state,...loaded}; setDirty(false); render(); showToast('Datei geladen') }
    else alert('Kein eingebetteter Zustand gefunden')
  }
  // Auto-Save-to-file (wenn Handle vorhanden)
  setInterval(async () => {
    if(!unsaved) return
    if(fileHandle && 'createWritable' in fileHandle){ try{ await saveToHandle(fileHandle, true); showToast('Automatisch gespeichert') }catch(e){} }
  }, 20000)

  // ===== Events =====
  document.getElementById('saveBtn').addEventListener('click', save)
  document.getElementById('saveFab').addEventListener('click', save)
  document.getElementById('printBtn').addEventListener('click', () => window.print())
  const printDetailToggle = document.getElementById('printDetailToggle')
  if(printDetailToggle){
    const syncPrintToggle = () => {
      const active = document.body.classList.contains('print-detailed')
      printDetailToggle.classList.toggle('on', active)
      printDetailToggle.textContent = active ? 'Druck-Details: AN' : 'Druck-Details: AUS'
    }
    printDetailToggle.addEventListener('click', () => {
      document.body.classList.toggle('print-detailed')
      syncPrintToggle()
    })
    window.addEventListener('afterprint', syncPrintToggle)
    syncPrintToggle()
  }
  document.getElementById('undoBtn').addEventListener('click', undo)
  document.getElementById('redoBtn').addEventListener('click', redo)
  document.getElementById('backupBtn').addEventListener('click', () => {
    const fname = 'projekte-backup-' + new Date().toISOString().replace(/[:.]/g,'-') + '.json'
    const blob = new Blob([JSON.stringify(state,null,2)], {type:'application/json'})
    if(window.showSaveFilePicker){
      window.showSaveFilePicker({ suggestedName: fname, types:[{description:'JSON', accept:{'application/json':['.json']}}]})
      .then(async handle => {
        const w = await handle.createWritable();
        await w.write(blob);
        await w.close();
        showToast('Backup gespeichert');
      })
      .catch(()=>{ /* Abbruch ignorieren */ });
    } else {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = fname;
      a.click();
      URL.revokeObjectURL(a.href);
      showToast('Backup gespeichert');
    }
  });

  // Datei öffnen/speichern (Buttons)
  // Die "Datei öffnen"‑Schaltfläche wurde entfernt, daher darf kein Event mehr gebunden werden.
  // Wir binden lediglich die "Speichern unter"‑Funktion an die vorhandene Schaltfläche.
  document.getElementById('saveAsBtn').addEventListener('click', saveAs);

  // CSV Import
  document.getElementById('csvImportBtn').addEventListener('click', () => {
    const inp = document.createElement('input');
    inp.type = 'file'; inp.accept = '.csv,text/csv';
    inp.onchange = () => {
      const f = inp.files[0]; if(!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        const rows = parseCSV(String(reader.result));
        if(!rows.length){ alert('CSV leer.'); return; }
        const header = rows[0].map(h => (h||'').toLowerCase());
        const idx = {
          id: header.findIndex(h => h === 'id' || h.includes('projekt-id')),
          nr: header.findIndex(h => h.includes('projektnummer') || h === 'nr'),
          name: header.findIndex(h => h.includes('projektname') || h === 'name'),
          date: header.findIndex(h => h === 'datum' || (h.includes('datum') && !h.includes('deadline'))),
          deadline: header.findIndex(h => h.includes('deadline') || h.includes('fälligkeit')),
          showDeadline: header.findIndex(h => h.includes('sichtbar') || h.includes('showdeadline')),
          todos: header.findIndex(h => h.includes('todo') || h.includes('aufgaben')),
          notes: header.findIndex(h => h.includes('notiz') || h.includes('notes')),
          tab: header.findIndex(h => h === 'tab' || h.includes('gruppe')),
          folder: header.findIndex(h => h.includes('pfad') || h.includes('ordner')),
          color: header.findIndex(h => h.includes('farbe')),
          collapsed: header.findIndex(h => h.includes('eingeklappt') || h.includes('collapsed')),
          order: header.findIndex(h => h.includes('sort'))
        };
        const boolFrom = (val) => {
          const v = (val || '').toString().trim().toLowerCase();
          return ['true','1','ja','yes','wahr','on'].includes(v);
        };
        pushHistory();
        const initialOrder = state.order && state.order.length ? state.order.slice() : state.projects.map(p => p.id);
        const importedOrder = [];
        for(let r=1; r<rows.length; r++){
          const c = rows[r] || [];
          if(!c.length || c.every(x => !x)) continue;
          const todosRaw = idx.todos>=0 ? (c[idx.todos]||'') : '';
          const todos = todosRaw.split('|')
            .map(s => s.trim()).filter(Boolean)
            .map(item => {
              const done = item.startsWith('[x]');
              const text = item.replace(/^\[(x| )\]\s*/i,'');
              const m = text.match(/^(.*)\s@(\d{4}-\d{2}-\d{2})$/);
              return { text: (m?m[1]:text).trim(), done, due: m?m[2]:'' };
            });

          let projectId = idx.id>=0 ? (c[idx.id]||'').trim() : '';
          if(!projectId) projectId = uid();
          if(state.projects.some(x => x.id === projectId)) projectId = uid();

          const p = {
            id: projectId,
            number: idx.nr>=0 ? (c[idx.nr]||'') : '',
            name: idx.name>=0 ? (c[idx.name]||'') : '',
            date: idx.date>=0 ? (c[idx.date]||'') : '',
            deadline: idx.deadline>=0 ? (c[idx.deadline]||'') : '',
            showDeadline: idx.showDeadline>=0 ? boolFrom(c[idx.showDeadline]) : !!(idx.deadline>=0 && c[idx.deadline]),
            todos,
            notes: idx.notes>=0 ? (c[idx.notes]||'') : '',
            tab: (idx.tab>=0 && c[idx.tab]) ? c[idx.tab] : (state.currentTab||'Alle'),
            folder: idx.folder>=0 ? (c[idx.folder]||'') : '',
            color: idx.color>=0 ? (c[idx.color]||'') : '',
            collapsed: idx.collapsed>=0 ? boolFrom(c[idx.collapsed]) : false
          };
          state.projects.push(p);
          if(p.tab && !state.tabs.includes(p.tab) && p.tab!=='Alle') state.tabs.push(p.tab);
          if(idx.order>=0){
            const sortToken = Number((c[idx.order]||'').trim());
            if(Number.isFinite(sortToken)) importedOrder.push({ id: p.id, order: sortToken });
          }
        }
        if(importedOrder.length){
          importedOrder.sort((a,b) => a.order - b.order);
          const orderedIds = importedOrder.map(o => o.id);
          const merged = initialOrder.filter(id => !orderedIds.includes(id));
          importedOrder.forEach(({id}) => merged.push(id));
          state.order = merged;
          state.orderByTab['Alle'] = merged.slice();
          state.filters.sort = 'manual';
        }else{
          const merged = initialOrder.slice();
          state.projects.forEach(proj => { if(!merged.includes(proj.id)) merged.push(proj.id); });
          state.order = merged;
          state.orderByTab['Alle'] = merged.slice();
        }
        setDirty(true); render(); showToast('CSV importiert');
      };
      reader.readAsText(f);
    };
    inp.click();
  });

  // CSV Export / Kalender-Export
  document.getElementById('csvExportBtn')
    .addEventListener('click', () => exportCSV(applyFilters(state.projects),'projekte.csv'));
  document.getElementById('calendarExportBtn')
    .addEventListener('click', () => exportICS(applyFilters(state.projects),'projekte.ics'));

  // Projekt hinzufügen
  const inNr = document.getElementById('inNr'),
        inName = document.getElementById('inName'),
        inDate = document.getElementById('inDate'),
        inDateCalBtn = document.getElementById('inDateCalBtn'),
        inFolder = document.getElementById('inFolder'),
        inTodos = document.getElementById('inTodos');

  // Kalenderbutton für das Projektdatum: öffnet einen nativen Date‑Picker direkt unter dem Icon
  if(inDateCalBtn){
    inDateCalBtn.addEventListener('click', (ev) => {
      ev.preventDefault();
      const existing = parseGermanDate(inDate.value.trim());
      openDatePicker(inDateCalBtn, {
        value: existing,
        onSelect: (date) => {
          inDate.value = formatGermanDate(date);
        }
      });
    });
  }

  document.getElementById('addBtn').addEventListener('click', () => {
    const number = inNr.value.trim(),
          name   = inName.value.trim(),
          // Datum aus dem Eingabefeld (tt.mm.jjjj) in ISO‑Format umwandeln
          date   = (function(raw){
            const m = (raw||'').trim().match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/);
            if(!m) return '';
            const [_, dd, mm, yyyy] = m;
            return `${yyyy.padStart(4,'0')}-${mm.padStart(2,'0')}-${dd.padStart(2,'0')}`;
          })(inDate.value),
          folder = inFolder.value.trim();
    const todos = (inTodos.value||'').split(';').map(s=>s.trim()).filter(Boolean)
                   .map(s => ({text:s, done:false, due:''}));
    if(!number && !name){ alert('Bitte Projektnummer oder Projektnamen eingeben.'); return; }
    pushHistory();
    const p = { id:uid(), number, name, date, deadline:'', showDeadline:false,
                todos, notes:'', tab: state.currentTab || 'Alle', folder, color:'', collapsed:false };
    state.projects.unshift(p);
    if(state.filters.sort==='manual'){
      state.order = Array.isArray(state.order) ? state.order.filter(id => id !== p.id) : [];
      state.order.unshift(p.id);
      state.orderByTab['Alle'] = state.order.slice();
      const tabKey = orderKeyForTab(p.tab || state.currentTab || 'Alle');
      if(tabKey !== 'Alle'){
        const scoped = getManualOrderArray(tabKey).filter(id => id !== p.id);
        scoped.unshift(p.id);
        state.orderByTab[tabKey] = scoped;
      }
    }
    setDirty(true); render();
    inNr.value=''; inName.value=''; inDate.value=''; inFolder.value=''; inTodos.value='';
    inNr.focus();
  });

  // Filter
  const q = document.getElementById('q'),
        status = document.getElementById('status'),
        sort = document.getElementById('sort'),
        pctMin = document.getElementById('pctMin'),
        pctMax = document.getElementById('pctMax');
  // Hinweis: Der Warnzeitraum für Deadlines wurde entfernt. Es gibt daher kein alertInput mehr.

  // Kein Warnzeitraum mehr – Deadlines werden über die Timeline verwaltet.

  function updateFilters(){
    state.filters.q = q.value;
    state.filters.status = status.value;
    state.filters.sort = sort.value;
    state.filters.pctMin = clampPct(pctMin.value);
    state.filters.pctMax = clampPct(pctMax.value);
    render();
  }
  q.addEventListener('input', updateFilters);
  status.addEventListener('change', updateFilters);
  sort.addEventListener('change', updateFilters);
  pctMin.addEventListener('change', updateFilters);
  pctMax.addEventListener('change', updateFilters);

  // Auswahl / Bulk
  document.getElementById('selectAllBtn').addEventListener('click', ()=>{
    selected.clear();
    applyFilters(state.projects).forEach(p=>selected.add(p.id));
    render();
  });
  document.getElementById('clearSelBtn').addEventListener('click', ()=>{ selected.clear(); render(); });

  // Alle Projekte ausklappen / zuklappen
  const expandAllBtn  = document.getElementById('expandAllBtn');
  const collapseAllBtn = document.getElementById('collapseAllBtn');
  if(expandAllBtn) expandAllBtn.addEventListener('click', () => {
    pushHistory();
    (state.projects || []).forEach(p => { p.collapsed = false; });
    setDirty(true);
    render();
  });
  if(collapseAllBtn) collapseAllBtn.addEventListener('click', () => {
    pushHistory();
    (state.projects || []).forEach(p => { p.collapsed = true; });
    setDirty(true);
    render();
  });
  document.getElementById('bulkAction').addEventListener('change', e=>{
    document.getElementById('bulkTarget').style.display = e.target.value==='move' ? 'inline-block' : 'none';
  });
  document.getElementById('bulkGo').addEventListener('click', ()=>{
    const action = document.getElementById('bulkAction').value;
    if(!action){ alert('Bitte Aktion wählen.'); return; }
    if(selected.size===0){ alert('Keine Projekte ausgewählt.'); return; }
    const ids = [...selected];
    if(action==='delete'){
      if(confirm('Ausgewählte Projekte in den Papierkorb verschieben?')){
        pushHistory();
        state.trash = state.trash || [];
        ids.forEach(id=>{
          const p = state.projects.find(x=>x.id===id);
          if(p) state.trash.unshift({...p, deletedAt: new Date().toISOString()});
        });
        state.projects = state.projects.filter(x=>!selected.has(x.id));
        if(state.order) state.order = state.order.filter(id=>!selected.has(id));
        if(state.orderByTab && typeof state.orderByTab === 'object'){
          Object.keys(state.orderByTab).forEach(key => {
            const arr = state.orderByTab[key];
            if(Array.isArray(arr)) state.orderByTab[key] = arr.filter(id => !selected.has(id));
          });
          state.orderByTab['Alle'] = Array.isArray(state.order) ? state.order.slice() : [];
        }
        selected.clear(); setDirty(true); render();
      }
    }else if(action==='move'){
      const target = document.getElementById('bulkTarget').value || 'Alle';
      pushHistory();
      ids.forEach(id=>{ const p = state.projects.find(x=>x.id===id); if(p) p.tab = target; });
      selected.clear(); setDirty(true); render();
    }else if(action==='export_csv'){
      exportCSV(state.projects.filter(p=>ids.includes(p.id)),'projekte_auswahl.csv');
    }else if(action==='export_ics'){
      exportICS(state.projects.filter(p=>ids.includes(p.id)),'projekte_auswahl.ics');
    }
  });

  // Papierkorb
  const trashDlg = document.getElementById('trashDlg'),
        trashList = document.getElementById('trashList');
  document.getElementById('trashOpenBtn').addEventListener('click', ()=>{ renderTrash(); trashDlg.showModal(); });
  document.getElementById('trashClose').addEventListener('click', ()=> trashDlg.close());
  document.getElementById('trashEmpty').addEventListener('click', ()=>{
    if(confirm('Papierkorb wirklich endgültig leeren?')){
      state.trash = []; setDirty(true); renderTrash();
    }
  });
  function renderTrash(){
    trashList.innerHTML = '';
    const items = state.trash || [];
    if(!items.length){
      const p=document.createElement('p'); p.textContent='Papierkorb ist leer'; p.style.color='var(--muted)';
      trashList.appendChild(p); return;
    }
    items.forEach((it,i)=>{
      const row=document.createElement('div');
      row.style.cssText='display:flex;justify-content:space-between;gap:10px;border:1px solid var(--border);border-radius:12px;padding:10px 12px;margin-bottom:10px;background:var(--chip)';
      const left=document.createElement('div'); left.textContent=`${it.number||'—'} · ${it.name||'Ohne Titel'} · gelöscht ${new Date(it.deletedAt).toLocaleString()}`;
      const right=document.createElement('div'); right.style.display='flex'; right.style.gap='8px';
      const restore=document.createElement('button'); restore.className='btn'; restore.textContent='Wiederherstellen';
      restore.addEventListener('click',()=>{
        pushHistory(); state.projects.unshift({...it}); state.trash.splice(i,1); setDirty(true); render(); renderTrash();
      });
      const drop=document.createElement('button'); drop.className='btn'; drop.textContent='Endgültig löschen';
      drop.addEventListener('click',()=>{
        if(confirm('Endgültig löschen?')){ state.trash.splice(i,1); setDirty(true); renderTrash(); }
      });
      right.appendChild(restore); right.appendChild(drop); row.appendChild(left); row.appendChild(right); trashList.appendChild(row);
    });
  }

  // Ansicht umschalten
  document.getElementById('viewTable').addEventListener('click', ()=>{ state.view='table'; render(); });
  document.getElementById('viewKanban').addEventListener('click', ()=>{ state.view='kanban'; render(); });
  const viewTimelineBtn = document.getElementById('viewTimeline');
  if(viewTimelineBtn){
    viewTimelineBtn.addEventListener('click', () => {
      state.view = 'timeline';
      if(state.tabs?.includes(state.currentTab)) state.timelineTab = state.currentTab;
      else state.timelineTab = 'Alle';
      render();
    });
  }
  const viewDispoBtn = document.getElementById('viewDispo');
  if(viewDispoBtn){
    viewDispoBtn.addEventListener('click', () => { state.view = 'dispo'; render(); });
  }
  if(timelineTabSelect){
    timelineTabSelect.addEventListener('change', (e) => {
      state.timelineTab = e.target.value || 'Alle';
      setDirty(true);
      if(state.view === 'timeline'){ renderTimeline(); }
    });
  }
  if(timelineZoomInput){
    timelineZoomInput.addEventListener('input', () => {
      const idx = Math.max(0, Math.min(TIMELINE_ZOOMS.length - 1, parseInt(timelineZoomInput.value, 10) || 0));
      const next = TIMELINE_ZOOMS[idx]?.value || 'days';
      state.timelineZoom = next;
      updateTimelineZoomIndicator(next);
      setDirty(true);
      if(state.view === 'timeline'){ renderTimeline(); }
    });
  }

  if(dispoWeekInput){
    const info = parseWeekValue(dispoWeekInput.value);
    dispoWeekInput.value = formatWeekValue(info.year, info.week);
  }
  if(dispoAddWeekBtn){
    dispoAddWeekBtn.addEventListener('click', () => {
      const weekInfo = parseWeekValue(dispoWeekInput ? dispoWeekInput.value : '');
      pushHistory();
      ensureDispo();
      const entry = {
        id: uid(),
        year: weekInfo.year,
        week: weekInfo.week,
        title: (dispoTitleInput?.value || '').trim(),
        notes: '',
        items: [],
        collapsed: false
      };
      state.dispo.unshift(entry);
      setDirty(true);
      if(dispoTitleInput) dispoTitleInput.value = '';
      const { start } = weekRange(entry.year, entry.week);
      dispoNavigator.year = entry.year;
      dispoNavigator.month = start.getUTCMonth();
      render();
    });
  }

  // Light/Dark Regler
  const modeToggle = document.getElementById('modeToggle');
  modeToggle.addEventListener('change', e=>{
    pushHistory();
    state.theme = e.target.checked ? 'light' : 'dark';
    setDirty(true); render();
  });

  // Titel bearbeiten + Placeholder für contenteditable
  const titleEl = document.getElementById('titleText');
  // CSS-Regel für Placeholder (falls noch nicht vorhanden)
 (function ensureCEPlaceholderRule(){
  if (!document.getElementById('ce-placeholder-rule')) {
    const st = document.createElement('style');
    st.id = 'ce-placeholder-rule';
    st.textContent = '.title [contenteditable]:empty::before{content:attr(data-placeholder); color:var(--muted);}';
    document.head.appendChild(st);
  }
})();
  titleEl.setAttribute('data-placeholder','Titel hier ändern …');
  titleEl.addEventListener('input', ()=>{
    pushHistory();
    state.title = (titleEl.textContent || '').trim();
  document.title = state.title || 'XY-To-Dos';   // ← Tab-Titel live setzen
  setDirty(true);
  });

  // Shortcuts
  document.addEventListener('keydown', e=>{
    if(e.ctrlKey && e.key.toLowerCase()==='s'){ e.preventDefault(); save(); }
    if(e.ctrlKey && e.key.toLowerCase()==='z'){ e.preventDefault(); if(e.shiftKey) redo(); else undo(); }
    if(e.ctrlKey && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
    if(e.ctrlKey && e.key.toLowerCase()==='p'){ /* Druck: Standard */ }
  });

  // Initiale Anzeige
  // Beim ersten Laden wird die komplette Anzeige aufgebaut (inkl. Filter, Tabelle, Kanban oder Timeline).
  applyTheme(); setTitle(); render();
</script>



</body></html>