<!DOCTYPE html>
<html lang="de"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Team SS</title>

<!-- Google Material Symbols (Icons) -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0">
<style>
  :root{
    --bg:#0f172a; --card:#0b1225; --muted:#94a3b8; --text:#e6eaf3;
    --accent:#7c3aed; --accent-2:#16a34a; --danger:#ef4444; --border:#1f2a44;
    --chip:#111b36; --progress:#16a34a; --hover:rgba(255,255,255,.06);
    --shadow:0 10px 24px rgba(0,0,0,.25); --row-sel:rgba(124,58,237,.18)
  }
  body.light{
    --bg:#f7fafc; --card:#ffffff; --muted:#475569; --text:#0f172a;
    --accent:#7c3aed; --accent-2:#16a34a; --danger:#b91c1c; --border:#e2e8f0;
    --chip:#f1f5f9; --progress:#16a34a; --hover:rgba(0,0,0,.04);
    --shadow:0 8px 18px rgba(2,6,23,.08); --row-sel:rgba(124,58,237,.14)
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font:15px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, Helvetica, Arial, sans-serif;
    color:var(--text); background:var(--bg)
  }

  /* Einheitliche Schrift für Formularelemente, damit Projekt‑Datum und Deadline identisch aussehen */
  input, select, button, textarea{
    font-family: inherit;
  }
  .container{max-width:1600px; margin:24px auto 120px; padding:0 20px}
.pathPreview{
  margin-top:8px; font-size:12px; color:var(--muted);
  cursor:pointer; text-decoration:underline dotted;
}
tr.collapsed .pathPreview{ display:none; } /* Vorschau im zugeklappten Zustand verstecken */


  /* Header */
  header{display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:14px}
  .title{font-weight:800; letter-spacing:.2px; font-size:28px; display:flex; align-items:center; gap:10px}
  .title [contenteditable]{padding:4px 8px; border-radius:10px}
  .title [contenteditable]:focus{outline:2px solid #334155; background:#0c1630}
  body.light .title [contenteditable]:focus{background:#f8fafc}
  .dirty{width:10px; height:10px; border-radius:999px; background:#f59e0b; display:none}
  .dirty.on{display:inline-block}
  .sub{color:var(--muted); font-size:13px}
  .muted{color:var(--muted)}
  #fileLocation{font-size:.9rem; opacity:.75; margin:.25rem 0}

  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border:1px solid var(--border); border-radius:18px; box-shadow:var(--shadow); overflow:hidden
  }

  /* Icon-Buttons (Nur Icons) */
  .actions-right{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .iconbtn{
    --bg1:rgba(255,255,255,.06); --bg2:rgba(255,255,255,.02);
    position:relative; display:inline-flex; align-items:center; justify-content:center;
    width:40px; height:40px; border-radius:12px; border:1px solid var(--border);
    background:linear-gradient(180deg,var(--bg1),var(--bg2)); box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
    cursor:pointer
  }
  .iconbtn:hover{background:var(--hover)}
  .ms{
  font-family: "Material Symbols Rounded";
  font-style: normal;
  font-weight: 400;
  font-size: 22px;      /* Icon-Größe */
  line-height: 1;
  display: inline-block;
  vertical-align: middle;
  font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
}
  .ic-save{color:#22c55e}
  .ic-print{color:#8b5cf6}
  .ic-undo{color:#f59e0b}
  .ic-redo{color:#06b6d4}
  .ic-backup{color:#0ea5e9}
  .ic-restore{color:#38bdf8}
  .ic-trash{color:#f97316}

  /* Top-Bars */
  .barTop{
    --topbar-item-height:42px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    border-bottom:1px solid var(--border);
    background:rgba(255,255,255,.02);
    gap:16px;
    padding:10px 18px 12px;
  }
  .leftTop{display:flex; flex-direction:column; gap:6px; flex:1; min-width:0}
  .rightTop{display:flex; gap:8px; align-items:center; flex-shrink:0}

  /* Tabs */
  .tabs-container{display:flex; flex-direction:column; gap:6px; position:relative}
  .tabs-scroll{
    display:flex;
    align-items:center;
    padding:8px 14px;
    gap:8px;
    overflow-x:auto;
    overflow-y:visible;
    scroll-behavior:smooth;
    scrollbar-width:none;
    position:relative;
    min-height:var(--topbar-item-height);
  }
  .tabs-scroll::-webkit-scrollbar{display:none}
  .tabs{display:flex; align-items:stretch; gap:8px; min-width:fit-content}
  .tab{
    --tab-bg: var(--card);
    --tab-fg: var(--text);
    display:inline-flex; align-items:center; gap:6px; padding:0 16px;
    border:1px solid var(--border); border-radius:12px;
    background:var(--tab-bg); color:var(--tab-fg);
    cursor:pointer; user-select:none; white-space:nowrap; position:relative;
    transition:transform .15s ease, box-shadow .15s ease;
    min-height:var(--topbar-item-height);
    height:var(--topbar-item-height);
  }
  .tab:focus-visible{outline:2px solid var(--accent); outline-offset:2px}
  .tab.active{outline:2px solid var(--accent); outline-offset:0}
  .tab.dragging{opacity:.6}
  .tab.drop-hint{box-shadow:0 0 0 2px rgba(124,58,237,.5)}
  .tab .name{max-width:220px; overflow:hidden; text-overflow:ellipsis}
  .tab .tab-more{
    background:transparent; border:none; color:inherit; cursor:pointer;
    display:inline-flex; align-items:center; justify-content:center;
    padding:4px; border-radius:8px; min-width:24px; height:24px;
  }
  .tab .tab-more:hover{background:color-mix(in srgb, currentColor 18%, transparent)}
  .tab .tab-more:focus-visible{outline:2px solid var(--accent)}
  .tab.in-dropdown{width:100%; justify-content:space-between; border-radius:10px; padding:8px 14px; min-height:34px; height:auto}
  .tab.in-dropdown .name{max-width:180px}
  .tab.in-dropdown .tab-more{margin-left:auto}
  .tab.add, .tab-add{
    border-style:dashed; font-weight:700; background:rgba(124,58,237,.12);
    color:var(--accent); display:inline-flex; align-items:center; justify-content:center;
  }
  .tab-add{padding:6px 14px; border-radius:12px; border:1px dashed var(--accent); cursor:pointer}
  .tab.is-group{padding-right:36px}
  .tab.is-group{border-radius:8px}
  .tab.is-group .name{
    padding-right:4px;
    font-weight:700;
    opacity:.92;
  }
  .tab-group-toggle{position:absolute; inset-inline-end:6px; top:6px; width:22px; height:22px;
    border-radius:8px; display:flex; align-items:center; justify-content:center;
    border:none; background:transparent; color:inherit; cursor:pointer;
  }
  .tab-group-toggle:hover{background:color-mix(in srgb, currentColor 18%, transparent)}
  .tab-group-toggle:focus-visible{outline:2px solid var(--accent)}
  .tab-group{position:relative; flex-shrink:0}
  .tab-group.open{z-index:1400}
  .tab-dropdown{
    position:absolute; top:calc(100% + 6px); inset-inline-start:0;
    background:var(--card); border:1px solid var(--border); border-radius:14px;
    padding:8px 10px; display:none; flex-direction:column; gap:6px; min-width:210px;
    box-shadow:var(--shadow); z-index:1500; pointer-events:auto;
  }
  .tab-dropdown.show{display:flex}
  .tab-dropdown.floating{position:fixed; inset-inline-start:auto;}
  .tab-dropdown::before{
    content:''; position:absolute; top:-6px; inset-inline-start:20px;
    width:12px; height:12px; transform:rotate(45deg);
    background:var(--card); border-inline-start:1px solid var(--border);
    border-block-start:1px solid var(--border);
  }
  .tab-dropdown.floating::before{inset-inline-start:var(--arrow-left, 24px);}
  .tab-dropdown.above::before{
    top:auto; bottom:-6px; transform:rotate(225deg);
  }
  .tab-group-layer{position:fixed; inset:0; pointer-events:none; z-index:2000;}
  .tab-group-layer .tab-dropdown{pointer-events:auto;}
  .tab-dropdown .tab{display:flex; width:100%;}
  .tab-group .group-drop-zone{
    border:1px dashed var(--border);
    border-radius:10px;
    padding:8px;
    text-align:center;
    font-size:12px;
    color:var(--muted);
    display:none;
    align-items:center;
    line-height:1.4;
  }
  .tab-group .group-drop-zone.show{display:flex; align-items:center; justify-content:center;}
  .tab-group .group-drop-zone.drag-over{border-color:var(--accent); color:var(--accent)}
  .tabs-scrollbar{
    position:relative; height:6px; margin:4px 10px 0; background:rgba(148,163,184,.24);
    border-radius:999px; display:none; flex-shrink:0;
  }
  .tabs-scrollbar.show{display:block}
  .tabs-thumb{
    position:absolute; inset-block-start:0; inset-inline-start:0; height:100%;
    width:64px; border-radius:inherit; background:rgba(124,58,237,.85);
    box-shadow:0 2px 6px rgba(124,58,237,.35); cursor:pointer;
    transition:background .2s ease;
  }
  .tabs-thumb:active{background:rgba(124,58,237,.95)}
  body.light .tabs-thumb{background:rgba(124,58,237,.75)}

  .tab-menu{
    position:absolute; min-width:200px; background:var(--card); border:1px solid var(--border);
    border-radius:12px; padding:6px 0; box-shadow:var(--shadow); display:none; z-index:1800;
  }
  .tab-menu.show{display:block}
  .tab-menu button{
    width:100%; padding:9px 14px; background:transparent; border:none; text-align:left;
    color:var(--text); font-size:14px; cursor:pointer; display:flex; align-items:center; gap:8px;
    position:relative;
  }
  .tab-menu button:hover{background:color-mix(in srgb, var(--accent) 18%, transparent)}
  .tab-menu button:disabled{opacity:.45; cursor:not-allowed}
  .tab-menu button .submenu-arrow{margin-inline-start:auto; font-size:18px; opacity:.7}

  .tab-submenu{
    position:absolute; min-width:200px; background:var(--card); border:1px solid var(--border);
    border-radius:12px; padding:6px 0; box-shadow:var(--shadow); display:none; z-index:1850;
  }
  .tab-submenu.show{display:block}
  .tab-submenu button{
    width:100%; padding:8px 14px; background:transparent; border:none; text-align:left;
    color:var(--text); font-size:14px; cursor:pointer; display:flex; align-items:center; gap:8px;
  }
  .tab-submenu button:hover{background:color-mix(in srgb, var(--accent) 18%, transparent)}

  .color-palette{
    position:absolute; display:none; background:var(--card); border:1px solid var(--border);
    border-radius:16px; padding:14px; box-shadow:var(--shadow); z-index:1900; width:220px;
  }
  .color-palette.show{display:block}
  .color-grid{display:grid; grid-template-columns:repeat(6, 1fr); gap:8px; margin-bottom:12px}
  .color-swatch{
    width:28px; height:28px; border-radius:10px; border:2px solid rgba(255,255,255,.2);
    cursor:pointer; transition:transform .15s ease, border-color .2s ease;
  }
  .color-swatch:hover{transform:scale(1.08)}
  .color-swatch.selected{border-color:#fff}
  body.light .color-swatch{border-color:rgba(15,23,42,.1)}
  .color-palette .custom-color{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:12px;
    font-size:13px;
    color:var(--muted);
  }
  .color-palette .custom-color input[type="color"]{
    -webkit-appearance:none;
    appearance:none;
    width:34px;
    height:26px;
    border:1px solid var(--border);
    border-radius:8px;
    padding:0;
    background:none;
    cursor:pointer;
  }
  .color-palette .custom-color input[type="color"]::-webkit-color-swatch,
  .color-palette .custom-color input[type="color"]::-moz-color-swatch{
    border:none;
    border-radius:6px;
  }
  .color-palette .custom-color input[type="text"]{
    flex:1;
    min-width:100px;
    padding:6px 8px;
    border-radius:8px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
  }
  .color-palette .custom-color input[type="text"].invalid{border-color:var(--danger);}
  .color-palette .custom-color button{
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    border-radius:8px;
    padding:6px 10px;
    cursor:pointer;
  }
  .color-palette .custom-color button:hover{background:color-mix(in srgb, var(--accent) 14%, transparent)}
  .color-palette .reset-btn{
    width:100%; border:1px solid var(--border); background:var(--card); color:var(--text);
    padding:8px 12px; border-radius:10px; cursor:pointer; font-size:14px;
  }
  .color-palette .reset-btn:hover{background:color-mix(in srgb, var(--accent) 14%, transparent)}

  /* Ansicht Toggle */
  .viewToggle{display:flex; gap:6px; padding-right:10px}
  .viewToggle button{
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    border-radius:10px;
    padding:0 12px;
    cursor:pointer;
    min-height:var(--topbar-item-height);
    display:inline-flex;
    align-items:center;
    justify-content:center;
  }
  .viewToggle .viewBtn{gap:6px; font-weight:600;}
  .viewToggle .viewBtn .ms{font-size:18px;}
  .viewToggle .viewBtn.view-table{
    background:color-mix(in srgb, #38bdf8 18%, var(--card));
    border-color:color-mix(in srgb, #38bdf8 45%, var(--border));
  }
  .viewToggle .viewBtn.view-timeline{
    background:color-mix(in srgb, #a78bfa 18%, var(--card));
    border-color:color-mix(in srgb, #a78bfa 45%, var(--border));
  }
  .viewToggle .viewBtn.view-summary{
    background:color-mix(in srgb, #60a5fa 18%, var(--card));
    border-color:color-mix(in srgb, #60a5fa 45%, var(--border));
  }
  .viewToggle .viewBtn.view-assignees{
    background:color-mix(in srgb, #34d399 18%, var(--card));
    border-color:color-mix(in srgb, #34d399 45%, var(--border));
  }
  .viewToggle .viewBtn.view-dispo{
    background:color-mix(in srgb, #fbbf24 18%, var(--card));
    border-color:color-mix(in srgb, #fbbf24 45%, var(--border));
  }
  .viewToggle .on{outline:2px solid var(--accent)}

  /* Eingabe-Toolbar */
  .toolbar{
    display:grid;
    grid-template-columns: minmax(90px,.55fr) minmax(0,1.35fr) minmax(0,1fr) minmax(0,1.9fr) minmax(110px,.6fr) minmax(110px,.55fr) minmax(150px,.75fr);
    gap:10px; padding:14px; border-bottom:1px solid var(--border); background:rgba(255,255,255,.02);
    align-items:center;
  }
  .toolbar input[type="text"], .toolbar input[type="date"], .toolbar select{
    width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--border);
    background:#0c1630; color:var(--text); outline:none
  }
  body.light .toolbar input[type="text"], body.light .toolbar input[type="date"]{background:#ffffff}
  body.light .toolbar select{background:#ffffff}
  .toolbar .btnPrimary{justify-self:stretch; align-self:stretch; display:flex; align-items:center; justify-content:center;}
  .toolbar .todoField{display:flex; flex-wrap:wrap; gap:6px; align-items:center}
  .toolbar .todoField input{flex:1 1 320px}
  .toolbar .todoField select{padding:6px 10px; border-radius:10px; border:1px solid var(--border); background:var(--card); color:var(--text)}
  body.light .toolbar .todoField select{background:#ffffff}
  .toolbar .tabSelect{min-width:110px;}
  .toolbar #inNr{max-width:130px; justify-self:start;}
  .toolbar #manageTeamBtn{padding:8px 10px; font-size:13px;}
  .btnPrimary{
    border:none; padding:10px 16px; border-radius:12px; color:#fff; cursor:pointer;
    background:linear-gradient(135deg, var(--accent), #4f46e5);
    justify-self:stretch;
    white-space:nowrap;
  }
  .btn{border:1px solid var(--border); background:var(--card); color:var(--text); border-radius:10px; padding:9px 12px; cursor:pointer; transition:color .2s, border-color .2s, background .2s}
  .barTop .btn{
    min-height:var(--topbar-item-height);
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:0 14px;
  }
  .btn.on{border-color:var(--accent); color:var(--accent); background:color-mix(in srgb, var(--accent) 12%, transparent);}

  /* Filter-Bar */
  .filterbar{
    display:grid;
    grid-template-columns: minmax(220px, 1.6fr) minmax(150px, .8fr) minmax(210px, 1fr) minmax(150px, .9fr) repeat(4, max-content);
    gap:8px 12px;
    padding:12px 14px;
    border-bottom:1px solid var(--border);
    background:rgba(255,255,255,.02);
    align-items:center;
  }
  .filterbar input[type="text"], .filterbar select{
    width:100%;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid var(--border);
    background:#0c1630;
    color:var(--text);
  }
  body.light .filterbar input[type="text"],
  body.light .filterbar select{
    background:#ffffff;
  }
  .miniBtn{
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    border-radius:10px;
    padding:8px 12px;
    cursor:pointer;
    white-space:nowrap;
  }
  .assigneeFilterControl{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  #tableAssigneeFilter{min-width:110px; max-width:150px; padding:6px 8px; border-radius:10px; border:1px solid var(--border); background:var(--card); color:var(--text); max-height:150px; overflow-y:auto;}
  body.light #tableAssigneeFilter{background:#ffffff;}

  /* Bulkbar */
  .bulkbar{display:none; gap:10px; align-items:center; padding:10px 14px; border-bottom:1px solid var(--border); background:rgba(124,58,237,.08)}
  .bulkbar.show{display:flex}
  .bulkInfo{color:var(--muted)}
  .hidden{display:none!important}

  /* Tabelle */
  table{width:100%; border-collapse:separate; border-spacing:0; table-layout:fixed}
  colgroup col:nth-child(1){width:120px} /* Pfeil + Auswahl + Farbe */
  colgroup col:nth-child(2){width:10%}
  colgroup col:nth-child(3){width:22%}
  colgroup col:nth-child(4){width:42%} /* To‑Dos & Fortschritt */
  colgroup col:nth-child(5){width:24%} /* Notizen */
  colgroup col:nth-child(6){width:8%}  /* Pfad */
  thead th{
    text-align:left; font-weight:700; padding:12px 14px; color:var(--muted); background:rgba(255,255,255,.02);
    border-bottom:1px solid var(--border); user-select:none
  }
  tbody tr{border-bottom:none; position:relative}
  tbody tr::after{
    content:'';
    position:absolute;
    left:14px;
    right:14px;
    bottom:0;
    height:1px;
    background:rgba(148,163,184,.18);
    pointer-events:none;
  }
  tbody tr:last-child::after{background:transparent}
  #emptyRow .emptyRowCell{
    text-align:center;
    padding:28px 0;
    color:var(--muted);
    font-size:14px;
  }
  body.light tbody tr::after{background:rgba(148,163,184,.28)}
  td{vertical-align:top; padding:12px 14px; overflow:visible}
  td:nth-child(5){overflow:visible}
  td:nth-child(5) .todoCol{min-width:0; overflow:hidden}
  td:nth-child(5) .todoItem{max-width:100%; overflow:hidden; text-overflow:ellipsis; overflow-wrap:anywhere; word-break:break-word}
  td .editable{min-width:60px; padding:8px 10px; border:1px solid transparent; border-radius:10px}
  td .editable:focus{outline:none; border-color:#334155; background:#0c1630}
  body.light td .editable:focus{background:#f8fafc}
  .dateInput{width:100%; background:#0c1630; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:8px 10px}
  /* Einheitliche Schrift und kleinere Datumsanzeige */
  .dateInput, input[type="date"]{
    /* Gleiche Schriftart und kleinere Schriftgröße für alle Datumsfelder (Projektdatum, Deadlines) */
    font-family: inherit;
    font-size:12px;
  }
  body.light .dateInput{background:#ffffff}
  .row-selected{background:var(--row-sel)}
  tr{--pcolor: transparent}
  tr.colored{background:linear-gradient(90deg, color-mix(in srgb, var(--pcolor) 15%, transparent), transparent)}

/* Auswahl soll die Projektfarbe komplett überdecken */
tbody tr.row-selected{
  --pcolor: transparent;                 /* evtl. gesetzte Zeilenfarbe neutralisieren */
  background: var(--row-sel) !important; /* Auswahlfarbe hat Vorrang */
}
tbody tr.row-selected.colored{
  --pcolor: transparent;
  background: var(--row-sel) !important; /* auch falls die Zeile zusätzlich 'colored' hat */
}

  /* Linke Steuerzelle */
  .leftCell{display:flex; align-items:flex-start; gap:8px}
  .caret{cursor:pointer; background:transparent; border:1px solid var(--border); border-radius:10px; width:28px; height:28px; display:flex; align-items:center; justify-content:center}
  .selectCb{margin-top:2px}
  .colorBtn{width:18px; height:18px; border-radius:6px; border:1px solid var(--border); background:var(--pcolor, #7c3aed); cursor:pointer; position:relative}
  .colorBtn::after{content:""; position:absolute; inset:0; border-radius:6px; box-shadow:inset 0 1px 0 rgba(255,255,255,.3), 0 1px 3px rgba(0,0,0,.25) }

  /* Farb-Popover */
  .colorPopover{position:fixed; z-index:50; background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:var(--shadow); padding:12px; display:none}
  #repeatDlg form{display:flex; flex-direction:column; gap:12px; min-width:280px; padding:14px 18px; background:var(--card); border-radius:12px; border:1px solid var(--border);}
  #repeatDlg h3{margin:0 0 8px; font-size:18px;}
  #repeatDlg label{display:flex; flex-direction:column; gap:6px; font-size:14px; font-weight:600;}
  #repeatDlg input, #repeatDlg select{padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:var(--card); color:var(--text);}
  body.light #repeatDlg input, body.light #repeatDlg select{background:#ffffff;}
  .repeatWeekdays{display:none; flex-direction:column; gap:6px; font-size:13px;}
  .repeatWeekdays span{font-weight:600;}
  .repeatWeekdays .weekdayGrid{display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:6px;}
  .repeatWeekdays label{display:flex; align-items:center; gap:6px; font-weight:500;}
  .repeatWeekdays.show{display:flex;}
  #repeatDlg .dialogButtons{display:flex; justify-content:flex-end; gap:8px; margin-top:6px;}
  #calendarDlg form{display:flex; flex-direction:column; gap:14px; min-width:340px; padding:16px 20px; background:var(--card); border-radius:14px; border:1px solid var(--border);}
  #calendarDlg h3{margin:0; font-size:18px;}
  .calendarHint{margin:0; font-size:13px; color:var(--muted);}
  .calendarToolbar{display:flex; justify-content:space-between; align-items:center; gap:12px;}
  .calendarToolbarLeft{display:flex; gap:8px;}
  .calendarSelectionCount{font-size:13px; color:var(--muted);}
  .calendarList{max-height:360px; overflow:auto; display:flex; flex-direction:column; gap:10px; padding-right:4px;}
  .calendarGroup{border:1px solid var(--border); border-radius:12px; padding:10px 12px; display:flex; flex-direction:column; gap:8px; background:color-mix(in srgb, var(--chip) 90%, transparent);}
  body.light .calendarGroup{background:color-mix(in srgb, #ffffff 88%, transparent);}
  .calendarGroupHeader{font-weight:600; font-size:14px; display:flex; justify-content:space-between; align-items:center; gap:10px; color:var(--text);}
  .calendarGroupHeader span{font-size:12px; color:var(--muted); font-weight:400;}
  .calendarTodos{display:flex; flex-direction:column; gap:6px;}
  .calendarTodo{display:flex; gap:10px; align-items:flex-start; font-size:13px; color:var(--text);}
  .calendarTodo input{margin-top:2px;}
  .calendarTodoDetails{display:flex; flex-direction:column; gap:2px;}
  .calendarTodoSummary{font-weight:600;}
  .calendarTodoMeta{font-size:12px; color:var(--muted);}
  .calendarEmpty{margin:0; font-size:13px; color:var(--muted);}
  .colorRow{display:flex; gap:8px; margin:8px 0}
  .sw{width:20px; height:20px; border-radius:6px; border:1px solid var(--border); cursor:pointer}
  .popBtns{display:flex; gap:8px; justify-content:flex-end}

  /* Fortschritt + Todos (30% kompakter) + Reorder */
  .todoCol{display:flex; flex-direction:column; gap:8px}
  .progress{height:6px; border-radius:999px; background:#0c1630; border:1px solid #223055; overflow:hidden}
  body.light .progress{background:#e2e8f0; border-color:#cbd5e1}
  .progress > i{display:block; height:100%; width:0%}
  .todoHead{display:flex; align-items:center; gap:10px; margin-bottom:0; color:var(--muted); font-size:12px}
  .todoEmptyToggle{
    display:flex;
    align-items:center;
    gap:8px;
    font-size:12px;
    color:var(--muted);
  }
  .todoEmptyToggle input[type="checkbox"]{
    width:16px;
    height:16px;
    accent-color:var(--accent-2);
  }

  .todoList{display:flex; flex-direction:column; gap:6px}
  .todoBlock{display:flex; flex-direction:column; gap:6px;}
  .todoItem{
    display:grid;
    grid-template-columns:auto 1fr;
    gap:8px;
    align-items:flex-start;
    background:var(--chip);
    padding:6px 8px;
    border-radius:10px;
    border:1px solid #1b2643;
    font-size:12px;
    cursor:grab;
    position:relative;
  }
  body.light .todoItem{border-color:#e2e8f0}
  .todoItem.dragging{opacity:.6; outline:2px dashed #64748b}
  .todoItem input[type="checkbox"]{accent-color:var(--accent-2); margin-top:2px}
  .todoItem.done{opacity:.65}
  .todoMain{display:flex; flex-wrap:wrap; gap:8px; align-items:center; min-width:0}
  .todoText{min-height:16px; min-width:0; flex:1 1 160px; overflow:hidden; text-overflow:ellipsis; font-weight:600}
  .todoText.editable{cursor:text}
  .assigneeChip{background:var(--muted); color:var(--bg); border-radius:.75rem; padding:2px 10px; font-size:.85rem; line-height:1}
  body.light .assigneeChip{color:#f8fafc}
  .todoItem.done .assigneeChip{opacity:.7}
  .moreBtn{margin-left:auto; background:transparent; border:1px solid var(--border); border-radius:999px; padding:2px 10px; colo
r:var(--muted); cursor:pointer}
  .moreBtn:hover, .moreBtn:focus{color:var(--text); border-color:var(--accent)}
  .todoMore{grid-column:1 / span 2; display:flex; flex-direction:column; gap:10px; align-items:stretch; margin-left:24px}
  .todoMore.hidden{display:none}
  .repeatBadge{display:inline-flex; align-items:center; gap:4px; padding:2px 6px; border-radius:999px; background:color-mix(in srgb, var(--accent) 18%, transparent); color:var(--text); font-size:12px; font-weight:600; max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
  body.light .repeatBadge{background:color-mix(in srgb, var(--accent) 16%, transparent);}
  .repeatInfo{margin-top:6px; font-size:12px; color:var(--muted);}
  .repeatEditBtn{
    background:transparent;
    border:1px solid var(--border);
    border-radius:10px;
    padding:6px 12px;
    color:var(--accent);
    cursor:pointer;
  }
  .repeatEditBtn:hover,
  .repeatEditBtn:focus-visible{
    background:var(--hover);
    border-color:var(--accent);
    outline:none;
  }
  .todoDel{background:transparent; border:none; color:#475569; cursor:pointer; padding:2px 6px; border-radius:8px; opacity:.92; pointer-events:auto; transition:opacity .15s, color .15s}
  body.light .todoDel{color:#1f2937}
  .todoItem:hover .todoDel,
  .todoDel:focus{opacity:1}
  .todoItem .subAddBtn{
    width:28px;
    height:28px;
    border:none;
    background:transparent;
    color:#93a1c8;
    cursor:pointer;
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .todoItem .subAddBtn:hover{color:#cbd5e1; background:rgba(148,163,184,.12);}

  /* Mini‑Kalenderbutton in To‑Do‑Zeilen */
  .miniCal{
    width:24px;
    height:24px;
    background:transparent;
    border:none;
    color:#93a1c8;
    cursor:pointer;
    padding:0;
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .miniCal:hover{ color:#cbd5e1; }

  .badge{display:inline-flex; align-items:center; gap:6px; border-radius:999px; padding:2px 8px; font-size:11px; border:1px solid var(--border)}
  .b-red{background:#7f1d1d; color:#fecaca; border-color:#7f1d1d}
  .b-amber{background:#78350f; color:#fde68a; border-color:#78350f}
  .b-yellow{background:#3f3f0f; color:#fef08a; border-color:#3f3f0f}
  .b-green{background:#064e3b; color:#bbf7d0; border-color:#064e3b}
  /* Im eingeklappten Zustand nur die Notizen ausblenden – der Fortschrittsbalken bleibt sichtbar. */
  .collapsed .note{display:none}
  /* In collapsed rows, hide the detailed todo list and add area but keep summary and progress visible */
  /* In zusammengeklappten Projektzeilen werden detaillierte To‑Do‑Listen und das Eingabefeld ausgeblendet. */
  .collapsed .todoList,
  .collapsed .todoAdd{
    display:none;
  }
  .todoAdd{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
  .todoAdd .todoCustom{
    flex:1;
    padding:6px 10px;
    border-radius:8px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
  }
  .todoAdd .todoDueInput{
    width:140px;
    padding:6px 10px;
    border-radius:8px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
  }
  .todoAdd .todoCustom:focus{
    outline:2px solid var(--accent);
    outline-offset:1px;
  }
  .todoMetaRow{display:grid; grid-template-columns:minmax(0,1fr) max-content; align-items:center; gap:10px;}
  .todoMetaRow .todoAssignee{flex:1 1 160px; max-width:220px; min-width:0;}
  .todoMetaRow .todoAssigneeSelect{min-width:0;}
  .todoDueWrap{display:flex; align-items:center; gap:6px; min-width:0;}
  .todoDueWrap .dateInput{width:140px;}
  .todoMoreActions{display:flex; justify-content:flex-end; gap:10px;}
  .todoItem .todoAssignee,
  .todoAdd .todoAssignee,
  .subItem .todoAssignee{
    padding:4px 6px;
    border-radius:8px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    min-width:70px;
    max-width:180px;
  }
  body.light .todoItem .todoAssignee,
  body.light .todoAdd .todoAssignee,
  body.light .subItem .todoAssignee{background:#ffffff;}
  body.light .todoAdd .todoDueInput{background:#ffffff;}
  .subList{margin-left:36px; display:flex; flex-direction:column; gap:4px;}
  .subItem{
    display:grid;
    grid-template-columns: 16px minmax(0,1fr) minmax(86px,auto) 28px minmax(130px,auto) 24px;
    grid-auto-flow: column;
    align-items:center;
    gap:6px;
    background:color-mix(in srgb, var(--chip) 92%, transparent);
    padding:4px 6px;
    border-radius:10px;
    border:1px dashed #1f2c4a;
    font-size:11px;
  }
  body.light .subItem{border-color:#dbe3f0; background:color-mix(in srgb, #ffffff 85%, transparent);}
  .subItem input[type="checkbox"]{accent-color:var(--accent-2);}
  .subItem.done{opacity:.65;}
  .subItem .todoAssignee{
    margin-left:0;
    padding:4px 6px;
    border-radius:8px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    min-width:70px;
    max-width:140px;
  }
  .dateInput--compact{width:82px; padding:6px 8px;}
  body.light .subItem .todoAssignee{background:#ffffff;}
  .collapsed .todoEmptyToggle{
    display:none;
  }
  /* Spezifischer: auch innerhalb der Tabelle sicherstellen, dass Listen und Eingabe bei collapsed‑Zeilen verborgen werden */
  tbody tr.collapsed .todoList,
  tbody tr.collapsed .todoAdd{
    display:none;
  }

  /* Collapsed rows: kleinere Höhe, Notizen und Editier-Icons ausblenden */
  tbody tr.collapsed > td{
    padding-top:6px;
    padding-bottom:6px;
  }
  .virtual-spacer td{padding:0 !important; border:none !important; background:transparent !important;}

  /* Hinweisleiste für bevorstehende Deadlines wurde entfernt */

  /* Timeline‑Ansicht */

  .summaryView {
    --summary-columns: 5;
    --summary-gap: 16px;
    --summary-edge-gap: 16px;
    display: none;
    padding: 18px;
    position: relative;
    min-height: 40px;
  }
  .summaryView.show {
    display: block;
  }
  .summaryCard {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 14px;
    box-shadow: var(--shadow);
    width: 100%;
    position: absolute;
    top: 0;
    left: 0;
    transition: top .2s ease;
  }
  .summaryCardHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1.1rem;
    margin-bottom: 8px;
  }
  .summaryCardStats {
    display: flex;
    gap: 10px;
    align-items: center;
    margin-bottom: 8px;
  }
  .summaryStat {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 2px;
  }
  .summaryStat .label {
    font-size: 0.8rem;
    color: var(--muted);
  }
  .summaryStat .value {
    font-size: 1.2rem;
    font-weight: bold;
  }
  .summaryDropdown {
    display: none;
    margin-top: 8px;
    border-top: 1px solid var(--border);
    padding-top: 8px;
    font-size: 0.9rem;
  }
  .summaryDropdown ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
    max-height: calc(15 * 40px);
    overflow-y: auto;
    padding-right: 4px;
  }
  .summaryDropdown li {
    margin: 0;
    padding: 8px 0;
  }
  .summaryDropdown li + li {
    border-top: 1px solid rgba(0,0,0,.35);
  }
  .summaryCardArrow {
    cursor: pointer;
    font-family: 'Material Symbols Rounded';
    user-select: none;
  }

  .summaryArrowTooltip {
    position: fixed;
    z-index: 2500;
    pointer-events: none;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    box-shadow: var(--shadow);
    color: var(--text);
    font-size: 12px;
    padding: 6px 8px;
    white-space: nowrap;
  }
  @media (max-width: 1400px){
    .summaryView{--summary-columns:4;}
  }
  @media (max-width: 1120px){
    .summaryView{--summary-columns:3;}
  }
  @media (max-width: 860px){
    .summaryView{--summary-columns:2;}
  }
  @media (max-width: 620px){
    .summaryView{--summary-columns:1;}
  }
  .csvMenuWrap{position:relative; display:inline-flex;}
  .csvMenu{position:absolute; top:calc(100% + 6px); right:0; min-width:150px; display:none; flex-direction:column; background:var(--card); border:1px solid var(--border); border-radius:10px; box-shadow:var(--shadow); overflow:hidden; z-index:1900;}
  .csvMenu.show{display:flex;}
  .csvMenu button{border:none; background:transparent; color:var(--text); text-align:left; padding:9px 12px; cursor:pointer;}
  .csvMenu button:hover{background:var(--hover);}
  .timelineShell{display:none; padding:14px 14px 22px;}
  .timelineShell.show{display:block}
  .timeline{
    --timeline-px-day:22px;
    --timeline-row-height:40px;
    --timeline-bar-height:14px;
    --timeline-label-width:220px;
    --timeline-grid-step:var(--timeline-px-day);
    padding:0;
    overflow-x:auto;
    overflow-y:auto;
    max-height:600px;
    scroll-behavior:smooth;
    position:relative;
  }
  /* Kopfzeile der Timeline: getrennte Zeilen für Monate und Tage */
  .timelineMonths,
  .timelineWeeks,
  .timelineDays{
    display:flex;
    position:relative;
    margin-left:var(--timeline-label-width);
    min-width:max-content;
    gap:0;
  }
  .timelineMonths{ margin-bottom:2px; }
  .timelineWeeks{ margin-bottom:2px; }
  .timeline-month{
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    color:var(--muted);
    border-left:1px solid var(--border);
    white-space:nowrap;
    height:20px;
    flex:0 0 auto;
    min-width:var(--timeline-px-day);
  }
  .timeline-month:first-child{ border-left:none; }
  .timeline-day{
    flex:0 0 var(--timeline-px-day);
    font-size:9px;
    color:var(--muted);
    text-align:center;
    border-left:1px solid var(--border);
    padding-top:2px;
    white-space:nowrap;
    min-width:var(--timeline-px-day);
  }
  .timeline-week{
    flex:0 0 auto;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
    color:var(--muted);
    border-left:1px solid var(--border);
    border-right:1px solid var(--border);
    min-width:calc(var(--timeline-px-day) * 7);
    height:22px;
    white-space:nowrap;
  }
  .timeline-week:first-child{border-left:none;}
  .timeline-week:last-child{border-right:none;}
  .timeline[data-zoom="weeks"] .timelineDays{display:none;}

  /* Popover für Datumsauswahl (benutzerdefinierter DatePicker) */
  .datePicker{
    position: fixed;
    background: var(--card);
    color: var(--fg);
    border: 1px solid var(--border);
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    padding: 6px;
    font-size: 12px;
    z-index: 10000;
    display:none;
    pointer-events:auto;
    width:236px;
    max-width:236px;
  }
  .datePicker.show{display:block;}
  .datePicker.above{transform:translateY(-4px);}
  .datePicker header{
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
    font-weight: 600;
  }
  .datePicker .navBtn{
    cursor: pointer;
    padding: 0 4px;
    user-select: none;
  }
  .datePicker table{
    border-collapse: collapse;
    width:100%;
    table-layout:fixed;
  }
  .datePicker th, .datePicker td{
    width: 24px;
    height: 22px;
    text-align: center;
    cursor: pointer;
  }
  .datePicker td.disabled{
    color: var(--muted);
    cursor: default;
  }
  .datePicker td:hover:not(.disabled){
    background: var(--chip);
  }
  .datePicker td.selected{
    background: var(--accent);
    color: #fff;
    border-radius: 50%;
  }
  .timeline-day:first-child{ border-left:none; }
  .timelineChart{
    position:relative;
    margin-left:var(--timeline-label-width);
    background-image:
      repeating-linear-gradient(to right, var(--border) 0, var(--border) 1px, transparent 1px, transparent var(--timeline-grid-step)),
      repeating-linear-gradient(to bottom, rgba(148,163,184,.18) 0, rgba(148,163,184,.18) 1px, transparent 1px, transparent var(--timeline-row-height));
    min-width:max-content;
  }
  .timeline-marker-layer{
    position:absolute;
    left:0;
    right:0;
    top:0;
    bottom:0;
    pointer-events:none;
  }
  .timeline-marker-layer .timeline-milestone{
    pointer-events:auto;
  }
  .timeline-milestone{
    position:absolute;
    width:10px;
    height:10px;
    top:calc((var(--timeline-row-height) - 10px)/2);
    border-radius:2px;
    background:var(--accent);
    transform:rotate(45deg);
    box-shadow:0 1px 3px rgba(15,23,42,.25);
  }
  .timeline-week-boundaries{position:absolute; inset:0; pointer-events:none;}
  .timeline-week-line{position:absolute; top:0; bottom:0; width:1px; background:rgba(148,163,184,.28);}
  body.light .timeline-week-line{background:rgba(148,163,184,.35);}
  .timelineControls{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:16px;
    margin-bottom:12px;
  }
  .timelineFilter{display:flex; flex-direction:column; gap:4px; min-width:180px;}
  .timelineFilter label{font-size:12px; color:var(--muted);}
  .timelineFilter select{
    padding:8px 10px;
    border-radius:10px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    min-height:44px;
  }
  #timelineAssigneeSelect{min-width:110px; max-height:150px; overflow-y:auto; padding:6px 8px; border-radius:10px; border:1px solid var(--border); background:var(--card); color:var(--text);}
  body.light #timelineAssigneeSelect{background:#ffffff;}
  #assigneeFilterSelect{min-width:140px; max-height:150px; overflow-y:auto; padding:6px 8px; border-radius:10px; border:1px solid var(--border); background:var(--card); color:var(--text);}
  body.light #assigneeFilterSelect{background:#ffffff;}
  body.light .timelineFilter select{background:#ffffff;}
  .timelineZoomWrap{display:flex; flex-direction:column; align-items:flex-end; gap:6px; min-width:220px;}
  .timelineZoomWrap span{color:var(--muted); font-size:12px;}
  .timelineZoomWrap input[type="range"]{width:200px; accent-color:var(--accent);}
  .timelineZoomLabels{display:flex; width:200px; justify-content:space-between; font-size:11px; color:var(--muted); gap:4px;}
  .timelineZoomLabels span{flex:1; text-align:center; transition:color .2s, font-weight .2s;}
  .timelineZoomLabels span.active{color:var(--text); font-weight:600;}

  /* Erlaube horizontales Scrollen in der Timeline, damit weit entfernte Deadlines erreichbar sind */
  #timelineView{
    overflow-x:auto;
    overflow-y:auto;
    padding-bottom:8px;
  }
  .timeline-row{
    position:absolute;
    left:0;
    right:0;
    height:var(--timeline-row-height);
  }
  .timeline-row::after{
    content:'';
    position:absolute;
    left:calc(var(--timeline-label-width) * -1);
    right:0;
    bottom:0;
    height:1px;
    background:rgba(148,163,184,.18);
    pointer-events:none;
  }
  body.light .timeline-row::after{background:rgba(148,163,184,.26)}
  .timeline-label{
    position:sticky;
    left:0;
    top:0;
    bottom:0;
    width:var(--timeline-label-width);
    margin-left:calc(var(--timeline-label-width) * -1);
    display:flex;
    align-items:center;
    justify-content:flex-start;
    white-space:nowrap;
    overflow:visible;
    font-size:13px;
    padding:10px 16px 10px 16px;
    background:none;
    z-index:3;
    border-right:1px solid var(--border);
    min-height:var(--timeline-row-height);
  }
  .timeline-label-text{
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    position:relative;
    z-index:2;
    max-width:100%;
    flex:1;
  }
  .timeline-label::before{
    content:'';
    position:absolute;
    inset:-6px -2px;
    background:rgba(15,23,42,.98);
    z-index:-1;
  }
  .timeline-label-bubble{
    position:absolute;
    left:16px;
    top:50%;
    transform:translateY(-50%);
    display:none;
    padding:10px 16px;
    align-items:center;
    line-height:1.4;
    background:rgba(15,23,42,.98);
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:var(--shadow);
    white-space:nowrap;
    pointer-events:none;
    z-index:5;
    max-width:calc(100vw - 60px);
    min-width:calc(var(--timeline-label-width) * 0.9);
  }
  .timeline-label:hover .timeline-label-bubble,
  .timeline-label:focus-within .timeline-label-bubble{
    display:inline-flex;
  }
  .timeline-label:hover .timeline-label-text,
  .timeline-label:focus-within .timeline-label-text{
    visibility:hidden;
  }
  body.light .timeline-label::before{
    background:rgba(255,255,255,.98);
  }
  body.light .timeline-label-bubble{
    background:rgba(255,255,255,.98);
  }
  .timeline-bar{
    position:absolute;
    height:var(--timeline-bar-height);
    border-radius:999px;
    top:calc((var(--timeline-row-height) - var(--timeline-bar-height))/2);
    /* Balkenfarbe wird im Script gesetzt (accent, danger oder muted) */
  }
  .timeline-row.overdue .timeline-label{color:var(--danger); font-weight:600;}
  .timeline-bar.overdue{
    background:linear-gradient(270deg, rgba(239,68,68,1) 0%, rgba(239,68,68,.82) 72%, rgba(239,68,68,.6) 100%) !important;
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0 12px;
    font-weight:700;
    letter-spacing:.3px;
    text-transform:uppercase;
  }
  .timeline-bar.overdue span{
    font-size:11px;
    white-space:nowrap;
  }
  .today-line{
    position:absolute;
    width:2px;
    background:var(--danger);
    top:0;
    bottom:0;
    z-index:5;
  }

  .note{min-height:180px; background:linear-gradient(180deg,#0c1630,#0a132a); border:1px dashed #314064; border-radius:12px; padding:10px 12px; outline:none}
  body.light .note{background:#ffffff; border-color:#e2e8f0}

  .folderWrap{display:flex; align-items:center; gap:8px}
  .folderInput{width:100%; background:#0c1630; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:8px 10px}
  body.light .folderInput{background:#ffffff}
  /* Floating Save */
  .fab{position:fixed; right:24px; bottom:24px; z-index:10}
  .toast{position:fixed; left:24px; bottom:24px; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; box-shadow:var(--shadow); opacity:0; transform:translateY(8px); transition:.25s}
  .toast.show{opacity:1; transform:translateY(0)}

  /* Bearbeiteransicht */
  .assigneeView{display:none; padding:18px; gap:16px; flex-direction:column;}
  .assigneeView.show{display:flex;}
  .assigneeFilterBar{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
  .assigneeFilterBar select{min-width:110px; max-width:200px; padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:var(--card); color:var(--text); max-height:150px; overflow-y:auto;}
  body.light .assigneeFilterBar select{background:#ffffff;}
  .assigneeProjects{display:flex; flex-direction:column; gap:16px;}
  .assigneeProjectBlock{border:1px solid var(--border); border-radius:14px; background:var(--card); padding:16px; display:flex; flex-direction:column; gap:12px;}
  body.light .assigneeProjectBlock{background:#ffffff;}
  .assigneeProjectHeading{font-weight:700; font-size:16px;}
  .assigneeTodoList{display:flex; flex-direction:column; gap:8px;}
  .assigneeTodoRow{position:relative; display:flex; align-items:flex-start; gap:12px; border:1px solid var(--border); border-radius:10px; background:var(--chip); padding:10px 12px;}
  .assigneeTodoRow.unacknowledged{border-color:#facc15; box-shadow:0 0 0 1px color-mix(in srgb, #facc15 45%, transparent);}
  .assigneeTodoRow.is-subtask{padding-left:24px;}
  .assigneeTodoRow input[type="checkbox"]{margin-top:2px;}
  .assigneeTodoBody{display:flex; flex-direction:column; gap:6px; font-size:13px; flex:1;}
  .assigneeTodoHeader{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
  .assigneeTodoTitle{font-weight:600; overflow-wrap:anywhere;}
  .assigneeTodoMeta{color:var(--muted); font-size:12px;}
  .assigneeTodoActions{display:flex; align-items:center; gap:8px;}
  .assigneeTodoRow.editing .assigneeTodoTitle,
  .assigneeTodoRow.editing .assigneeTodoMeta{display:none;}
  .assigneeTodoEdit{display:none; flex-direction:column; gap:8px;}
  .assigneeTodoRow.editing .assigneeTodoEdit{display:flex;}
  .assigneeTodoEdit input[type="text"],
  .assigneeTodoEdit input[type="date"]{
    padding:8px 10px;
    border-radius:10px;
    border:1px solid var(--border);
    background:#0c1630;
    color:var(--text);
  }
  body.light .assigneeTodoEdit input[type="text"],
  body.light .assigneeTodoEdit input[type="date"]{background:#ffffff;}
  .assigneeTodoEditActions{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
  .assigneeEditBtn .ms{font-size:18px;}
  .ackIndicator{width:10px; height:10px; border-radius:999px; background:#facc15; box-shadow:0 0 8px rgba(250,204,21,.35);}
  .ackIndicator.acknowledged{opacity:0; visibility:hidden;}
  .assigneeEmpty{padding:24px; text-align:center; color:var(--muted); border:1px dashed var(--border); border-radius:14px; margin:24px auto;}

  /* Dispo */
  .dispo{display:none; padding:18px;}
  .dispo.show{display:block;}
    .dispoControls{display:flex; flex-wrap:wrap; align-items:flex-end; gap:12px; margin-bottom:18px;}
    .dispoField{display:flex; flex-direction:column; gap:6px; min-width:160px;}
    .dispoField label{font-size:12px; color:var(--muted);}
    .dispoField input, .dispoField textarea{padding:9px 12px; border-radius:12px; border:1px solid var(--border); background:#0c1630; color:var(--text);}
    body.light .dispoField input, body.light .dispoField textarea{background:#ffffff;}
    .dispoExplorer{display:flex; flex-direction:column; gap:14px;}
    .dispoBreadcrumbs{display:flex; align-items:center; flex-wrap:wrap; gap:6px; font-size:12px; color:var(--muted);}
    .dispoBreadcrumbs button{border:none; background:transparent; color:inherit; cursor:pointer; padding:4px 8px; border-radius:8px; font:inherit;}
    .dispoBreadcrumbs button:disabled{cursor:default; opacity:.85;}
    .dispoBreadcrumbs button:hover{background:var(--hover); color:var(--text);}
    .dispoBreadcrumbs button.active{background:var(--hover); color:var(--text); font-weight:600;}
    .dispoBreadcrumbs .sep{opacity:.6;}
    .dispoList{display:flex; flex-direction:column; gap:16px;}
    .dispoList.chooser{display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); gap:12px;}
    .dispoCard{border:1px solid var(--border); border-radius:14px; padding:14px 16px; background:var(--card); display:flex; flex-direction:column; gap:6px; cursor:pointer; transition:border-color .2s, transform .2s;}
    .dispoCard:hover{border-color:color-mix(in srgb, var(--accent) 55%, var(--border)); transform:translateY(-2px);}
    .dispoCard strong{font-size:16px;}
    .dispoCard span{color:var(--muted); font-size:12px;}
  .dispoEntry{border:1px solid var(--border); border-radius:16px; background:var(--card); overflow:hidden;}
  .dispoEntry summary{list-style:none; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 18px; cursor:pointer; font-weight:600;}
  .dispoEntry summary::-webkit-details-marker{display:none;}
  .dispoEntry[open] summary{border-bottom:1px solid var(--border);}
  .dispoSummaryTitle{display:flex; flex-direction:column; gap:4px;}
  .dispoRange{color:var(--muted); font-size:12px; font-weight:500;}
  .dispoSummaryMeta{color:var(--muted); font-size:12px; margin-left:auto;}
  .dispoSummaryActions{display:flex; gap:6px; align-items:center;}
  .dispoSummaryActions button{border:none; background:transparent; color:var(--muted); cursor:pointer; padding:4px 6px; border-radius:8px;}
  .dispoSummaryActions button:hover{color:var(--danger); background:var(--hover);}
  .dispoBody{padding:18px; display:flex; flex-direction:column; gap:16px;}
  .dispoNotes textarea{min-height:140px; resize:vertical;}
  .dispoItems{display:flex; flex-direction:column; gap:10px;}
  .dispoItemHead{display:grid; grid-template-columns:minmax(0,1fr) minmax(0,0.45fr) minmax(0,2fr) 120px 40px; gap:8px; font-size:12px; color:var(--muted); padding:0 4px;}
  .dispoItemRow{display:grid; grid-template-columns:minmax(0,1fr) minmax(0,0.45fr) minmax(0,2fr) 120px 40px; gap:8px; align-items:center;}
  .dispoItemRow input{padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:#0c1630; color:var(--text);}
  body.light .dispoItemRow input{background:#ffffff;}
  .dispoItemRow button{border:none; background:transparent; color:var(--muted); cursor:pointer; font-size:18px; line-height:1; padding:4px;}
  .dispoItemRow button:hover{color:var(--danger);}
  .dispoAssignBar .dispoProject{min-width:220px; flex:1 1 220px;}
  .dispoAssignBar .dispoAssignee{min-width:120px; max-width:160px; flex:0 1 140px;}
  .dispoAssignBar .dispoTodoText{flex:2 1 320px;}
  .dispoAssignBar .dispoTodoDue{min-width:130px; flex:0 0 130px;}
  .dispoAssignBar{display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end; padding-top:12px; margin-top:4px; border-top:1px solid var(--border);}

  @media (max-width: 1200px){
    .container{margin:16px auto 96px; padding:0 14px;}
    .barTop{flex-direction:column; align-items:flex-start;}
    .rightTop{flex-wrap:wrap; justify-content:flex-start;}
    .viewToggle{flex-wrap:wrap;}
    .toolbar{grid-template-columns:repeat(2, minmax(0,1fr));}
    .toolbar .todoField{grid-column:span 2;}
    .toolbar #manageTeamBtn{justify-self:start;}
    .filterbar{grid-template-columns:repeat(2, minmax(0,1fr));}
  }
  @media (max-width: 900px){
    .toolbar{grid-template-columns:1fr;}
    .filterbar{grid-template-columns:1fr;}
    .toolbar .todoField{grid-column:auto;}
  }
  .dispoAssignBar select,
  .dispoAssignBar input{padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:#0c1630; color:var(--text);}
  body.light .dispoAssignBar select,
  body.light .dispoAssignBar input{background:#ffffff;}
  .dispoAssignBar button{height:38px;}
  .dispoAssignSummary{margin-top:16px; padding:10px 14px; border:1px dashed var(--border); border-radius:12px; font-size:12px; color:var(--muted); background:var(--chip); display:flex; align-items:center; gap:8px;}
  .dispoAssignSummary strong{color:var(--text);}
  .dispoAssignSummary .badge{margin-left:auto;}
  .dispoEmpty{padding:28px 12px; text-align:center; color:var(--muted); border:1px dashed var(--border); border-radius:14px;}

  /* Print */
  @media print{
    @page view-table{ size:A4 portrait; margin:12mm; }
    @page view-assignees{ size:A4 portrait; margin:12mm; }
    @page view-dispo{ size:A4 portrait; margin:12mm; }
    @page view-timeline{ size:A4 landscape; margin:12mm; }
    body{ background:#ffffff; color:#0f172a; font-size:10px; line-height:1.35; }
    table{ table-layout:auto; }
    thead th, tbody td{ padding:6px 8px; font-size:10px; vertical-align:top; }
    body.view-table{ page:view-table; }
    body.view-assignees{ page:view-assignees; }
    body.view-dispo{ page:view-dispo; }
    body.view-timeline{ page:view-timeline; }
    header, .barTop, .viewToggle, .toolbar, .filterbar, .bulkbar, .footer, .fab, .actions-right,
    .caret, .leftCell .selectCb, .colorBtn, .todoDel, .miniCal { display:none !important; }
    .container{ margin:0; max-width:100%; padding:0 8mm; }
    body.view-table .timelineShell,
    body.view-table #assigneeView,
    body.view-table #dispoView{ display:none !important; }
    body.view-assignees #tableView,
    body.view-assignees .timelineShell,
    body.view-assignees #dispoView{ display:none !important; }
    body.view-dispo #tableView,
    body.view-dispo .timelineShell,
    body.view-dispo #assigneeView{ display:none !important; }
    body.view-timeline #tableView,
    body.view-timeline #assigneeView,
    body.view-timeline #dispoView{ display:none !important; }
    body.view-timeline .timelineShell{ display:block !important; padding:0 !important; }
    body.view-timeline #timelineView{ overflow:visible !important; padding-bottom:0 !important; }
    body.view-timeline .timelineControls{ display:none !important; }
    body.view-timeline .timeline{ --timeline-label-width:200px; --timeline-row-height:32px; --timeline-bar-height:10px; }
    body.view-timeline .timelineMonths,
    body.view-timeline .timelineWeeks,
    body.view-timeline .timelineDays{ display:flex !important; gap:0; }
    body.view-timeline .timelineChart{ margin-left:0; background-image:none; border:1px solid #d1d5db; border-radius:10px; padding:12px 16px 16px; }
    body.view-timeline .timeline-row{ position:relative !important; top:auto !important; height:auto !important; padding:10px 0; page-break-inside:avoid; break-inside:avoid; }
    body.view-timeline .timeline-row.project-start:not(:first-child){ break-before:page; }
    body.view-timeline .timeline-row::after{ left:0 !important; right:0 !important; }
    body.view-timeline .timeline-label{ position:relative; left:auto; top:auto; bottom:auto; margin:0 0 8px; width:auto; padding:0; background:none !important; border:none !important; font-size:11px; font-weight:700; color:#0f172a; }
    body.view-timeline .timeline-bar{ position:relative !important; top:auto !important; height:10px; margin-top:4px; border-radius:5px; box-shadow:none; }
    body.view-timeline .timeline-bar.overdue{ padding-right:8px; }
    body.view-timeline .timeline-bar.overdue span{ font-size:9px; }
    body.view-timeline .today-line{ display:none !important; }
    table{ width:100%; table-layout:auto; border-collapse:collapse; }
    thead th, tbody td{ white-space:normal; word-break:break-word; padding:4px 6px; font-size:11px; border:none !important; }
    tbody tr{ page-break-inside:avoid; border-bottom:1px solid #d1d5db; }
    tbody tr::after{ display:none !important; }
    tbody tr[data-id]{ break-inside:avoid; }
    .progress{ height:4px; }
    input[type="date"], input[type="text"], .folderInput{ border:none !important; padding:0 !important; background:none !important; color:#0f172a !important; width:auto !important; }
    .todoAdd{ display:none !important; }
    .note{ display:none !important; }
    body.print-detailed .note{ display:block !important; background:none !important; border:none !important; padding:0 !important; min-height:auto; }
    .todoList{ display:none !important; }
    body.print-detailed .todoList{ display:block !important; margin-top:6px; }
    body.print-detailed .todoItem{ display:flex; align-items:center; gap:6px; padding:2px 0; border:none; background:none; box-shadow:none; }
    body.print-detailed .todoItem input[type="checkbox"]{ display:none; }
    body.print-detailed .todoItem .todoText{ font-weight:600; }
    body.print-detailed .todoItem.done .todoText{ text-decoration:line-through; color:#475569; }
    body.print-detailed .todoMore{ display:none !important; }
    body.print-detailed .moreBtn{ display:none !important; }
    body.print-detailed .assigneeChip{ background:none; color:#0f172a; padding:0; }
    body.print-detailed .dateInput{ border:none !important; background:none !important; padding:0 !important; color:#0f172a !important; }
    td:nth-child(7), th:nth-child(7){ display:table-cell !important; }
    .pathPreview{ display:block !important; white-space:normal; position:relative; color:transparent; }
    .pathPreview::after{ content:attr(data-full); color:#0f172a; display:block; font-size:10px; font-weight:600; }
    body.print-detailed .pathPreview::after{ font-weight:700; }
    .dispoControls, .dispoSummaryActions{ display:none !important; }
  }


</style>
<style id="ce-placeholder-rule">.title [contenteditable]:empty::before{content:attr(data-placeholder); color:var(--muted);}</style></head>
<body class="light view-table">
  <!-- eingebetteter Zustand -->
  <script id="APP_STATE" type="application/json">{"title":"Team SS","projects":[{"id":"tagbx6v","number":"3004310","name":"LH - Wahlleistungsstation 8. OG","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Angebot NT01-OTE/Schadstoffsanierung bearbeiten","done":false,"due":"","assignee":"JHi","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Angebot NT01 finalisieren?","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"WMe","folder":"","color":"","collapsed":false},{"id":"g7pe1kq","number":"3003358","name":"Deponie Bornheim-Hersel","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Abstimmung mit Herrn Straubel über den Umfang unsererseits zum Jahresbericht","done":true,"due":"2026-01-16","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"Alle","folder":"","color":"","collapsed":false},{"id":"tcdo61i","number":"A0221","name":"Deponie Tummelfeld","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Unterlagen Kanalinspektion Fa. Breideneichen anfragen","done":true,"due":"2026-01-12","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Jahresbericht und Anlagen anfertigen","done":false,"due":"2026-03-31","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"Alle","folder":"","color":"","collapsed":false},{"id":"fywghce","number":"3010062","name":"Schadstofferkundung vor Betonsanierung Hildener Str.","date":"","deadline":"","showDeadline":false,"todos":[{"text":"1. Ortstermin, Sichtung + Beprobung Teil 1","done":true,"due":"2026-01-15","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Probenversand und Laboranalyse","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"2. Ortstermin abstimmen","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"BlM","folder":"","color":"","collapsed":false},{"id":"hlky0db","number":"3005374","name":"UKA VER - Treppenturm","date":"","deadline":"","showDeadline":false,"todos":[{"text":"A+S Plan erstellen","done":true,"due":"2025-12-03","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Gesprächstermin A+S Plan","done":true,"due":"2025-11-21","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Verteilen A+S plan","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Begleitung Sanierung","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"Alle","folder":"","color":"","collapsed":false},{"id":"hu7b2yj","number":"3004450","name":"Aerobe in situ Stabilisation","date":"","deadline":"","showDeadline":false,"todos":[{"text":"RP: Oliver Abstimmung Vorgehen","done":true,"due":"2025-11-12","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"Alle","folder":"","color":"","collapsed":true},{"id":"n0nzzz5","number":"3003687","name":"DoKa - Rückbau ZVA","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Terminplanung (Planung der Planung)","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Abstimmung Ansprechpartner für OT","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Vorbereitung der Probenahme","done":false,"due":"2026-01-12","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Probenahme ZVA DoKa","done":false,"due":"2026-01-15","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[{"text":"Support Kernbohrung","done":true,"due":"","assignee":"BlM","acknowledged":true}]},{"text":"Kostenschätzung","done":false,"due":"","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Terminierung OT Gelänebetreuung BW","done":false,"due":"","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"Alle","folder":"","color":"","collapsed":false},{"id":"jvqopv1","number":"3004266","name":"UKA Ambulanzaufzüge","date":"","deadline":"","showDeadline":false,"todos":[{"text":"SanKonz erstellen","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Ergebnisse MBS in Projektordner ablegen","done":true,"due":"2025-10-27","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Terminschiene klären Abgabetermin SK","done":true,"due":"2025-11-13","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"Alle","folder":"","color":"","collapsed":false},{"id":"rxr924s","number":"3004529","name":"DN GS Birkesdorf Fassadensanierung","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Nachfrage bei Firma Vlasman bezüglich Restarbeiten (WMe)","done":true,"due":"2025-10-15","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Kurzbewertung Beprobung","done":true,"due":"2025-10-17","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Örtliche Erkundung neuer Sachverhalt Buntsteinputz","done":true,"due":"","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Schlussrechnung Vlasman versenden","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Bauherrnabstimmung Umgang SR","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Einzelrechnung von Fa. Vlasman prüfen","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"WMe","folder":"","color":"","collapsed":false},{"id":"h29264e","number":"3002224","name":"LH Haupthaus","date":"","deadline":"","showDeadline":false,"todos":[{"text":"LV Versand (BlM)","done":true,"due":"2025-10-10","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Angebotsprüfung Vergabevorschlag","done":true,"due":"","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Bieterbesichtigung","done":true,"due":"","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Angebotseinholung Freimessung","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Schnittstellentermin abstimmen","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Schnittstellentermin durchführen","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Ankündigung beim SiGeKO","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Abfrage Gefährdungsbeurteilung","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"BlM","folder":"","color":"","collapsed":false},{"id":"66ceq5y","number":"3005201","name":"Rückbau Systemzentrale 4","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Einpflegen von Korrekturvorschlägen(BlM)","done":true,"due":"2025-10-22","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Ergänzung SanKonz um Brandschutzvorgaben","done":true,"due":"","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Weitere Begehungstermine mit Christoph Schneider und Füssenich abstimmen","done":true,"due":"","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"BlM","folder":"","color":"","collapsed":false},{"id":"tqwx1a4","number":"3005182","name":"Aurubis Gebäude 101","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Fotodoku (CVa)","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Versand Schimmelgutachten (CVa)","done":true,"due":"","assignee":"","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"dlvvdxu","number":"3004955","name":"Dalli Rückbau Seifenhaus","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Aktenvermerk (CVa)","done":true,"due":"2025-11-18","assignee":"CVa","repeat":{"freq":"weekly","interval":2,"start":"2025-11-17","end":"2025-12-22","until":"2025-12-22","days":[1]},"acknowledged":true,"subtasks":[]},{"text":"Baustellenmail (CVa)","done":true,"due":"2025-10-14","assignee":"CVa","repeat":{"freq":"weekly","interval":1,"start":"2025-11-11","end":"2025-12-22","until":"2025-12-22","days":[2]},"acknowledged":true,"subtasks":[]},{"text":"Abstimmung Statik Gerüstaufstellung (CVa)","done":true,"due":"2025-10-16","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Abstimmung Lohmer Pumpen (CVa)","done":true,"due":"2025-10-16","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Prüfung Nachträge","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Prüfung Nachtrag 05","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"OT Lohmer Dachflächen + Notentwässerung","done":true,"due":"2025-11-14","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Abstimmung WUF Absturzsicherung","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Baubesprechung mit anschl. Aktenvermerk","done":false,"due":"2026-01-16","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Klärung Umgang Übernahme Baustelleneinrichtung","done":false,"due":"","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"jsozik2","number":"3004604","name":"Aurubis Dachsanierung Gebäude 109","date":"","deadline":"","showDeadline":false,"todos":[],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"ed56c6e","number":"3004559","name":"UKA Angiographie","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Fachgutachterliche Begleitung (CVa)","done":false,"due":"","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"5zbee8o","number":"3004489","name":"SSK Düsseldorf - Sanierung TG","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Prüfung LV (CVa)","done":true,"due":"2025-10-15","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Versand LV (CVa)","done":true,"due":"2025-10-16","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Ortstermin und Begehung EnDeSa","done":true,"due":"2025-10-30","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Angebotsprüfung Vergabevorschlag","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Abstimmungstermin Vergabematrix CVa, JHi","done":true,"due":"2025-11-13","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Absage Bieter","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"d924wn9","number":"3004336","name":"UKA Spüllüftung C5 + B4","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Anpassung Konzept B4 (CVa)","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Kalkulation Aufwand Restarbeiten","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Terminabstimmung Frau Freise bzgl. Nachtrag","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"88a65dg","number":"3004141","name":"Otto Junker","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Abstimmung Schimmel (CVa)","done":true,"due":"2026-01-05","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Abfrage und Zusammenstellung Messergebnis (CVa)","done":true,"due":"2025-10-17","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"neues Angebot Messungen","done":false,"due":"","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"im8s6o1","number":"3003956","name":"Regionetz KMF","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Zusammenstellung Messergebnisse (CVa)","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Weiteres Vorgehen klären (CVa)","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"neues Angebot Messungen","done":false,"due":"","assignee":"CVa","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"x7ool21","number":"3003315","name":"LP DN Einlaufbauwerk","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Abfrage Status Raumluftmessung (CVa)","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"71mkt4q","number":"3003295","name":"BLB BSK-Tausch","date":"","deadline":"","showDeadline":false,"todos":[],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"s5fr3cn","number":"3001606","name":"RWTH IBAC","date":"","deadline":"","showDeadline":false,"todos":[],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"lnxl3kg","number":"3000077","name":"LVR Rückbau Haus 13+14","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Rechnungsprüfung 10. AR","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"CVa","folder":"","color":"","collapsed":true},{"id":"t342n54","number":"3004622","name":"LH - Bestands-ITS","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Angebot weitere Beprobung (WMe)","done":true,"due":"2025-10-15","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Klärung Beauftragung bei Christoph Dörre (DCH)","done":false,"due":"2026-01-16","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"WMe","folder":"","color":"","collapsed":false},{"id":"llbzm0o","number":"3004309","name":"LH - Wöchnerinnenstation","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Baustellenbegehung mit Firma (WMe)","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Planungs jourfixe (CVa)","done":true,"due":"2025-10-15","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Angebot Fa. STEG anschauen","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Angebotsprüfung und Vergabeempfehlung","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Bieterrückmeldung zu stockendem Vergabeverfahren","done":true,"due":"","assignee":"CVa","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Beauftragungsklärung","done":true,"due":"2026-01-05","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Klärung Vergabeverfahren/Vergabegesprächen mit LH","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"A+S Plan finalisieren","done":true,"due":"2025-12-03","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"WMe","folder":"","color":"","collapsed":false},{"id":"weovyir","number":"3003940-2","name":"UKA BSK, LV Freimessung","date":"2025-09-00","deadline":"","showDeadline":false,"todos":[{"text":"Vergabeempfehlung schreiben","done":true,"due":"","assignee":"","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Versand","done":true,"due":"","assignee":"","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Pflichtenliste für Freimesser erstellen","done":false,"due":"","assignee":"Har","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Abnahme SB","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Abstimmung zu neuer VDI mit GBA und Alexandrova nach in Kraft treten","done":false,"due":"","assignee":"BlM","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"Vorher Aleksandrova erreichen","tab":"Har","folder":"P:\\PLA\\300\\3940\\05_AVA, Baul\\BA01\\LV151_BA1_Freimessung","color":"","collapsed":false},{"id":"5zlr9e1","number":"3003940-1","name":"UKA Brandschutzklappentausch","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Abnahme PB519 B8 09:00 + Nachbearbeitung (WMe)","done":true,"due":"2025-10-16","assignee":"","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Freimessbeauftragung","done":false,"due":"","assignee":"","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Termin mit Freimesser für Mittwoch absprechen","done":true,"due":"2025-10-27","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[{"text":"Alex die Kontaktinfos schicken","done":true,"due":"2025-10-27","assignee":"Har","acknowledged":true}]},{"text":"BA1 - Mengenermittlung zusätzliche BSK","done":false,"due":"","assignee":"Har","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"BA1 - SanKonz: Neuer Index für neue Maßnahme","done":false,"due":"","assignee":"Har","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"Har","folder":"","color":"","collapsed":false},{"id":"fth7szo","number":"3003896","name":"Luisenhospital - Erweiterung CBG","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Analytik anschauen (Har)","done":true,"due":"","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"OTE Bericht (Har)","done":true,"due":"","assignee":"","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Rücksprache Jan zu Ergbnissen (Har)","done":true,"due":"","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Timo anrufen (Har)","done":true,"due":"","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Nachbeprobung CBG","done":true,"due":"2025-10-29","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[{"text":"E-Mail mit Ankündigung an Schröder","done":true,"due":"2025-10-27","assignee":"Har","acknowledged":true},{"text":"Proben abschicken","done":true,"due":"2025-10-30","assignee":"Har","acknowledged":true}]},{"text":"OTE und DTE Bericht schreiben","done":true,"due":"","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[{"text":"Fotodoku","done":true,"due":"","assignee":"Har","acknowledged":true},{"text":"Probenahmeplan","done":true,"due":"","assignee":"Har","acknowledged":true}]},{"text":"SanKonz vorbereiten","done":true,"due":"","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Besprechung mit Capmo Key-User","done":true,"due":"2025-11-17","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Termin Ergebnisbesprechung JHi, BlM","done":true,"due":"2025-11-14","assignee":"BlM","repeat":null,"acknowledged":true,"subtasks":[]}],"notes":"","tab":"Har","folder":"P:\\PLA\\300\\3896","color":"","collapsed":true},{"id":"ntlr180","number":"3005047","name":"Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","date":"","deadline":"","showDeadline":false,"todos":[{"text":"OTE Bericht schreiben (Har)","done":true,"due":"","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Termin mit Grünflächenamt zu Baumfällantrag (WMe)","done":true,"due":"2025-10-14","assignee":"","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Baustellenordnung d. SiGeKo an Bauherr (WMe)","done":true,"due":"2025-10-14","assignee":"","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Klärung des Deckblattes mit Projektsteuerer (WMe)","done":true,"due":"2025-10-15","assignee":"","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"LV Baufeldfreimachung VE1.2 (WMe)","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"LV Baumfällarbeiten","done":true,"due":"2025-10-29","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"OTE Bericht zur Korrektur abschicken","done":true,"due":"2025-10-27","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[{"text":"Melanie Korrekturlesen","done":true,"due":"2025-10-27","assignee":"WMe","acknowledged":true}]},{"text":"To-Dos absprechen","done":false,"due":"2025-11-03","assignee":"JHi","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Rückmeldung Fr. Adolphi zu Umsiedlung Gebäude am Turm","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Dateien in Conclude hochladen","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Beprobung Pförtnerhäuschen","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"AEV Konzept Zollamtshäuschen","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[{"text":"Entwurf erstellen","done":true,"due":"","assignee":"Har","acknowledged":true},{"text":"Einarbeitung der Kommentare","done":false,"due":"","assignee":"Har","acknowledged":false}]},{"text":"SanKonz IDR","done":true,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"AEV Pförtnerhäuschen","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"SanKonz Pförtnerhäuschen","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Abbruch-LV Zollamtshäuschen","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[{"text":"Abbruch und Sanierungs-LV entwerfen","done":false,"due":"","assignee":"Har","acknowledged":false}]},{"text":"Abbruch-LV Pförtnerhäuschen","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Neuer Termin Jan,Melanie,Mago","done":true,"due":"2025-11-19","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Mengenermittlung für LV VE1.2","done":true,"due":"2026-01-16","assignee":"WMe","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Baufeldfreimachungskonzept","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"LV Baufeldfreimachung VE1.5","done":false,"due":"","assignee":"WMe","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"","tab":"Har","folder":"P:\\PLA\\300\\5047\\05_Antraege_Berichte\\07_IDR","color":"","collapsed":false},{"id":"6k5vst8","number":"3005328","name":"UKA Systemzentrale Vorabreinigung","date":"","deadline":"","showDeadline":false,"todos":[{"text":"Sanierungskonzept schreiben (Har)","done":true,"due":"","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[{"text":"Sanierungskonzept überarbeiten","done":false,"due":"","assignee":"Har","acknowledged":false},{"text":"Antworten von Christoph einarbeiten","done":false,"due":"","assignee":"Har","acknowledged":false}]},{"text":"Dominik Konzept schicken (Har)","done":true,"due":"","assignee":"Har","repeat":null,"acknowledged":true,"subtasks":[]},{"text":"Christoph Bescheid geben (HAr)","done":true,"due":"2025-10-09","assignee":"","repeat":null,"acknowledged":false,"subtasks":[]},{"text":"Dominik ansprechen, bezgl. Planänderungen","done":false,"due":"","assignee":"Har","repeat":null,"acknowledged":false,"subtasks":[]}],"notes":"Christoph will wissen, wenn das Sanierungskonzept fertig ist.&nbsp;","tab":"Har","folder":"P:\\PLA\\300\\5328\\03_Plan","color":"","collapsed":false}],"filters":{"q":"3847","status":"all","sort":"manual","pctMin":0,"pctMax":100},"trash":[],"tabs":["Alle","WMe","CVa","UKA","BlM","Har"],"currentTab":"Alle","theme":"light","view":"table","timelineTab":"CVa","timelineZoom":"days","timelineAssignees":["CVa"],"kanbanTab":"Alle","assigneeFilter":[],"order":["tagbx6v","g7pe1kq","tcdo61i","fywghce","hlky0db","hu7b2yj","n0nzzz5","jvqopv1","tqwx1a4","dlvvdxu","jsozik2","ed56c6e","5zbee8o","d924wn9","88a65dg","im8s6o1","x7ool21","71mkt4q","s5fr3cn","lnxl3kg","t342n54","llbzm0o","ntlr180","weovyir","5zlr9e1","6k5vst8","fth7szo","rxr924s","h29264e","66ceq5y"],"orderByTab":{"3005047":[],"Alle":["tagbx6v","g7pe1kq","tcdo61i","fywghce","hlky0db","hu7b2yj","n0nzzz5","jvqopv1","tqwx1a4","dlvvdxu","jsozik2","ed56c6e","5zbee8o","d924wn9","88a65dg","im8s6o1","x7ool21","71mkt4q","s5fr3cn","lnxl3kg","t342n54","llbzm0o","ntlr180","weovyir","5zlr9e1","6k5vst8","fth7szo","rxr924s","h29264e","66ceq5y"],"UKA":[],"WMe":["tagbx6v","t342n54","llbzm0o","rxr924s"],"CVa":["tqwx1a4","dlvvdxu","jsozik2","ed56c6e","5zbee8o","d924wn9","88a65dg","im8s6o1","x7ool21","71mkt4q","s5fr3cn","lnxl3kg"],"Har":["weovyir","5zlr9e1","fth7szo","6k5vst8","ntlr180"],"BlM":["fywghce","h29264e","66ceq5y"]},"dispo":[{"id":"0ps71de","title":"","notes":"Mago: \n-To-Do Eingabefeld in Dispoansicht vergrößern\n-Nächstes To-Do Vorauswahl wie vorheriges Projekt und Bearbeiter  (Zeit sparen)\n-Evtl. mehr als einen Bearbeiter auswählen\n-Dispo-Ansicht To-Dos Nachbearbeitung = Auswirkung andere Ansichten\n-Zeile oben zusammenfassen\n-Kanban evtl. raus oder Drop-Down zur Auswahl der Ansicht\n-Auf Surface Bildschirm einpassen","year":2025,"month":null,"week":46,"items":[{"id":"cvttkoj","project":"3004529 · DN GS Birkesdorf Fassadensanierung","assignee":"BlM","todo":"Örtliche Erkundung neuer Sachverhalt Buntsteinputz","due":""},{"id":"e42bp53","project":"3004529 · DN GS Birkesdorf Fassadensanierung","assignee":"WMe","todo":"Schlussrechnung Vlasman versenden","due":""},{"id":"gdh4418","project":"3004529 · DN GS Birkesdorf Fassadensanierung","assignee":"WMe","todo":"Bauherrnabstimmung Umgang SR","due":""},{"id":"hm9u0qm","project":"3004309 · LH - Wöchnerinnenstation","assignee":"WMe","todo":"Angebotsprüfung und Vergabeempfehlung","due":""},{"id":"3aodhwi","project":"3004309 · LH - Wöchnerinnenstation","assignee":"CVa","todo":"Bieterrückmeldung zu stockendem Vergabeverfahren","due":""},{"id":"1rltusn","project":"3004309 · LH - Wöchnerinnenstation","assignee":"WMe","todo":"Beauftragungsklärung","due":"2026-01-05"},{"id":"822p1cy","project":"3004309 · LH - Wöchnerinnenstation","assignee":"WMe","todo":"Klärung Vergabeverfahren/Vergabegesprächen mit LH","due":""},{"id":"00fuz85","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"Rückmeldung Fr. Adolphi zu Umsiedlung Gebäude am Turm","due":""},{"id":"1hyoek7","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"Dateien in Conclude hochladen","due":""},{"id":"ulwcn3b","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"Beprobung Pförtnerhäuschen","due":""},{"id":"027ostv","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"AEV Konzept Zollamtshäuschen","due":""},{"id":"7obcvv7","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"SanKonz IDR","due":""},{"id":"h912fph","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"AEV Pförtnerhäuschen","due":""},{"id":"k2p9y2p","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"SanKonz Pförtnerhäuschen","due":""},{"id":"mj3gv9j","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"Abbruch-LV Zollamtshäuschen","due":""},{"id":"fbalhsj","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"Abbruch-LV Pförtnerhäuschen","due":""},{"id":"d9ehqwp","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"Har","todo":"Neuer Termin Jan,Melanie,Mago","due":"2025-11-19"},{"id":"6jh3tma","project":"3004622 · LH - Bestands-ITS","assignee":"WMe","todo":"Klärung Beauftragung bei Christoph Dörre (DCH)","due":""},{"id":"pnkmids","project":"3003847 · LüKa - Rückbau ZVA","assignee":"WMe","todo":"Terminplanung","due":""},{"id":"s5ddlg8","project":"3003847 · LüKa - Rückbau ZVA","assignee":"WMe","todo":"Abstimmung Ansprechpartner wg. Ortstermin","due":""},{"id":"b2zhg2u","project":"3003847 · LüKa - Rückbau ZVA","assignee":"WMe","todo":"Vorbereitung Probenahme","due":""},{"id":"5gvhpad","project":"3003847 · LüKa - Rückbau ZVA","assignee":"WMe","todo":"Kostenberechnung","due":""},{"id":"gfu0q0v","project":"3004955 · Dalli Rückbau Seifenhaus","assignee":"CVa","todo":"Prüfung Nachtrag 05","due":""},{"id":"a5pcs3z","project":"3004955 · Dalli Rückbau Seifenhaus","assignee":"CVa","todo":"OT Lohmer Dachflächen + Notentwässerung","due":"2025-11-14"},{"id":"ibb32te","project":"3004955 · Dalli Rückbau Seifenhaus","assignee":"CVa","todo":"Abstimmung WUF Absturzsicherung","due":""},{"id":"2xnhlxo","project":"3004489 · SSK Düsseldorf - Sanierung TG","assignee":"CVa","todo":"Angebotsprüfung Vergabevorschlag","due":""},{"id":"4uef9mo","project":"3004489 · SSK Düsseldorf - Sanierung TG","assignee":"CVa","todo":"Abstimmungstermin Vergabematrix CVa, JHi","due":"2025-11-13"},{"id":"3gv25g8","project":"3004336 · UKA Spüllüftung C5 + B4","assignee":"CVa","todo":"Kalkulation Aufwand Restarbeiten","due":""},{"id":"nbonijw","project":"3004336 · UKA Spüllüftung C5 + B4","assignee":"CVa","todo":"Terminabstimmung Frau Freise bzgl. Nachtrag","due":""},{"id":"ld1uz7g","project":"3000077 · LVR Rückbau Haus 13+14","assignee":"CVa","todo":"Rechnungsprüfung 10. AR","due":""},{"id":"nkxv8ie","project":"3003687 · DoKa - Rückbau ZVA","assignee":"CVa","todo":"Terminplanung (Planung der Planung)","due":""},{"id":"qe2dvzn","project":"3003687 · DoKa - Rückbau ZVA","assignee":"CVa","todo":"Abstimmung Ansprechpartner für OT","due":""},{"id":"ehg7447","project":"3003687 · DoKa - Rückbau ZVA","assignee":"CVa","todo":"Kostenberechnung","due":""},{"id":"f5mqpig","project":"3003687 · DoKa - Rückbau ZVA","assignee":"CVa","todo":"Vorbereitung der Probenahme","due":""},{"id":"wj059uz","project":"3003896 · Luisenhospital - Erweiterung CBG","assignee":"Har","todo":"Besprechung mit Capmo Key-User","due":"2025-11-17"},{"id":"d8ahz1q","project":"3003896 · Luisenhospital - Erweiterung CBG","assignee":"BlM","todo":"Termin Ergebnisbesprechung JHi, BlM","due":"2025-11-14"},{"id":"xib1njz","project":"3004450 · Aerobe in situ Stabilisation","assignee":"Har","todo":"RP: Oliver Abstimmung Vorgehen","due":"2025-11-12"},{"id":"i7v5idh","project":"3003940-2 · UKA BSK, LV Freimessung","assignee":"BlM","todo":"Abnahme SB","due":""},{"id":"vpg677j","project":"3004266 · UKA Ambulanzaufzüge","assignee":"BlM","todo":"Terminschiene klären Abgabetermin SK","due":"2025-11-13"},{"id":"xj6j2z4","project":"3002224 · LH Haupthaus","assignee":"BlM","todo":"Angebotsprüfung Vergabevorschlag","due":""},{"id":"zpfscnw","project":"3002224 · LH Haupthaus","assignee":"BlM","todo":"Bieterbesichtigung","due":""},{"id":"gr16qyn","project":"3005201 · Rückbau Systemzentrale 4","assignee":"BlM","todo":"Ergänzung SanKonz um Brandschutzvorgaben","due":""},{"id":"ygidzmu","project":"3005201 · Rückbau Systemzentrale 4","assignee":"BlM","todo":"Weitere Begehungstermine mit Christoph Schneider und Füssenich abstimmen","due":""},{"id":"wbvnr8v","project":"3004309 · LH - Wöchnerinnenstation","assignee":"BlM","todo":"A+S Plan finalisieren","due":"2025-12-03"},{"id":"39g6sif","project":"3005374 · UKA VER - Treppenturm","assignee":"BlM","todo":"A+S Plan erstellen","due":"2025-12-03"},{"id":"hsawkc4","project":"3005374 · UKA VER - Treppenturm","assignee":"BlM","todo":"Gesprächstermin A+S Plan","due":"2025-11-21"}]},{"id":"dg5zyp1","title":"","notes":"4955 - Wiederholungstermin AV steht noch\n\n3940 Freimessungen:\n-Kontaktperson angeben\n-Tageszeit definieren\n\n3896:\nCBG geht in Stufe 2 und SanKonz wird bis 20.11.25 gefordert\nNach der Beprobung am 29.10 wird die OTE und die DTE in einen Bericht zusammengefasst","year":2025,"month":null,"week":44,"items":[{"id":"4r2ib5u","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"WMe","todo":"LV Baumfällarbeiten","due":"2025-10-29"},{"id":"qg6lsa3","project":"3004309 · LH - Wöchnerinnenstation","assignee":"WMe","todo":"Angebot Fa. STEG anschauen","due":""},{"id":"jmlb29f","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"Har","todo":"OTE Bericht zur Korrektur abschicken","due":"2025-10-27"},{"id":"1qd7eri","project":"3003940-1 · UKA Brandschutzklappentausch","assignee":"Har","todo":"Termin mit Freimesser für Mittwoch absprechen","due":"2025-10-27"},{"id":"na51k5q","project":"3003896 · Luisenhospital - Erweiterung CBG","assignee":"Har","todo":"Nachbeprobung CBG","due":"2025-10-29"},{"id":"ai9ihwh","project":"3004955 · Dalli Rückbau Seifenhaus","assignee":"CVa","todo":"Prüfung Nachträge","due":""},{"id":"iv8gxtr","project":"3004489 · SSK Düsseldorf - Sanierung TG","assignee":"CVa","todo":"Ortstermin und Begehung EnDeSa","due":"2025-10-30"},{"id":"3uwm7m6","project":"3003940-2 · UKA BSK, LV Freimessung","assignee":"Har","todo":"Pflichtenliste für Freimesser erstellen","due":""},{"id":"bqtb78o","project":"3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung","assignee":"JHi","todo":"To-Dos absprechen","due":"2025-11-03"},{"id":"jy4k9dc","project":"3003896 · Luisenhospital - Erweiterung CBG","assignee":"Har","todo":"OTE und DTE Bericht schreiben","due":""},{"id":"hq0wcef","project":"3003896 · Luisenhospital - Erweiterung CBG","assignee":"BlM","todo":"SanKonz vorbereiten","due":""},{"id":"2chphcw","project":"3004266 · UKA Ambulanzaufzüge","assignee":"BlM","todo":"SanKonz erstellen","due":""},{"id":"l63es8k","project":"3004266 · UKA Ambulanzaufzüge","assignee":"Har","todo":"Ergebnisse MBS in Projektordner ablegen","due":"2025-10-27"}]},{"id":"eytkq47","title":"","notes":"-Wiederholungstermine einfügen\n-","year":2025,"month":null,"week":42,"items":[]},{"id":"7jkbqdd","title":"","notes":"","year":2025,"month":null,"week":23,"items":[]}],"tabGroups":[],"tabOrder":["tab:WMe","tab:CVa","tab:UKA","tab:BlM","tab:Har"],"tabMeta":{"UKA":{"groupId":"","color":""},"WMe":{"color":"","groupId":""},"CVa":{"color":"","groupId":""},"BlM":{"color":"","groupId":""},"Har":{"color":"","groupId":""},"Alle":{}},"team":["JHi","WMe","CVa","Har","BlM"]}</script>

  <script>
  // Fehlerdiagnose: Alle JavaScript-Fehler im Fenster auf der Seite anzeigen.
  window.onerror = function(msg, url, line, col, error){
    const div = document.createElement('pre');
    div.style.color = 'red';
    div.style.whiteSpace = 'pre-wrap';
    div.textContent = 'JS-Fehler: ' + msg + ' at ' + line + ':' + col;
    document.body.appendChild(div);
  };
  window.addEventListener('unhandledrejection', function(event){
    const div = document.createElement('pre');
    div.style.color = 'red';
    div.style.whiteSpace = 'pre-wrap';
    div.textContent = 'Unhandled promise rejection: ' + (event.reason && event.reason.message || event.reason);
    document.body.appendChild(div);
  });
  </script>

  <script>
  // Beim Laden der Datei die gespeicherten Autosave-Daten entfernen, um eine saubere Testumgebung zu gewährleisten.
  try{
    localStorage.removeItem('autosaveState');
  }catch(e){}
  </script>

  <!-- Autosave Toast -->
  <div class="toast show" id="toast">Gespeichert</div>

  <!-- Floating Save -->
  <div class="fab">
    <button class="iconbtn" id="saveFab" title="Speichern"><span class="ms ic-save">save</span></button>
  </div>

  <div class="container">
    <header>
      <div>
        <div class="title">
          <span class="dirty on" id="dirtyDot"></span>
          <span id="titleText" contenteditable="true" spellcheck="false" data-placeholder="Titel hier ändern …">Team SS</span>
        </div>
        <div class="sub"></div>
        <div id="fileLocation" class="muted">26-01-19_1_TeamSS.html</div>
      </div>
      <div class="actions-right" role="toolbar" aria-label="Aktionen">
        <!-- Nur Icons (ohne Text) -->
        <button class="iconbtn" id="saveBtn" title="Speichern"><span class="ms ic-save">save</span></button>
        <button class="iconbtn" id="printBtn" title="Drucken"><span class="ms ic-print">print</span></button>
        <button class="iconbtn" id="undoBtn" title="Rückgängig"><span class="ms ic-undo">undo</span></button>
        <button class="iconbtn" id="redoBtn" title="Wiederholen"><span class="ms ic-redo">redo</span></button>
        <button class="iconbtn" id="backupBtn" title="Backup speichern"><span class="ms ic-backup">backup</span></button>
        <button class="iconbtn" id="backupLoadBtn" title="Backup laden"><span class="ms ic-restore">settings_backup_restore</span></button>
        <!-- Farbmodus Switch -->
        <label class="iconbtn" title="Farbmodus umschalten" style="width:auto; gap:8px">
          <input id="modeToggle" type="checkbox" role="switch" aria-checked="true" style="accent-color:#64748b; width:18px; height:18px">
          <span class="ms">dark_mode</span>
        </label>
        <!-- Papierkorb (ständig verfügbar) -->
        <button class="iconbtn" id="trashOpenBtn" title="Papierkorb öffnen"><span class="ms ic-trash">delete</span></button>
      </div>
    </header>

    <div class="card">
      <!-- Tabs + Ansicht -->
      <div class="barTop">
        <div class="leftTop">
          <div class="tabs-container">
            <div class="tabs-scroll is-overflowing" id="tabsScroll">
              <div class="tabs" id="tabs"><div class="tab active" data-name="Alle" role="button" tabindex="0"><span class="name">Alle</span></div><div class="tab" data-name="WMe" role="button" tabindex="0" draggable="true"><span class="name">WMe</span><button type="button" class="tab-more"><span class="ms">more_vert</span></button></div><div class="tab" data-name="CVa" role="button" tabindex="0" draggable="true"><span class="name">CVa</span><button type="button" class="tab-more"><span class="ms">more_vert</span></button></div><div class="tab" data-name="UKA" role="button" tabindex="0" draggable="true"><span class="name">UKA</span><button type="button" class="tab-more"><span class="ms">more_vert</span></button></div><div class="tab" data-name="BlM" role="button" tabindex="0" draggable="true"><span class="name">BlM</span><button type="button" class="tab-more"><span class="ms">more_vert</span></button></div><div class="tab" data-name="Har" role="button" tabindex="0" draggable="true"><span class="name">Har</span><button type="button" class="tab-more"><span class="ms">more_vert</span></button></div><button type="button" class="tab-add" title="Tab oder Gruppe hinzufügen"><span class="ms">add</span></button></div>
            </div>
            <div class="tabs-scrollbar show" id="tabsScrollbar">
              <div class="tabs-thumb" id="tabsThumb" style="transform: translateX(0px); width: 89px;"></div>
            </div>
          </div>
        </div>
        <div class="rightTop">
          <div class="viewToggle">
            <button id="viewTable" class="viewBtn view-table on"><span class="ms">table_rows</span><span>Tabelle</span></button>
            <button id="viewSummary" class="viewBtn view-summary"><span class="ms">dashboard</span><span>Workload</span></button>
            <button id="viewAssignees" class="viewBtn view-assignees"><span class="ms">groups</span><span>Bearbeiter</span></button>
            <button id="viewDispo" class="viewBtn view-dispo"><span class="ms">event_note</span><span>Dispo</span></button>
            <button id="viewTimeline" class="viewBtn view-timeline"><span class="ms">timeline</span><span>Timeline</span></button>
          </div>
          <div class="csvMenuWrap">
            <button class="btn" id="csvMenuBtn" title="CSV Optionen">CSV</button>
            <div class="csvMenu" id="csvMenu">
              <button type="button" id="csvImportBtn" title="CSV importieren">Import</button>
              <button type="button" id="csvExportBtn" title="CSV exportieren">Export</button>
            </div>
          </div>
          <button class="btn" id="calendarExportBtn" title="Export für Kalender">Export für Kalender</button>
        </div>
      </div>

      <!-- Eingabezeile -->
      <div class="toolbar" id="addForm" style="display: grid;">
        <input id="inNr" type="text" placeholder="Projektnummer">
        <input id="inName" type="text" placeholder="Projektname">
        <input id="inFolder" type="text" placeholder="Pfad (file://, C:\\..., /mnt/...)">
        <div class="todoField">
          <input id="inTodos" type="text" placeholder="To-Dos mit ; trennen">
        </div>
        <select id="inTab" class="tabSelect"><option value="">Tab wählen</option><option value="Alle">Alle</option><option value="WMe">WMe</option><option value="CVa">CVa</option><option value="UKA">UKA</option><option value="BlM">BlM</option><option value="Har">Har</option></select>
        <button class="btn" id="manageTeamBtn" type="button">Team verwalten</button>
        <button class="btnPrimary" id="addBtn" type="button">Projekt hinzufügen</button>
      </div>

      <!-- Filter -->
      <div class="filterbar" style="display: grid;">
        <input id="q" type="text" placeholder="Suchen in Nr. und Name">
        <select id="status">
          <option value="all">Status Alle</option>
          <option value="open">Nur offen</option>
          <option value="done">Nur erledigt</option>
          <option value="partial">Teilweise erledigt</option>
        </select>
        <div class="assigneeFilterControl">
          <select id="tableAssigneeFilter" multiple="" title="Bearbeiter filtern" size="3"><option value="__all__">Alle Bearbeiter</option><option value="__unassigned__">Unzugewiesen</option><option value="JHi">JHi</option><option value="WMe">WMe</option><option value="CVa">CVa</option><option value="Har">Har</option><option value="BlM">BlM</option></select>
        </div>
        <select id="sort">
          <option value="date_desc">Sortieren Datum ↓</option>
          <option value="date_asc">Datum ↑</option>
          <option value="name_asc">Name A → Z</option>
          <option value="name_desc">Name Z → A</option>
          <option value="nr_asc">Nummer ↑</option>
          <option value="nr_desc">Nummer ↓</option>
          <option value="prog_desc">Fortschritt ↓</option>
          <option value="prog_asc">Fortschritt ↑</option>
          <option value="manual">Manuell (Drag &amp; Drop)</option>
        </select>
        <!-- Anzahl der Tage bis zum Fälligkeitsdatum, ab dem eine Warnung angezeigt wird -->
        <button class="miniBtn" id="selectAllBtn">Alle auswählen</button>
        <button class="miniBtn" id="clearSelBtn">Alle abwählen</button>
        <!-- Neue Buttons zum gleichzeitigen Auf- und Zuklappen aller Projekte -->
        <button class="miniBtn" id="expandAllBtn" title="Alle Projekte ausklappen">Alle ausklappen</button>
        <button class="miniBtn" id="collapseAllBtn" title="Alle Projekte zuklappen">Alle zuklappen</button>
      </div>

      <!-- Bulk Aktionen -->
      <div class="bulkbar" id="bulkbar">
        <span class="bulkInfo" id="selCount">0 ausgewählt</span>
        <select id="bulkAction">
          <option value="">Aktion wählen</option>
          <option value="delete">Löschen → Papierkorb</option>
          <option value="move">Verschieben in Tab</option>
          <option value="export_csv">Export CSV</option>
          <option value="export_ics">Export Kalender</option>
        </select>
        <select id="bulkTarget" style="display:none"><option value="Alle">Alle</option><option value="WMe">WMe</option><option value="CVa">CVa</option><option value="UKA">UKA</option><option value="BlM">BlM</option><option value="Har">Har</option></select>
        <button class="btnPrimary" id="bulkGo">Ausführen</button>
      </div>

      <!-- Hinweisleiste für kommende Deadlines entfernt -->

      <!-- Tabellenansicht -->
      <div id="tableView" style="display: block;">
        <table>
          <colgroup><col><col><col><col><col><col></colgroup>
          <thead>
            <tr>
              <th><!-- leer (Pfeil, Auswahl, Farbe) --></th>
              <th>Projektnummer</th>
              <th>Projektname</th>
              <th>To-Dos · Fortschritt</th>
              <th>Notizen</th>
              <th>Pfad</th>
            </tr>
          </thead>
          <tbody id="tbody"><tr id="emptyRow"><td colspan="7" class="emptyRowCell">Keine Projekte gefunden</td></tr></tbody>
        </table>
      </div>

      <!-- Timeline Ansicht -->
      <div id="timelineShell" class="timelineShell">
        <div class="timelineControls">
          <div class="timelineFilter">
            <label for="timelineTabSelect">Tab-Auswahl</label>
            <select id="timelineTabSelect"><option value="Alle">Alle</option><option value="WMe">WMe</option><option value="CVa">CVa</option><option value="UKA">UKA</option><option value="BlM">BlM</option><option value="Har">Har</option></select>
          </div>
          <div class="timelineFilter">
            <label for="timelineAssigneeSelect">Bearbeiter-Filter</label>
            <select id="timelineAssigneeSelect" multiple="" size="3"><option value="__all__">Alle Bearbeiter</option><option value="__unassigned__">Unzugewiesen</option><option value="JHi">JHi</option><option value="WMe">WMe</option><option value="CVa">CVa</option><option value="Har">Har</option><option value="BlM">BlM</option></select>
          </div>
          <div class="timelineZoomWrap">
            <span>Zoom</span>
            <input id="timelineZoom" type="range" min="0" max="2" step="1">
            <div class="timelineZoomLabels" id="timelineZoomLabels"><span>KW</span><span>Kompakt</span><span class="active">Tage</span></div>
          </div>
        </div>
        <div id="timelineView" class="timeline" data-zoom="days" data-taskcount="1" style="--timeline-px-day: 30px; --timeline-grid-step: 30px; --timeline-row-height: 40px; --timeline-bar-height: 14px;"><div class="timelineMonths"><div class="timeline-month" style="width: 90px;">Dez 25</div><div class="timeline-month" style="width: 930px;">Jan 26</div><div class="timeline-month" style="width: 240px;">Feb 26</div></div><div class="timelineWeeks"><div class="timeline-week" title="KW 01 / 2026" style="width: 210px;">KW 01</div><div class="timeline-week" title="KW 02 / 2026" style="width: 210px;">KW 02</div><div class="timeline-week" title="KW 03 / 2026" style="width: 210px;">KW 03</div><div class="timeline-week" title="KW 04 / 2026" style="width: 210px;">KW 04</div><div class="timeline-week" title="KW 05 / 2026" style="width: 210px;">KW 05</div><div class="timeline-week" title="KW 06 / 2026" style="width: 210px;">KW 06</div></div><div class="timelineDays"><div class="timeline-day" style="width: 30px;">29</div><div class="timeline-day" style="width: 30px;">30</div><div class="timeline-day" style="width: 30px;">31</div><div class="timeline-day" style="width: 30px;">1</div><div class="timeline-day" style="width: 30px;">2</div><div class="timeline-day" style="width: 30px;">3</div><div class="timeline-day" style="width: 30px;">4</div><div class="timeline-day" style="width: 30px;">5</div><div class="timeline-day" style="width: 30px;">6</div><div class="timeline-day" style="width: 30px;">7</div><div class="timeline-day" style="width: 30px;">8</div><div class="timeline-day" style="width: 30px;">9</div><div class="timeline-day" style="width: 30px;">10</div><div class="timeline-day" style="width: 30px;">11</div><div class="timeline-day" style="width: 30px;">12</div><div class="timeline-day" style="width: 30px;">13</div><div class="timeline-day" style="width: 30px;">14</div><div class="timeline-day" style="width: 30px;">15</div><div class="timeline-day" style="width: 30px;">16</div><div class="timeline-day" style="width: 30px;">17</div><div class="timeline-day" style="width: 30px;">18</div><div class="timeline-day" style="width: 30px;">19</div><div class="timeline-day" style="width: 30px;">20</div><div class="timeline-day" style="width: 30px;">21</div><div class="timeline-day" style="width: 30px;">22</div><div class="timeline-day" style="width: 30px;">23</div><div class="timeline-day" style="width: 30px;">24</div><div class="timeline-day" style="width: 30px;">25</div><div class="timeline-day" style="width: 30px;">26</div><div class="timeline-day" style="width: 30px;">27</div><div class="timeline-day" style="width: 30px;">28</div><div class="timeline-day" style="width: 30px;">29</div><div class="timeline-day" style="width: 30px;">30</div><div class="timeline-day" style="width: 30px;">31</div><div class="timeline-day" style="width: 30px;">1</div><div class="timeline-day" style="width: 30px;">2</div><div class="timeline-day" style="width: 30px;">3</div><div class="timeline-day" style="width: 30px;">4</div><div class="timeline-day" style="width: 30px;">5</div><div class="timeline-day" style="width: 30px;">6</div><div class="timeline-day" style="width: 30px;">7</div><div class="timeline-day" style="width: 30px;">8</div></div><div class="timelineChart" style="height: 40px; width: 1260px;"><div class="timeline-week-boundaries"><div class="timeline-week-line" style="left: 0px;"></div><div class="timeline-week-line" style="left: 210px;"></div><div class="timeline-week-line" style="left: 420px;"></div><div class="timeline-week-line" style="left: 630px;"></div><div class="timeline-week-line" style="left: 840px;"></div><div class="timeline-week-line" style="left: 1050px;"></div><div class="timeline-week-line" style="left: 1260px;"></div></div><div class="today-line" style="left: 285px; height: 40px;"></div><div class="timeline-row project-start" data-project-id="dlvvdxu" style="top: 0px;"><div class="timeline-label" title="3004955 · Dalli Rückbau Seifenhaus"><span class="timeline-label-text">3004955 – Baubesprechung mit anschl. Aktenvermerk</span><div class="timeline-label-bubble">3004955 – Baubesprechung mit anschl. Aktenvermerk</div></div><div class="timeline-bar" title="Baubesprechung mit anschl. Aktenvermerk
07.01.2026 → 16.01.2026 (10 Tage)
Noch 9 Tage" style="left: 285px; width: 267px; background: var(--accent);"></div></div></div></div>
      </div>

      <!-- Bearbeiter Ansicht -->
      <div id="assigneeView" class="assigneeView"><div class="assigneeFilterBar"><label for="assigneeFilterSelect">Bearbeiter filtern:</label><select id="assigneeFilterSelect" multiple="" size="3"><option value="__all__">Alle Bearbeiter</option><option value="__unassigned__">Unzugewiesen</option><option value="JHi">JHi</option><option value="WMe">WMe</option><option value="CVa">CVa</option><option value="Har">Har</option><option value="BlM">BlM</option></select><span style="font-size: 12px; color: var(--muted);">Mehrfachauswahl mit Strg/⌘</span></div><div class="assigneeProjects"><div class="assigneeProjectBlock"><div class="assigneeProjectHeading">3003847 · LüKa - Rückbau ZVA</div><div class="assigneeTodoList"><div class="assigneeTodoRow is-subtask unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">Probenahme LüKa → Unterstützung Probenahme</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div></div></div><div class="assigneeProjectBlock"><div class="assigneeProjectHeading">3003940-2 · UKA BSK, LV Freimessung</div><div class="assigneeTodoList"><div class="assigneeTodoRow unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">Pflichtenliste für Freimesser erstellen</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div></div></div><div class="assigneeProjectBlock"><div class="assigneeProjectHeading">3003940-1 · UKA Brandschutzklappentausch</div><div class="assigneeTodoList"><div class="assigneeTodoRow unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">BA1 - Mengenermittlung zusätzliche BSK</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div><div class="assigneeTodoRow unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">BA1 - SanKonz: Neuer Index für neue Maßnahme</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div></div></div><div class="assigneeProjectBlock"><div class="assigneeProjectHeading">3005047 · Landtag Dus - Leitungsumverlegung; Baufeldfreimachung</div><div class="assigneeTodoList"><div class="assigneeTodoRow is-subtask unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">Abbruch-LV Zollamtshäuschen → Abbruch und Sanierungs-LV entwerfen</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div><div class="assigneeTodoRow is-subtask unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">AEV Konzept Zollamtshäuschen → Einarbeitung der Kommentare</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div></div></div><div class="assigneeProjectBlock"><div class="assigneeProjectHeading">3005328 · UKA Systemzentrale Vorabreinigung</div><div class="assigneeTodoList"><div class="assigneeTodoRow is-subtask unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">Sanierungskonzept schreiben (Har) → Antworten von Christoph einarbeiten</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div><div class="assigneeTodoRow unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">Dominik ansprechen, bezgl. Planänderungen</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div><div class="assigneeTodoRow is-subtask unacknowledged"><input type="checkbox"><div class="assigneeTodoBody"><div class="assigneeTodoHeader"><span class="ackIndicator"></span><div class="assigneeTodoTitle">Sanierungskonzept schreiben (Har) → Sanierungskonzept überarbeiten</div><span class="assigneeChip">Har</span></div><div class="assigneeTodoMeta">Kein Fälligkeitsdatum</div></div><div class="assigneeTodoActions"><button type="button" class="miniBtn" title="Als gelesen bestätigen">Gesehen</button></div></div></div></div></div></div>

      <!-- Dispo Ansicht -->
      <div id="dispoView" class="dispo">
        <div class="dispoControls">
          <div class="dispoField">
            <label for="dispoWeekInput">Kalenderwoche</label>
            <input type="week" id="dispoWeekInput">
          </div>
          <div class="dispoField" style="min-width:220px;">
            <label for="dispoTitleInput">Titel / Fokus</label>
            <input type="text" id="dispoTitleInput" placeholder="z. B. Schwerpunkte der Woche">
          </div>
          <button class="btnPrimary" id="dispoAddWeek">Neue Woche erfassen</button>
          <button class="btn" id="dispoCsvImportBtn" title="Dispo aus CSV importieren">Dispo CSV import</button>
          <button class="btn" id="dispoCsvExportBtn" title="Dispo als CSV exportieren">Dispo CSV export</button>
        </div>
        <div class="dispoExplorer">
          <div id="dispoBreadcrumbs" class="dispoBreadcrumbs"><button type="button" class="active">Jahre</button></div>
          <div id="dispoList" class="dispoList chooser"><div class="dispoCard"><strong>2025</strong><span>4 Wochen in 3 Monaten</span></div></div>
          <div id="dispoAssignSummary" class="dispoAssignSummary">Noch keine To-Dos zugewiesen.</div>
        </div>
      </div>

      <!-- Workload-Karten Ansicht -->
      <div id="summaryView" class="summaryView"></div>

      <div class="footer" style="display:flex; justify-content:space-between; padding:12px 14px; color:var(--muted); font-size:12px; border-top:1px solid var(--border)">
        <div>Speichern schreibt alle Daten in diese HTML-Datei. Tastenkürzel: <span class="kbd">Strg+S</span>, <span class="kbd">Strg+Z</span>, <span class="kbd">Strg+Y</span></div>
        <div><span class="kbd">Strg+P</span> öffnet die kompakte Druckansicht</div>
      </div>
    </div>
  </div>

  <!-- Farb-Popover -->
  <div class="colorPopover" id="colorPop">
    <div style="font-weight:700; margin-bottom:6px">Projektfarbe</div>
    <input type="color" id="colorPicker" value="#7c3aed" style="width:100%; height:28px; border:1px solid var(--border); border-radius:10px; background:transparent">
    <div class="colorRow">
      <div class="sw" data-v="#7c3aed" style="background:#7c3aed"></div>
      <div class="sw" data-v="#06b6d4" style="background:#06b6d4"></div>
      <div class="sw" data-v="#22c55e" style="background:#22c55e"></div>
      <div class="sw" data-v="#f59e0b" style="background:#f59e0b"></div>
      <div class="sw" data-v="#ef4444" style="background:#ef4444"></div>
    </div>
    <div class="popBtns">
      <button class="btn" id="colorClear">Farbe entfernen</button>
      <button class="btn" id="colorCancel">Abbrechen</button>
      <button class="btnPrimary" id="colorOk">OK</button>
    </div>
  </div>

  <!-- Papierkorb-Dialog -->
  <dialog id="trashDlg">
    <div style="display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid var(--border)">
      <div>Papierkorb</div>
      <button class="btn" id="trashClose">Schließen</button>
    </div>
    <div style="padding:16px">
      <div class="trash-list" id="trashList" style="max-height:360px; overflow:auto"><p style="color: var(--muted);">Papierkorb ist leer</p></div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:10px">
        <button class="btn" id="trashEmpty">Papierkorb leeren</button>
      </div>
    </div>
  </dialog>

<dialog id="pathDlg">
  <div style="display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border)">
    <div>Voller Pfad</div>
    <button class="btn" onclick="document.getElementById('pathDlg').close()">Schließen</button>
  </div>
  <div style="padding:14px">
    <pre id="pathFull" style="white-space:pre-wrap;word-break:break-all;margin:0"></pre>
  </div>
</dialog>

<dialog id="repeatDlg">
  <form method="dialog" id="repeatForm">
    <h3>Wiederholung</h3>
    <label for="repeatFreq">Frequenz
      <select id="repeatFreq">
        <option value="">Keine</option>
        <option value="daily">Täglich</option>
        <option value="weekly">Wöchentlich</option>
        <option value="monthly">Monatlich</option>
        <option value="yearly">Jährlich</option>
      </select>
    </label>
    <label for="repeatInterval">Intervall <span id="repeatIntervalLabelText">(Wochen)</span>
      <input id="repeatInterval" type="number" min="1" value="1" placeholder="z. B. 2 für alle 2 Wochen" title="1 = jede Woche, 2 = alle 2 Wochen">
    </label>
    <label for="repeatStart">Serienstart
      <input id="repeatStart" type="date">
    </label>
    <div id="repeatWeekdayWrap" class="repeatWeekdays show">
      <span>Wochentage</span>
      <div class="weekdayGrid">
        <label><input type="checkbox" value="1">Mo</label>
        <label><input type="checkbox" value="2">Di</label>
        <label><input type="checkbox" value="3">Mi</label>
        <label><input type="checkbox" value="4">Do</label>
        <label><input type="checkbox" value="5">Fr</label>
        <label><input type="checkbox" value="6">Sa</label>
        <label><input type="checkbox" value="7">So</label>
      </div>
    </div>
    <label for="repeatCount">Maximale Wiederholungen (optional)
      <input id="repeatCount" type="number" min="1" placeholder="leer = unbegrenzt">
    </label>
    <label for="repeatEnd">Serienende (optional)
      <input id="repeatEnd" type="date">
    </label>
    <div class="dialogButtons">
      <button type="button" class="btn" id="repeatRemove" disabled="">Entfernen</button>
      <button type="button" class="btn" id="repeatCancel">Abbrechen</button>
      <button type="submit" class="btnPrimary" id="repeatApply">Übernehmen</button>
    </div>
  </form>
</dialog>

<dialog id="calendarDlg">
  <form method="dialog" id="calendarForm">
    <h3>To-Dos für Kalender-Export</h3>
    <p class="calendarHint">Wähle die To-Dos mit Fälligkeitsdatum aus, die in eine Kalenderdatei übernommen werden sollen.</p>
    <div class="calendarToolbar">
      <div class="calendarToolbarLeft">
        <button type="button" class="miniBtn" id="calendarSelectAll">Alle wählen</button>
        <button type="button" class="miniBtn" id="calendarSelectNone">Keine</button>
      </div>
      <span id="calendarSelectionCount" class="calendarSelectionCount">0 ausgewählt</span>
    </div>
    <div class="calendarList" id="calendarList"></div>
    <div class="dialogButtons">
      <button type="button" class="btn" id="calendarCancel">Abbrechen</button>
      <button type="submit" class="btnPrimary" id="calendarExportConfirm">Exportieren</button>
    </div>
  </form>
</dialog>


<script>
  // ===== Zustand =====
  const ASSIGNEE_UNASSIGNED = '__unassigned__'
  function createDefaultState(){
    return {
      title: 'XY-To-Dos',
      projects: [],
      filters: { q:'', status:'all', sort:'date_desc' },
      trash: [],
      tabs: ['Alle'],
      currentTab: 'Alle',
      theme: 'dark',
      view: 'table',
      timelineTab: 'Alle',
      timelineZoom: 'days',
      timelineAssignees: [],
      assigneeFilter: [],
      order: [],
      orderByTab: {},
      dispo: [],
      tabGroups: [],
      tabOrder: [],
      tabMeta: {},
      team: []
    }
  }
  const embedded = document.getElementById('APP_STATE').textContent
  let state = { ...createDefaultState(), ...JSON.parse(embedded || '{}') }

  const normalizeRepeatDays = (raw) => {
    if(!raw) return []
    let list = []
    if(Array.isArray(raw)) list = raw.slice()
    else if(typeof raw === 'string') list = raw.split(/[;,\s]+/).filter(Boolean)
    const map = {
      mo:1, montag:1, monday:1,
      di:2, dienstag:2, tuesday:2,
      mi:3, mittwoch:3, wednesday:3,
      do:4, donnerstag:4, thursday:4,
      fr:5, freitag:5, friday:5,
      sa:6, samstag:6, saturday:6,
      so:7, sonntag:7, sunday:7
    }
    const out = new Set()
    list.forEach(entry => {
      if(entry == null) return
      if(typeof entry === 'number' && Number.isFinite(entry)){
        const num = Math.floor(entry)
        if(num >= 1 && num <= 7) out.add(num)
        return
      }
      const str = String(entry).trim()
      if(!str) return
      const num = Number(str)
      if(Number.isFinite(num)){
        const value = Math.floor(num)
        if(value >= 1 && value <= 7) out.add(value)
        return
      }
      const key = str.toLowerCase()
      if(map[key]) out.add(map[key])
    })
    return Array.from(out).sort((a,b) => a - b)
  }

  const isoWeekday = (date) => {
    if(!(date instanceof Date) || Number.isNaN(date.getTime())) return null
    return ((date.getUTCDay() + 6) % 7) + 1
  }

  const normalizeRepeatSpec = (raw, ctx = {}) => {
    if(!raw || typeof raw !== 'object') return null
    const freq = typeof raw.freq === 'string' ? raw.freq.trim().toLowerCase() : ''
    if(!['daily','weekly','monthly','yearly'].includes(freq)) return null
    const intervalNum = Number(raw.interval)
    const interval = Number.isFinite(intervalNum) && intervalNum > 0 ? Math.floor(intervalNum) : 1
    const countNum = Number(raw.count)
    const count = Number.isFinite(countNum) && countNum > 0 ? Math.floor(countNum) : null
    const untilStr = typeof raw.until === 'string' ? raw.until.trim() : ''
    const until = untilStr && parseIsoDate(untilStr) ? untilStr : ''
    let dueDate = null
    if(ctx && ctx.dueDate){
      if(ctx.dueDate instanceof Date){
        dueDate = ctx.dueDate
      }else if(typeof ctx.dueDate === 'string'){
        dueDate = parseIsoDate(ctx.dueDate)
      }
    }
    const startStr = typeof raw.start === 'string' ? raw.start.trim() : ''
    let startDate = startStr ? (parseIsoDate(startStr) || parseGermanDate(startStr)) : null
    if(!startDate && dueDate) startDate = dueDate
    const endStr = typeof raw.end === 'string' ? raw.end.trim() : ''
    let endDate = endStr ? (parseIsoDate(endStr) || parseGermanDate(endStr)) : null
    if(!endDate && until){
      const parsedUntil = parseIsoDate(until)
      if(parsedUntil) endDate = parsedUntil
    }
    const defaultDay = startDate ? isoWeekday(startDate) : (dueDate ? isoWeekday(dueDate) : null)
    const spec = { freq, interval }
    if(count) spec.count = count
    if(startDate) spec.start = formatIsoDate(startDate)
    if(endDate){
      const isoEnd = formatIsoDate(endDate)
      spec.end = isoEnd
      spec.until = isoEnd
    }else if(until){
      spec.until = until
    }
    if(freq === 'weekly' || freq === 'monthly'){
      const cleaned = normalizeRepeatDays(raw.days)
      if(cleaned.length){
        spec.days = cleaned
      }else if(defaultDay){
        spec.days = [defaultDay]
      }
    }
    return spec
  }
  function applyLoadedState(raw, { markDirty = true, preserveFilters = true } = {}){
    if(!raw || typeof raw !== 'object') throw new Error('Ungültiger Zustand')
    let parsed
    try{
      parsed = JSON.parse(JSON.stringify(raw))
    }catch(err){
      throw new Error('Zustand konnte nicht interpretiert werden')
    }
    const defaults = createDefaultState()
    const next = { ...defaults, ...state, ...parsed }
    if(Array.isArray(parsed.projects)) next.projects = parsed.projects
    const parsedFilters = parsed.filters && typeof parsed.filters === 'object' ? parsed.filters : null
    if(parsedFilters){
      next.filters = preserveFilters
        ? parsedFilters
        : {
            ...defaults.filters,
            sort: typeof parsedFilters.sort === 'string' && parsedFilters.sort
              ? parsedFilters.sort
              : defaults.filters.sort
          }
    }else if(!preserveFilters){
      next.filters = { ...defaults.filters }
    }
    if(!preserveFilters){
      next.currentTab = typeof parsed.currentTab === 'string' && parsed.currentTab
        ? parsed.currentTab
        : defaults.currentTab
      next.timelineTab = typeof parsed.timelineTab === 'string' && parsed.timelineTab
        ? parsed.timelineTab
        : defaults.timelineTab
      next.timelineAssignees = []
      next.assigneeFilter = []
    }
    if(Array.isArray(parsed.tabs)) next.tabs = parsed.tabs
    if(Array.isArray(parsed.tabGroups)) next.tabGroups = parsed.tabGroups
    if(Array.isArray(parsed.tabOrder)) next.tabOrder = parsed.tabOrder
    if(parsed.tabMeta && typeof parsed.tabMeta === 'object') next.tabMeta = parsed.tabMeta
    if(Array.isArray(parsed.trash)) next.trash = parsed.trash
    if(parsed.orderByTab && typeof parsed.orderByTab === 'object') next.orderByTab = parsed.orderByTab
    if(Array.isArray(parsed.dispo)) next.dispo = parsed.dispo
    if(Array.isArray(parsed.order)) next.order = parsed.order
    state = next
    lastDispoAssignInfo = { count:0, label:'' }
    normalizeState()
    setDirty(!!markDirty)
    render()
  }
  function normalizeState(){
    if(!state || typeof state !== 'object') state = createDefaultState()
    const defaults = createDefaultState()

    if(!Array.isArray(state.team)) state.team = []
    else state.team = uniqueCaseInsensitive(state.team)
    const teamSet = new Set(state.team)
    if(!Array.isArray(state.timelineAssignees)) state.timelineAssignees = []
    else {
      const normalized = []
      const seen = new Set()
      state.timelineAssignees.forEach(value => {
        const raw = typeof value === 'string' ? value.trim() : ''
        if(!raw) return
        if(raw === ASSIGNEE_UNASSIGNED){
          if(!seen.has(ASSIGNEE_UNASSIGNED)){
            seen.add(ASSIGNEE_UNASSIGNED)
            normalized.push(ASSIGNEE_UNASSIGNED)
          }
          return
        }
        if(!teamSet.has(raw)) return
        const key = raw.toLowerCase()
        if(seen.has(key)) return
        seen.add(key)
        const original = state.team.find(name => name.toLowerCase() === key) || raw
        normalized.push(original)
      })
      state.timelineAssignees = normalized
    }
    if(!Array.isArray(state.assigneeFilter)) state.assigneeFilter = []
    else {
      const normalized = []
      const seen = new Set()
      state.assigneeFilter.forEach(value => {
        const raw = typeof value === 'string' ? value.trim() : ''
        if(!raw) return
        if(raw === ASSIGNEE_UNASSIGNED){
          if(!seen.has(ASSIGNEE_UNASSIGNED)){
            seen.add(ASSIGNEE_UNASSIGNED)
            normalized.push(ASSIGNEE_UNASSIGNED)
          }
          return
        }
        if(!teamSet.has(raw)) return
        const key = raw.toLowerCase()
        if(seen.has(key)) return
        seen.add(key)
        const original = state.team.find(name => name.toLowerCase() === key) || raw
        normalized.push(original)
      })
      state.assigneeFilter = normalized
    }

    if(!Array.isArray(state.projects)) state.projects = []
    else {
      const sanitizedProjects = []
      const seenIds = new Set()
      state.projects.forEach(raw => {
        if(!raw || typeof raw !== 'object') return
        const copy = {
          id: typeof raw.id === 'string' && raw.id.trim() ? raw.id.trim() : uid(),
          number: typeof raw.number === 'string' ? raw.number : String(raw.number ?? ''),
          name: typeof raw.name === 'string' ? raw.name : String(raw.name ?? ''),
          date: typeof raw.date === 'string' ? raw.date : '',
          deadline: typeof raw.deadline === 'string' ? raw.deadline : '',
          showDeadline: !!raw.showDeadline,
          todos: Array.isArray(raw.todos)
            ? raw.todos
                .filter(t => t && typeof t === 'object')
                .map(t => {
                  const sanitizeSubtask = sub => {
                    const subtask = {
                      text: typeof sub.text === 'string' ? sub.text : String(sub.text ?? ''),
                      done: !!sub.done,
                      due: typeof sub.due === 'string' ? sub.due : '',
                      assignee: '',
                      acknowledged: !!sub.acknowledged
                    }
                    if(subtask.due && !parseIsoDate(subtask.due)) subtask.due = ''
                    const rawSubAssignee = typeof sub.assignee === 'string' ? sub.assignee.trim() : ''
                    if(rawSubAssignee && teamSet.has(rawSubAssignee)) subtask.assignee = rawSubAssignee
                    return subtask
                  }
                  const todo = {
                    text: typeof t.text === 'string' ? t.text : String(t.text ?? ''),
                    done: !!t.done,
                    due: typeof t.due === 'string' ? t.due : '',
                    assignee: '',
                    repeat: null,
                    acknowledged: !!t.acknowledged,
                    subtasks: Array.isArray(t.subtasks)
                      ? t.subtasks.filter(st => st && typeof st === 'object').map(st => sanitizeSubtask(st))
                      : []
                  }
                  if(todo.due && !parseIsoDate(todo.due)) todo.due = ''
                  const rawAssignee = typeof t.assignee === 'string' ? t.assignee.trim() : ''
                  if(rawAssignee && teamSet.has(rawAssignee)) todo.assignee = rawAssignee
                  const repeatSpec = normalizeRepeatSpec(t.repeat, { dueDate: todo.due })
                  if(repeatSpec) todo.repeat = repeatSpec
                  todo.subtasks.forEach(sub => { if(sub.due && !parseIsoDate(sub.due)) sub.due = '' })
                  return todo
                })
            : [],
          notes: typeof raw.notes === 'string' ? raw.notes : String(raw.notes ?? ''),
          tab: typeof raw.tab === 'string' && raw.tab.trim() ? raw.tab.trim() : 'Alle',
          folder: typeof raw.folder === 'string' ? raw.folder : String(raw.folder ?? ''),
          color: typeof raw.color === 'string' ? raw.color : String(raw.color ?? ''),
          collapsed: !!raw.collapsed
        }
        if(copy.date && !parseIsoDate(copy.date)) copy.date = ''
        if(copy.deadline && !parseIsoDate(copy.deadline)) copy.deadline = ''
        copy.todos.forEach(todo => { if(todo.due && !parseIsoDate(todo.due)) todo.due = '' })
        while(seenIds.has(copy.id)) copy.id = uid()
        seenIds.add(copy.id)
        sanitizedProjects.push(copy)
      })
      state.projects = sanitizedProjects
    }

    if(!state.filters || typeof state.filters !== 'object') state.filters = { ...defaults.filters }
    else {
      const { filters } = defaults
      state.filters = {
        q: String(state.filters.q ?? filters.q),
        status: ['all','open','done'].includes(state.filters.status) ? state.filters.status : filters.status,
        sort: typeof state.filters.sort === 'string' && state.filters.sort ? state.filters.sort : filters.sort
      }
    }

    if(!Array.isArray(state.trash)) state.trash = []
    else state.trash = state.trash.filter(item => item && typeof item === 'object').map(item => ({ ...item }))

    if(!Array.isArray(state.tabs)) state.tabs = defaults.tabs.slice()
    if(!state.tabs.includes('Alle')) state.tabs = ['Alle', ...state.tabs.filter(name => name !== 'Alle')]
    if(!Array.isArray(state.tabGroups)) state.tabGroups = []
    if(!Array.isArray(state.tabOrder)) state.tabOrder = []
    if(!state.tabMeta || typeof state.tabMeta !== 'object') state.tabMeta = {}
    const sanitizedTabMeta = {}
    Object.entries(state.tabMeta).forEach(([key,value]) => {
      const meta = (value && typeof value === 'object') ? { ...value } : {}
      if(typeof meta.color !== 'string') delete meta.color
      if(typeof meta.groupId !== 'string') delete meta.groupId
      sanitizedTabMeta[key] = meta
    })
    state.tabMeta = sanitizedTabMeta
    state.tabs.forEach(name => {
      if(!state.tabMeta[name] || typeof state.tabMeta[name] !== 'object') state.tabMeta[name] = {}
    })

    if(!state.currentTab || typeof state.currentTab !== 'string') state.currentTab = defaults.currentTab
    if(!state.theme || typeof state.theme !== 'string') state.theme = defaults.theme
    state.theme = state.theme === 'light' ? 'light' : 'dark'
    if(!state.view || typeof state.view !== 'string') state.view = defaults.view
    if(!['table','timeline','dispo','assignees','summary'].includes(state.view)) state.view = defaults.view

    if(!Array.isArray(state.dispo)) state.dispo = []
    else {
      const sanitizedDispo = []
      const seenDispoIds = new Set()
      state.dispo.forEach(raw => {
        if(!raw || typeof raw !== 'object') return
        const copy = {
          id: typeof raw.id === 'string' && raw.id.trim() ? raw.id.trim() : uid(),
          title: typeof raw.title === 'string' ? raw.title : String(raw.title ?? ''),
          notes: typeof raw.notes === 'string' ? raw.notes : String(raw.notes ?? ''),
          year: parseInteger(raw.year, null),
          month: parseInteger(raw.month, null),
          week: parseInteger(raw.week, null),
          items: Array.isArray(raw.items) ? raw.items.filter(it => it && typeof it === 'object').map(it => ({
            id: typeof it.id === 'string' && it.id.trim() ? it.id.trim() : uid(),
            project: typeof it.project === 'string' ? it.project : String(it.project ?? ''),
            assignee: typeof it.assignee === 'string' ? it.assignee : String(it.assignee ?? ''),
            todo: typeof it.todo === 'string' ? it.todo : String(it.todo ?? ''),
            due: typeof it.due === 'string' ? it.due : ''
          })) : []
        }
        copy.items.forEach(item => { if(item.due && !parseIsoDate(item.due)) item.due = '' })
        while(seenDispoIds.has(copy.id)) copy.id = uid()
        seenDispoIds.add(copy.id)
        sanitizedDispo.push(copy)
      })
      state.dispo = sanitizedDispo
    }

    if(!state.timelineTab) state.timelineTab = defaults.timelineTab
    if(!state.timelineZoom) state.timelineZoom = defaults.timelineZoom
    if(!Array.isArray(state.order)) state.order = []
    if(!state.orderByTab || typeof state.orderByTab !== 'object') state.orderByTab = {}
    if(Array.isArray(state.projects)){
      const seen = new Set()
      state.order = state.order.filter(id => {
        if(!id || seen.has(id)) return false
        seen.add(id)
        return true
      })
      state.projects.forEach(p => {
        if(p && p.id && !seen.has(p.id)){
          state.order.push(p.id)
          seen.add(p.id)
        }
      })
    }
  if(!Array.isArray(state.orderByTab['Alle'])) state.orderByTab['Alle'] = state.order.slice()
}
normalizeState()

  const dirtyDot = document.getElementById('dirtyDot')
  const fileLocationEl = document.getElementById('fileLocation')
  let unsaved = false
  const history = [], future = [], selected = new Set()
  const toast = document.getElementById('toast')
  const DAY_MS = 86400000
  if(fileLocationEl){
    updateFileLocationDisplay()
  }
  let draggingProjectId = null
  let draggingTabName = null
  let draggingGroupId = null
  let lastDispoAssignInfo = { count:0, label:'' }
  let virtualizationActive = false
  let virtualScrollScheduled = false
  let currentFileHandle = null
  let repeatTarget = null
  const calendarDialogState = { tasks: [], fileName: 'todos.ics' }
  const TAB_COLOR_PRESETS = [
    '#7C3AED', '#6366F1', '#8B5CF6', '#A855F7', '#EC4899', '#FB7185',
    '#F97316', '#F59E0B', '#FACC15', '#22C55E', '#10B981', '#0EA5E9',
    '#38BDF8', '#14B8A6', '#0F766E', '#2563EB', '#4338CA', '#94A3B8',
    '#64748B', '#1E293B'
  ]
  const DEFAULT_TAB_COLOR = '#7C3AED'

  // ===== Theme / Title =====
  function applyTheme(){
    const isLight = state.theme === 'light'
    document.body.classList.toggle('light', isLight)
    const modeToggle = document.getElementById('modeToggle')
    modeToggle.checked = isLight
    modeToggle.setAttribute('aria-checked', String(isLight))
  }
 function setTitle(){
  const t = (state.title || '').trim() || 'XY-To-Dos';
  document.getElementById('titleText').textContent = t;
  document.title = t;                   // ← Tab-Titel aktualisieren
}

  function snapshot(){ return JSON.parse(JSON.stringify(state)) }
  function setDirty(v){
    unsaved = !!v
    dirtyDot.classList.toggle('on', unsaved)
  }

  function showToast(msg){
    toast.textContent = msg
    toast.classList.add('show')
    setTimeout(()=>toast.classList.remove('show'), 1800)
  }
  const locationKey = (() => {
    try{
      const url = new URL(location.href)
      url.hash = ''
      url.search = ''
      return url.href
    }catch(e){
      return location.href
    }
  })()
  async function writeToHandle(handle, html){
    const writable = await handle.createWritable()
    await writable.write(html)
    await writable.close()
  }
  const FILE_HANDLE_DB = 'xy_todos_handles'
  const FILE_HANDLE_STORE = 'handles'
  let handleDbPromise = null
  function openHandleDb(){
    if(handleDbPromise) return handleDbPromise
    if(!('indexedDB' in window)){
      handleDbPromise = Promise.resolve(null)
      return handleDbPromise
    }
    handleDbPromise = new Promise(resolve => {
      try{
        const req = indexedDB.open(FILE_HANDLE_DB, 1)
        req.onupgradeneeded = () => {
          const db = req.result
          if(!db.objectStoreNames.contains(FILE_HANDLE_STORE)){
            db.createObjectStore(FILE_HANDLE_STORE)
          }
        }
        req.onsuccess = () => resolve(req.result)
        req.onerror = () => resolve(null)
      }catch(e){ resolve(null) }
    })
    return handleDbPromise
  }
  async function storeHandle(key, handle){
    const db = await openHandleDb()
    if(!db) return
    return new Promise(resolve => {
      try{
        const tx = db.transaction(FILE_HANDLE_STORE, 'readwrite')
        tx.objectStore(FILE_HANDLE_STORE).put(handle, key)
        tx.oncomplete = () => resolve()
        tx.onerror = () => resolve()
      }catch(e){ resolve() }
    })
  }
  async function loadHandle(key){
    const db = await openHandleDb()
    if(!db) return null
    return new Promise(resolve => {
      try{
        const tx = db.transaction(FILE_HANDLE_STORE, 'readonly')
        const req = tx.objectStore(FILE_HANDLE_STORE).get(key)
        req.onsuccess = () => resolve(req.result || null)
        req.onerror = () => resolve(null)
      }catch(e){ resolve(null) }
    })
  }
  async function ensureHandlePermission(handle){
    if(!handle) return false
    if(typeof handle.queryPermission === 'function'){
      try{
        const status = await handle.queryPermission({ mode:'readwrite' })
        if(status === 'granted') return true
        if(status === 'prompt'){
          const result = await handle.requestPermission({ mode:'readwrite' })
          return result === 'granted'
        }
        return false
      }catch(e){ return false }
    }
    return true
  }
  function updateFileLocationDisplay(name){
    if(!fileLocationEl) return
    if(name){
      fileLocationEl.textContent = name
    }else{
      try{
        const url = new URL(location.href)
        fileLocationEl.textContent = decodeURIComponent(url.pathname.split('/').pop() || url.href)
      }catch(e){
        fileLocationEl.textContent = ''
      }
    }
  }
  const storedHandlePromise = loadHandle(locationKey).catch(() => null)
  storedHandlePromise.then(handle => {
    if(handle){
      currentFileHandle = handle
      try{
        updateFileLocationDisplay(handle.name || location.href)
      }catch(e){ /* ignore */ }
    }
  })
  if('launchQueue' in window && typeof window.launchQueue.setConsumer === 'function'){
    try{
      window.launchQueue.setConsumer(async launchParams => {
        if(!launchParams || !Array.isArray(launchParams.files)) return
        for(const file of launchParams.files){
          if(file && file.kind === 'file' && file.handle){
            currentFileHandle = file.handle
            updateFileLocationDisplay(file.name || location.href)
            storeHandle(locationKey, currentFileHandle).catch(()=>{})
            break
          }
        }
      })
    }catch(e){ /* optional */ }
  }
  async function ensureFileHandle(){
    if(currentFileHandle){
      if(await ensureHandlePermission(currentFileHandle)){
        return currentFileHandle
      }
      currentFileHandle = null
      updateFileLocationDisplay()
    }
    const stored = await storedHandlePromise
    if(stored){
      if(await ensureHandlePermission(stored)){
        currentFileHandle = stored
        updateFileLocationDisplay(stored.name || location.href)
        return currentFileHandle
      }
    }
    if(window.showSaveFilePicker){
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: inferFileName(),
          types: [{ description: 'HTML', accept: { 'text/html': ['.html', '.htm'] } }],
          excludeAcceptAllOption: true
        })
        if(handle){
          currentFileHandle = handle
          updateFileLocationDisplay(handle.name || location.href)
          try{
            await storeHandle(locationKey, handle)
          }catch(e){ /* ignore */ }
          return handle
        }
      }catch(err){
        if(err && err.name === 'AbortError') return null
        throw err
      }
      return null
    }
    if(window.showOpenFilePicker){
      try{
        const [handle] = await window.showOpenFilePicker({
          multiple: false,
          types: [{ description:'HTML-Dateien', accept:{ 'text/html':['.html','.htm'] } }],
          excludeAcceptAllOption: true
        })
        if(handle && await ensureHandlePermission(handle)){
          currentFileHandle = handle
          updateFileLocationDisplay(handle.name || location.href)
          try{
            await storeHandle(locationKey, handle)
          }catch(e){ /* ignore */ }
          return handle
        }
      }catch(err){
        if(err && err.name === 'AbortError') return null
        throw err
      }
      return null
    }
    showToast('Datei-Zugriff nicht möglich. Bitte im kompatiblen Browser erneut öffnen.')
    return null
  }
  function syncEmbeddedState(){
    const script = document.getElementById('APP_STATE')
    if(script){
      try{
        script.textContent = JSON.stringify(state)
      }catch(err){
        console.error('APP_STATE konnte nicht aktualisiert werden', err)
      }
    }
  }

  function inferFileName(){
    if(currentFileHandle && currentFileHandle.name) return currentFileHandle.name
    try{
      const url = new URL(location.href)
      const last = url.pathname.split('/').pop()
      if(last) return decodeURIComponent(last)
    }catch(e){ /* ignore */ }
    const title = (state.title || '').trim()
    return title ? `${title}.html` : 'Projektuebersicht.html'
  }

  async function save(){
    syncEmbeddedState()
    const html = buildSelfContainedHTML()
    try{
      const handle = await ensureFileHandle()
      if(handle){
        await writeToHandle(handle, html)
        setDirty(false)
        showToast('Gespeichert')
        updateFileLocationDisplay(handle.name || location.href)
        return
      }
    }catch(err){
      if(err && err.name === 'AbortError') return
      const message = err && err.message ? err.message : err
      console.error('Dateihandle-Speicherung fehlgeschlagen', err)
      showToast('Speichern fehlgeschlagen: ' + message)
    }
    try{
      const blob = new Blob([html], { type:'text/html;charset=utf-8' })
      const fileName = inferFileName()
      if(typeof navigator !== 'undefined' && typeof navigator.msSaveOrOpenBlob === 'function'){
        navigator.msSaveOrOpenBlob(blob, fileName)
      }else{
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = fileName
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      }
      setDirty(false)
      showToast('Download gespeichert – bitte Originaldatei ersetzen')
    }catch(fallbackErr){
      console.error('Download-Sicherung fehlgeschlagen', fallbackErr)
      const message = fallbackErr && fallbackErr.message ? fallbackErr.message : fallbackErr
      showToast('Speichern nicht möglich: ' + message)
    }
  }
  window.save = save
  function parseGermanDate(str){
    if(!str) return null
    const m = String(str).trim().match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/)
    if(!m) return null
    const [, dd, mm, yyyy] = m
    const d = new Date(Date.UTC(Number(yyyy), Number(mm) - 1, Number(dd)))
    return Number.isNaN(d.getTime()) ? null : d
  }
  function parseIsoDate(str){
    if(!str) return null
    const m = String(str).trim().match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/)
    if(!m) return null
    const [, yyyy, mm, dd] = m
    const d = new Date(Date.UTC(Number(yyyy), Number(mm) - 1, Number(dd)))
    return Number.isNaN(d.getTime()) ? null : d
  }
  function formatGermanDate(date){
    if(!(date instanceof Date) || Number.isNaN(date.getTime())) return ''
    const dd = String(date.getUTCDate()).padStart(2,'0')
    const mm = String(date.getUTCMonth()+1).padStart(2,'0')
    const yyyy = date.getUTCFullYear()
    return `${dd}.${mm}.${yyyy}`
  }
  function formatIsoDate(date){
    if(!(date instanceof Date) || Number.isNaN(date.getTime())) return ''
    const dd = String(date.getUTCDate()).padStart(2,'0')
    const mm = String(date.getUTCMonth()+1).padStart(2,'0')
    const yyyy = date.getUTCFullYear()
    return `${yyyy}-${mm}-${dd}`
  }
  function parseCsvBoolean(val){
    const normalized = String(val ?? '').trim().toLowerCase()
    if(!normalized) return false
    return ['true','1','ja','yes','y','on','wahr'].includes(normalized)
  }
  function parseInteger(val, fallback=null){
    const n = parseInt(String(val ?? '').trim(), 10)
    return Number.isFinite(n) ? n : fallback
  }
  function startOfIsoWeek(date){
    const base = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()))
    const dow = base.getUTCDay() || 7
    base.setUTCDate(base.getUTCDate() - (dow - 1))
    return base
  }
  function endOfIsoWeek(date){
    const start = startOfIsoWeek(date)
    const end = new Date(start.getTime())
    end.setUTCDate(start.getUTCDate() + 6)
    return end
  }
  const DATE_PICKER_MONTHS = ['Januar','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember']
  const DATE_PICKER_WEEKDAYS = ['Mo','Di','Mi','Do','Fr','Sa','So']
  const datePickerState = { el:null, anchor:null, year:0, month:0, selected:null, onSelect:null }

  function ensureDatePicker(){
    if(datePickerState.el) return datePickerState.el
    const el = document.createElement('div')
    el.className = 'datePicker'
    el.setAttribute('role','dialog')
    el.setAttribute('aria-modal','true')
    datePickerState.el = el
    document.body.appendChild(el)
    return el
  }
  function renderDatePicker(){
    const picker = ensureDatePicker()
    picker.innerHTML = ''
    const header = document.createElement('header')
    const prev = document.createElement('span')
    prev.className = 'navBtn'
    prev.textContent = '‹'
    prev.addEventListener('click', () => shiftDatePickerMonth(-1))
    const next = document.createElement('span')
    next.className = 'navBtn'
    next.textContent = '›'
    next.addEventListener('click', () => shiftDatePickerMonth(1))
    const title = document.createElement('div')
    title.textContent = `${DATE_PICKER_MONTHS[datePickerState.month]} ${datePickerState.year}`
    header.appendChild(prev)
    header.appendChild(title)
    header.appendChild(next)
    picker.appendChild(header)

    const table = document.createElement('table')
    const thead = document.createElement('thead')
    const headRow = document.createElement('tr')
    DATE_PICKER_WEEKDAYS.forEach(label => {
      const th = document.createElement('th')
      th.textContent = label
      headRow.appendChild(th)
    })
    thead.appendChild(headRow)
    table.appendChild(thead)

    const tbody = document.createElement('tbody')
    const firstOfMonth = new Date(Date.UTC(datePickerState.year, datePickerState.month, 1))
    let cursor = startOfIsoWeek(firstOfMonth)
    for(let w=0; w<6; w++){
      const row = document.createElement('tr')
      for(let d=0; d<7; d++){
        const cellDate = new Date(cursor.getTime())
        const td = document.createElement('td')
        td.textContent = cellDate.getUTCDate()
        if(cellDate.getUTCMonth() !== datePickerState.month){ td.classList.add('disabled') }
        if(datePickerState.selected && cellDate.getTime() === datePickerState.selected.getTime()){
          td.classList.add('selected')
        }
        td.addEventListener('click', () => {
          const cb = datePickerState.onSelect
          const chosen = new Date(cellDate.getTime())
          closeDatePicker()
          if(typeof cb === 'function'){
            cb(chosen)
          }
        })
        row.appendChild(td)
        cursor.setUTCDate(cursor.getUTCDate() + 1)
      }
      tbody.appendChild(row)
    }
    table.appendChild(tbody)
    picker.appendChild(table)
  }
  function positionDatePicker(){
    const picker = datePickerState.el
    if(!picker || !picker.classList.contains('show') || !datePickerState.anchor) return
    picker.style.visibility = 'hidden'
    const rect = datePickerState.anchor.getBoundingClientRect()
    const width = picker.offsetWidth
    const height = picker.offsetHeight
    let left = rect.left
    let top = rect.bottom + 8
    let above = false
    if(top + height > window.innerHeight - 12){
      const potentialTop = rect.top - height - 8
      if(potentialTop >= 12){
        top = potentialTop
        above = true
      }else{
        top = Math.max(12, window.innerHeight - height - 12)
      }
    }
    if(top < 12){ top = 12 }
    if(left + width > window.innerWidth - 12){ left = window.innerWidth - width - 12 }
    if(left < 12){ left = 12 }
    picker.style.left = `${Math.round(left)}px`
    picker.style.top = `${Math.round(top)}px`
    picker.classList.toggle('above', above)
    const anchorCenter = rect.left + rect.width / 2
    const arrowLeft = Math.min(width - 20, Math.max(20, anchorCenter - left))
    picker.style.setProperty('--arrow-left', `${arrowLeft}px`)
    picker.style.visibility = ''
  }
  function shiftDatePickerMonth(delta){
    datePickerState.month += delta
    while(datePickerState.month < 0){ datePickerState.month += 12; datePickerState.year -= 1 }
    while(datePickerState.month > 11){ datePickerState.month -= 12; datePickerState.year += 1 }
    renderDatePicker()
    positionDatePicker()
  }
  function handleDatePickerOutside(ev){
    const picker = datePickerState.el
    if(!picker || !picker.classList.contains('show')) return
    if(picker.contains(ev.target)) return
    if(datePickerState.anchor && datePickerState.anchor.contains(ev.target)) return
    closeDatePicker()
  }
  function handleDatePickerKey(ev){
    if(ev.key === 'Escape') closeDatePicker()
  }
  function closeDatePicker(){
    const picker = datePickerState.el
    if(!picker) return
    picker.classList.remove('show','above')
    picker.style.removeProperty('visibility')
    picker.style.removeProperty('--arrow-left')
    datePickerState.anchor = null
    datePickerState.onSelect = null
    window.removeEventListener('resize', positionDatePicker, true)
    window.removeEventListener('scroll', positionDatePicker, true)
    document.removeEventListener('mousedown', handleDatePickerOutside, true)
    document.removeEventListener('keydown', handleDatePickerKey, true)
  }
  function openDatePicker(anchor, opts = {}){
    if(datePickerState.el && datePickerState.el.classList.contains('show')){
      if(datePickerState.anchor === anchor){
        closeDatePicker()
        return
      }
    }
    const picker = ensureDatePicker()
    const provided = (opts.value instanceof Date && !Number.isNaN(opts.value.getTime())) ? new Date(opts.value.getTime()) : null
    const base = provided || new Date()
    datePickerState.anchor = anchor
    datePickerState.selected = provided
    datePickerState.year = base.getUTCFullYear()
    datePickerState.month = base.getUTCMonth()
    datePickerState.onSelect = typeof opts.onSelect === 'function' ? opts.onSelect : null
    renderDatePicker()
    picker.classList.add('show')
    picker.style.visibility = 'hidden'
    positionDatePicker()
    picker.style.visibility = ''
    document.addEventListener('mousedown', handleDatePickerOutside, true)
    document.addEventListener('keydown', handleDatePickerKey, true)
    window.addEventListener('resize', positionDatePicker, true)
    window.addEventListener('scroll', positionDatePicker, true)
  }
  function ensureTabGroupLayer(){
    let layer = document.getElementById('tabGroupLayer')
    if(!layer){
      layer = document.createElement('div')
      layer.id = 'tabGroupLayer'
      layer.className = 'tab-group-layer'
      document.body.appendChild(layer)
    }
    return layer
  }
  function positionGroupDropdown(anchor, dropdown){
    const layer = ensureTabGroupLayer()
    if(dropdown.parentElement !== layer){
      layer.appendChild(dropdown)
    }
    dropdown.classList.add('floating','show')
    dropdown.style.visibility = 'hidden'
    const rect = anchor.getBoundingClientRect()
    const width = dropdown.offsetWidth
    const height = dropdown.offsetHeight
    let left = rect.left
    let top = rect.bottom + 8
    let above = false
    if(top + height > window.innerHeight - 12){
      const potentialTop = rect.top - height - 8
      if(potentialTop >= 12){
        top = potentialTop
        above = true
      }else{
        top = Math.max(12, window.innerHeight - height - 12)
      }
    }
    if(left + width > window.innerWidth - 12){ left = window.innerWidth - width - 12 }
    if(left < 12){ left = 12 }
    dropdown.style.left = `${Math.round(left)}px`
    dropdown.style.top = `${Math.round(top)}px`
    dropdown.classList.toggle('above', above)
    const anchorCenter = rect.left + rect.width / 2
    const arrowLeft = Math.min(width - 24, Math.max(24, anchorCenter - left))
    dropdown.style.setProperty('--arrow-left', `${arrowLeft}px`)
    dropdown.style.visibility = ''
  }
  function resetGroupDropdown(dropdown, container){
    dropdown.classList.remove('floating','above','show')
    dropdown.style.removeProperty('left')
    dropdown.style.removeProperty('top')
    dropdown.style.removeProperty('--arrow-left')
    dropdown.style.removeProperty('visibility')
    const layer = document.getElementById('tabGroupLayer')
    if(layer && dropdown.parentElement === layer){
      layer.removeChild(dropdown)
    }
    if(container && dropdown.parentElement !== container){
      container.appendChild(dropdown)
    }
  }
  const openTabGroupDropdowns = new Set()
  function closeAllGroupDropdowns(){
    const current = Array.from(openTabGroupDropdowns)
    current.forEach(drop => {
      if(typeof drop.__close === 'function'){
        drop.__close()
      }else{
        resetGroupDropdown(drop, drop.__home || null)
        openTabGroupDropdowns.delete(drop)
      }
    })
  }

  window.addEventListener('beforeunload', e => { if(unsaved){ e.preventDefault(); e.returnValue = '' } })
  window.addEventListener('unhandledrejection', ev => {
    if(isAbortError(ev.reason)){
      ev.preventDefault()
    }
  })

  // ===== Utils =====
  const tbody = document.getElementById('tbody')
  let emptyRow = document.getElementById('emptyRow')
  if(!emptyRow){
    emptyRow = document.createElement('tr')
    emptyRow.id = 'emptyRow'
    const td = document.createElement('td')
    td.colSpan = 7
    td.className = 'emptyRowCell'
    td.textContent = 'Keine Projekte gefunden'
    emptyRow.appendChild(td)
  }
  if(tbody){
    tbody.addEventListener('dragover', e => {
      if(state.filters.sort !== 'manual') return
      if(!getDragProjectId(e)) return
      e.preventDefault()
      e.dataTransfer.dropEffect = 'move'
    })
    tbody.addEventListener('drop', e => {
      e.preventDefault()
      if(state.filters.sort !== 'manual'){
        showToast('Sortierung auf „Manuell“ stellen, um die Reihenfolge zu ändern.');
        return
      }
      const dragId = getDragProjectId(e)
      if(!dragId) return
      pushHistory()
      const activeTab = state.currentTab || 'Alle'
      const order = ensureManualOrder(projectIdsForTab(activeTab), activeTab)
      const from = order.indexOf(dragId)
      if(from >= 0) order.splice(from,1)
      const rows = Array.from(tbody.querySelectorAll('tr[data-id]'))
      const pointerY = e.clientY
      let beforeId = ''
      for(const row of rows){
        const rect = row.getBoundingClientRect()
        if(pointerY < rect.top + rect.height / 2){
          beforeId = row.dataset.id || ''
          break
        }
      }
      let insertIdx = order.length
      if(beforeId){
        const idx = order.indexOf(beforeId)
        if(idx >= 0) insertIdx = idx
      }
      if(insertIdx < 0) insertIdx = 0
      if(insertIdx > order.length) insertIdx = order.length
      order.splice(insertIdx, 0, dragId)
      if(activeTab === 'Alle'){
        state.order = order
        state.orderByTab['Alle'] = order.slice()
      }else{
        state.orderByTab[activeTab] = order
      }
      setDirty(true)
      render()
      draggingProjectId = null
    })
  }
  const tabsEl = document.getElementById('tabs')
  const tabsScroll = document.getElementById('tabsScroll')
  const tabsScrollbar = document.getElementById('tabsScrollbar')
  const tabsThumb = document.getElementById('tabsThumb')
  const tabMenu = document.createElement('div')
  tabMenu.className = 'tab-menu'
  document.body.appendChild(tabMenu)
  const tabSubmenu = document.createElement('div')
  tabSubmenu.className = 'tab-submenu'
  document.body.appendChild(tabSubmenu)
  const colorPalette = document.createElement('div')
  colorPalette.className = 'color-palette'
  const colorGrid = document.createElement('div')
  colorGrid.className = 'color-grid'
  colorPalette.appendChild(colorGrid)
  const customColorRow = document.createElement('div')
  customColorRow.className = 'custom-color'
  const customColorLabel = document.createElement('span')
  customColorLabel.textContent = 'Eigene Farbe'
  const customColorPicker = document.createElement('input')
  customColorPicker.type = 'color'
  customColorPicker.value = DEFAULT_TAB_COLOR
  const customColorInput = document.createElement('input')
  customColorInput.type = 'text'
  customColorInput.placeholder = '#RRGGBB'
  customColorInput.autocomplete = 'off'
  customColorInput.spellcheck = false
  const customColorApply = document.createElement('button')
  customColorApply.type = 'button'
  customColorApply.textContent = 'Übernehmen'
  customColorRow.appendChild(customColorLabel)
  customColorRow.appendChild(customColorPicker)
  customColorRow.appendChild(customColorInput)
  customColorRow.appendChild(customColorApply)
  colorPalette.appendChild(customColorRow)
  const resetColorBtn = document.createElement('button')
  resetColorBtn.type = 'button'
  resetColorBtn.className = 'reset-btn'
  resetColorBtn.textContent = 'Standardfarbe verwenden'
  colorPalette.appendChild(resetColorBtn)
  document.body.appendChild(colorPalette)

  let activeMenuAnchor = null
  let activeSubmenuAnchor = null
  let submenuHideTimer = null
  let colorPaletteCallback = null
  function setCustomColorInputs(hex){
    const normalized = normalizeHexColor(hex) || DEFAULT_TAB_COLOR
    customColorPicker.value = normalized
    customColorInput.value = normalized
    customColorInput.classList.remove('invalid')
  }

  function closeSubmenu(){
    tabSubmenu.classList.remove('show')
    tabSubmenu.innerHTML = ''
    activeSubmenuAnchor = null
  }

  function closeColorPalette(){
    colorPalette.classList.remove('show')
    customColorInput.classList.remove('invalid')
    colorPaletteCallback = null
  }

  function closeTabMenu(){
    if(tabMenu.classList.contains('show')){
      tabMenu.classList.remove('show')
      tabMenu.innerHTML = ''
    }
    closeSubmenu()
    activeMenuAnchor = null
  }

  function openTabSubmenu(anchor, items){
    if(!anchor || !Array.isArray(items) || !items.length) return
    tabSubmenu.innerHTML = ''
    items.forEach(item => {
      if(item && item.type === 'divider'){
        const hr = document.createElement('hr')
        hr.style.margin = '4px 0'
        hr.style.border = 'none'
        hr.style.borderTop = '1px solid ' + getComputedStyle(document.body).getPropertyValue('--border')
        tabSubmenu.appendChild(hr)
        return
      }
      const btn = document.createElement('button')
      btn.type = 'button'
      btn.textContent = item && item.label ? item.label : 'Option'
      if(item && item.icon){
        const icon = document.createElement('span')
        icon.className = 'ms'
        icon.textContent = item.icon
        btn.prepend(icon)
      }
      if(item && item.disabled) btn.disabled = true
      btn.addEventListener('click', e => {
        e.preventDefault(); e.stopPropagation()
        closeTabMenu()
        if(item && typeof item.action === 'function') item.action({ event:e, anchor:btn, close:closeTabMenu })
      })
      tabSubmenu.appendChild(btn)
    })
    const rect = anchor.getBoundingClientRect()
    const menuRect = tabSubmenu.getBoundingClientRect()
    const width = Math.max(menuRect.width || 0, 200)
    const left = Math.min(window.innerWidth - width - 12, rect.right + 8)
    tabSubmenu.style.left = left + 'px'
    tabSubmenu.style.top = rect.top + window.scrollY + 'px'
    tabSubmenu.classList.add('show')
    activeSubmenuAnchor = anchor
  }

  function openColorPalette(anchor, { currentColor = '', onSelect } = {}){
    if(!anchor) return
    colorPaletteCallback = typeof onSelect === 'function' ? onSelect : null
    colorGrid.innerHTML = ''
    const selected = normalizeHexColor(currentColor)
    const selectedLower = selected ? selected.toLowerCase() : ''
    TAB_COLOR_PRESETS.forEach(color => {
      const normalized = normalizeHexColor(color) || color
      const sw = document.createElement('button')
      sw.type = 'button'
      sw.className = 'color-swatch'
      sw.style.background = normalized
      if(selectedLower && selectedLower === normalized.toLowerCase()) sw.classList.add('selected')
      sw.addEventListener('click', e => {
        e.preventDefault(); e.stopPropagation()
        if(colorPaletteCallback) colorPaletteCallback(normalized)
        closeColorPalette()
      })
      colorGrid.appendChild(sw)
    })
    setCustomColorInputs(selected || DEFAULT_TAB_COLOR)
    const rect = anchor.getBoundingClientRect()
    const paletteRect = colorPalette.getBoundingClientRect()
    const width = Math.max(paletteRect.width || 0, 220)
    let left = rect.left
    if(left + width + 12 > window.innerWidth) left = window.innerWidth - width - 12
    if(left < 12) left = 12
    colorPalette.style.left = left + 'px'
    colorPalette.style.top = rect.bottom + window.scrollY + 8 + 'px'
    colorPalette.classList.add('show')
  }

  customColorPicker.addEventListener('input', () => {
    customColorInput.value = customColorPicker.value.toUpperCase()
    customColorInput.classList.remove('invalid')
  })
  customColorPicker.addEventListener('change', e => {
    e.preventDefault(); e.stopPropagation()
    if(colorPaletteCallback) colorPaletteCallback(customColorPicker.value.toUpperCase())
    closeColorPalette()
  })
  customColorInput.addEventListener('input', () => {
    customColorInput.classList.remove('invalid')
    const normalized = normalizeHexColor(customColorInput.value)
    if(normalized){
      customColorPicker.value = normalized
    }
  })
  customColorInput.addEventListener('keydown', e => {
    if(e.key === 'Enter'){
      e.preventDefault()
      customColorApply.click()
    }
  })
  customColorApply.addEventListener('click', e => {
    e.preventDefault(); e.stopPropagation()
    const normalized = normalizeHexColor(customColorInput.value)
    if(normalized){
      if(colorPaletteCallback) colorPaletteCallback(normalized)
      closeColorPalette()
    }else{
      customColorInput.classList.add('invalid')
    }
  })

  resetColorBtn.addEventListener('click', e => {
    e.preventDefault(); e.stopPropagation()
    if(colorPaletteCallback) colorPaletteCallback('')
    closeColorPalette()
  })

  tabSubmenu.addEventListener('mouseenter', () => { clearTimeout(submenuHideTimer) })
  tabSubmenu.addEventListener('mouseleave', () => {
    clearTimeout(submenuHideTimer)
    submenuHideTimer = setTimeout(() => closeSubmenu(), 120)
  })

  function openTabMenu(anchor, items){
    if(!anchor || !Array.isArray(items) || !items.length) return
    closeSubmenu()
    closeColorPalette()
    tabMenu.innerHTML = ''
    items.forEach(item => {
      if(item && item.type === 'divider'){
        const hr = document.createElement('hr')
        hr.style.margin = '4px 0'
        hr.style.border = 'none'
        hr.style.borderTop = '1px solid ' + getComputedStyle(document.body).getPropertyValue('--border')
        tabMenu.appendChild(hr)
        return
      }
      const btn = document.createElement('button')
      btn.type = 'button'
      btn.textContent = item && item.label ? item.label : 'Option'
      if(item && item.icon){
        const icon = document.createElement('span')
        icon.className = 'ms'
        icon.textContent = item.icon
        btn.prepend(icon)
      }
      if(item && item.disabled) btn.disabled = true
      const submenuItems = Array.isArray(item && item.submenu) ? item.submenu.filter(Boolean) : null
      if(submenuItems && submenuItems.length){
        btn.classList.add('has-submenu')
        const arrow = document.createElement('span')
        arrow.className = 'ms submenu-arrow'
        arrow.textContent = 'chevron_right'
        btn.appendChild(arrow)
        const showSub = () => {
          clearTimeout(submenuHideTimer)
          openTabSubmenu(btn, submenuItems)
        }
        const scheduleHide = () => {
          clearTimeout(submenuHideTimer)
          submenuHideTimer = setTimeout(() => {
            if(activeSubmenuAnchor === btn) closeSubmenu()
          }, 150)
        }
        btn.addEventListener('mouseenter', showSub)
        btn.addEventListener('focus', showSub)
        btn.addEventListener('mouseleave', scheduleHide)
      }else{
        btn.addEventListener('click', e => {
          e.preventDefault(); e.stopPropagation()
          const ctx = { event:e, anchor:btn, close:closeTabMenu, openColorPalette }
          const res = item && typeof item.action === 'function' ? item.action(ctx) : undefined
          if(res === false || (item && item.keepOpen)) return
          closeTabMenu()
        })
      }
      tabMenu.appendChild(btn)
    })
    const rect = anchor.getBoundingClientRect()
    const menuRect = tabMenu.getBoundingClientRect()
    const menuWidth = Math.max(menuRect.width || 0, 200)
    const left = Math.min(window.innerWidth - menuWidth - 12, Math.max(12, rect.left))
    tabMenu.style.left = left + 'px'
    tabMenu.style.right = 'auto'
    tabMenu.style.top = rect.bottom + window.scrollY + 6 + 'px'
    tabMenu.classList.add('show')
    activeMenuAnchor = anchor
  }

  document.addEventListener('click', e => {
    if(tabMenu.classList.contains('show')){
      if(tabMenu.contains(e.target) || (activeMenuAnchor && activeMenuAnchor.contains(e.target)) || tabSubmenu.contains(e.target)){
        return
      }
      closeTabMenu()
    }
    if(colorPalette.classList.contains('show') && !colorPalette.contains(e.target)){
      closeColorPalette()
    }
  })
  document.addEventListener('keydown', e => {
    if(e.key === 'Escape'){
      closeTabMenu()
      closeColorPalette()
    }
  })
  window.addEventListener('resize', () => { closeTabMenu(); closeColorPalette(); updateTabsOverflow() })
  window.addEventListener('scroll', () => { closeTabMenu(); closeColorPalette() }, true)

  let tabsThumbDragging = false
  let tabsThumbPointerId = null
  let tabsThumbDragStartX = 0
  let tabsThumbStartScroll = 0

  function updateTabsOverflow(){
    if(!tabsScroll || !tabsScrollbar || !tabsThumb) return
    const overflow = tabsScroll.scrollWidth - tabsScroll.clientWidth > 2
    tabsScrollbar.classList.toggle('show', overflow)
    tabsScroll.classList.toggle('is-overflowing', overflow)
    if(!overflow){
      tabsThumb.style.transform = 'translateX(0)'
      return
    }
    const trackWidth = tabsScrollbar.clientWidth || tabsScroll.clientWidth
    const ratio = tabsScroll.clientWidth / Math.max(tabsScroll.scrollWidth, 1)
    const thumbWidth = Math.min(Math.max(Math.round(trackWidth * ratio), 32), trackWidth)
    tabsThumb.style.width = thumbWidth + 'px'
    const maxScroll = Math.max(tabsScroll.scrollWidth - tabsScroll.clientWidth, 1)
    const maxOffset = Math.max(trackWidth - thumbWidth, 1)
    const offset = (tabsScroll.scrollLeft / maxScroll) * maxOffset
    tabsThumb.style.transform = `translateX(${Math.min(Math.max(offset, 0), maxOffset)}px)`
  }

  if(tabsScroll){
    tabsScroll.addEventListener('scroll', updateTabsOverflow)
    tabsScroll.addEventListener('wheel', e => {
      if(Math.abs(e.deltaY) <= Math.abs(e.deltaX)) return
      tabsScroll.scrollLeft += e.deltaY
      e.preventDefault()
    }, { passive:false })
  }

  if(tabsThumb){
    const stopThumbDrag = () => {
      if(!tabsThumbDragging) return
      tabsThumbDragging = false
      if(tabsThumbPointerId !== null){
        try{ tabsThumb.releasePointerCapture(tabsThumbPointerId) }catch(err){}
      }
      tabsThumbPointerId = null
    }
    tabsThumb.addEventListener('pointerdown', e => {
      if(!tabsScrollbar || !tabsScroll || !tabsScrollbar.classList.contains('show')) return
      tabsThumbDragging = true
      tabsThumbPointerId = e.pointerId
      tabsThumbDragStartX = e.clientX
      tabsThumbStartScroll = tabsScroll.scrollLeft
      try{ tabsThumb.setPointerCapture(e.pointerId) }catch(err){}
      e.preventDefault()
    })
    tabsThumb.addEventListener('pointermove', e => {
      if(!tabsThumbDragging || e.pointerId !== tabsThumbPointerId) return
      const trackWidth = tabsScrollbar.clientWidth || tabsScroll.clientWidth
      const thumbWidth = tabsThumb.offsetWidth || 1
      const maxOffset = Math.max(trackWidth - thumbWidth, 1)
      const delta = e.clientX - tabsThumbDragStartX
      const scrollMax = Math.max(tabsScroll.scrollWidth - tabsScroll.clientWidth, 1)
      const scrollDelta = (delta / maxOffset) * scrollMax
      tabsScroll.scrollLeft = Math.min(Math.max(tabsThumbStartScroll + scrollDelta, 0), scrollMax)
      e.preventDefault()
    })
    tabsThumb.addEventListener('pointerup', stopThumbDrag)
    tabsThumb.addEventListener('pointercancel', stopThumbDrag)
  }

  if(tabsScrollbar){
    tabsScrollbar.addEventListener('pointerdown', e => {
      if(!tabsScroll || !tabsScrollbar.classList.contains('show') || e.target === tabsThumb) return
      const rect = tabsScrollbar.getBoundingClientRect()
      const ratio = (e.clientX - rect.left) / rect.width
      const scrollMax = Math.max(tabsScroll.scrollWidth - tabsScroll.clientWidth, 0)
      tabsScroll.scrollLeft = Math.min(Math.max(ratio * scrollMax, 0), scrollMax)
      e.preventDefault()
    })
  }

  if(typeof ResizeObserver === 'function' && tabsScroll){
    const ro = new ResizeObserver(() => updateTabsOverflow())
    ro.observe(tabsScroll)
  }
  if(tabsScroll) requestAnimationFrame(() => updateTabsOverflow())

  function normalizeHexColor(value){
    if(value == null) return null
    let hex = String(value).trim()
    if(!hex) return null
    if(hex[0] !== '#') hex = '#' + hex
    if(/^#([0-9a-fA-F]{3})$/.test(hex)){
      hex = '#' + hex.slice(1).split('').map(ch => ch + ch).join('')
    }
    if(/^#([0-9a-fA-F]{6})$/.test(hex)) return hex.toUpperCase()
    return null
  }

  function contrastColor(hex){
    const match = /^#?([0-9a-fA-F]{6})$/.exec(hex || '')
    if(!match) return '#ffffff'
    const value = parseInt(match[1], 16)
    const r = (value >> 16) & 255
    const g = (value >> 8) & 255
    const b = value & 255
    const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255
    return luminance > 0.6 ? '#0f172a' : '#ffffff'
  }

  function detachTabFromGroups(name){
    if(!name || name === 'Alle') return
    state.tabGroups.forEach(group => {
      if(Array.isArray(group.tabs)) group.tabs = group.tabs.filter(t => t !== name)
    })
    if(state.tabMeta[name]) state.tabMeta[name].groupId = ''
  }

    function moveTabBefore(tabName, beforeName){
      if(!tabName || tabName === 'Alle') return
      detachTabFromGroups(tabName)
      const key = 'tab:' + tabName
      state.tabOrder = state.tabOrder.filter(entry => entry !== key)
      if(beforeName && beforeName !== 'Alle'){
        const beforeKey = 'tab:' + beforeName
        const idx = state.tabOrder.indexOf(beforeKey)
        if(idx >= 0) state.tabOrder.splice(idx, 0, key)
        else state.tabOrder.push(key)
      }else{
        state.tabOrder.push(key)
      }
      ensureTabs()
    }

    function moveTabToGroup(tabName, groupId, position){
      if(!tabName || tabName === 'Alle' || !groupId) return
      const group = state.tabGroups.find(g => g.id === groupId)
      if(!group) return
      detachTabFromGroups(tabName)
      state.tabOrder = state.tabOrder.filter(entry => entry !== 'tab:' + tabName)
      if(!state.tabMeta[tabName]) state.tabMeta[tabName] = {}
      state.tabMeta[tabName].groupId = groupId
      if(!Array.isArray(group.tabs)) group.tabs = []
      group.tabs = group.tabs.filter(t => t !== tabName)
      const insertAt = typeof position === 'number' && position >= 0 && position <= group.tabs.length ? position : group.tabs.length
      group.tabs.splice(insertAt, 0, tabName)
      if(!state.tabOrder.includes('group:' + groupId)) state.tabOrder.push('group:' + groupId)
      ensureTabs()
    }

    function moveTabWithinGroup(tabName, groupId, beforeName){
      if(!tabName || tabName === 'Alle' || !groupId) return
      const group = state.tabGroups.find(g => g.id === groupId)
      if(!group){ moveTabToGroup(tabName, groupId); return }
      const idx = beforeName ? group.tabs.indexOf(beforeName) : -1
      moveTabToGroup(tabName, groupId, idx >= 0 ? idx : group.tabs.length)
    }

    function moveGroupBefore(groupId, beforeGroupId){
      if(!groupId) return
      const key = 'group:' + groupId
      state.tabOrder = state.tabOrder.filter(entry => entry !== key)
      if(beforeGroupId){
        const idx = state.tabOrder.indexOf('group:' + beforeGroupId)
        if(idx >= 0) state.tabOrder.splice(idx, 0, key)
        else state.tabOrder.push(key)
      }else{
        state.tabOrder.push(key)
      }
      ensureTabs()
    }

    function assignProjectToTab(projectId, tabName){
      if(!projectId || !tabName) return
      const p = (state.projects || []).find(pr => pr.id === projectId)
      if(p) p.tab = tabName
    }

    function createTab(){
      const nn = prompt('Name des neuen Tabs')
      if(!nn) return
      const name = nn.trim()
      if(!name || name === 'Alle') return
      if(state.tabs.includes(name)){
        showToast('Tab existiert bereits.')
        return
      }
      pushHistory()
      state.tabs.push(name)
      state.tabMeta[name] = state.tabMeta[name] || { color:'', groupId:'' }
      moveTabBefore(name)
      state.currentTab = name
      if(state.view === 'timeline') state.timelineTab = name
      setDirty(true); render()
    }

    function createGroup(){
      const nn = prompt('Name der neuen Gruppe')
      if(!nn) return
      const name = nn.trim()
      if(!name) return
      pushHistory()
      const id = 'grp_' + uid()
      state.tabGroups.push({ id, name, color:'', tabs: [] })
      if(!state.tabOrder.includes('group:' + id)) state.tabOrder.push('group:' + id)
      ensureTabs()
      setDirty(true); render()
    }

    function renameTabPrompt(name){
      if(!name || name === 'Alle') return
      const nn = prompt('Neuer Name für Tab', name)
      if(!nn) return
      const trimmed = nn.trim()
      if(!trimmed || trimmed === 'Alle') return
      if(trimmed === name) return
      if(state.tabs.includes(trimmed)){
        showToast('Name bereits vergeben.')
        return
      }
      pushHistory()
      state.projects.forEach(p => { if(p.tab === name) p.tab = trimmed })
      state.tabGroups.forEach(group => {
        if(Array.isArray(group.tabs)) group.tabs = group.tabs.map(t => t === name ? trimmed : t)
      })
      state.tabOrder = state.tabOrder.map(entry => entry === 'tab:' + name ? 'tab:' + trimmed : entry)
      if(state.tabMeta[name]){
        state.tabMeta[trimmed] = { ...state.tabMeta[name] }
        delete state.tabMeta[name]
      }else{
        state.tabMeta[trimmed] = { color:'', groupId:'' }
      }
      state.tabs = state.tabs.map(t => t === name ? trimmed : t)
      if(state.currentTab === name) state.currentTab = trimmed
      if(state.timelineTab === name) state.timelineTab = trimmed
      ensureTabs()
      setDirty(true); render()
    }

    function deleteTabByName(name){
      if(!name || name === 'Alle') return
      if(!confirm('Tab löschen? Projekte werden nach „Alle“ verschoben.')) return
      pushHistory()
      state.projects.forEach(p => { if(p.tab === name) p.tab = 'Alle' })
      state.tabGroups.forEach(group => {
        if(Array.isArray(group.tabs)) group.tabs = group.tabs.filter(t => t !== name)
      })
      state.tabOrder = state.tabOrder.filter(entry => entry !== 'tab:' + name)
      delete state.tabMeta[name]
      state.tabs = state.tabs.filter(t => t !== name)
      if(state.currentTab === name) state.currentTab = 'Alle'
      if(state.timelineTab === name) state.timelineTab = 'Alle'
      ensureTabs()
      setDirty(true); render()
    }

    function changeTabColor(name, anchor){
      if(!name) return false
      const meta = state.tabMeta[name] || {}
      const anchorEl = anchor || document.querySelector(`.tab[data-name="${CSS && CSS.escape ? CSS.escape(name) : name}"] .tab-more`)
      if(!anchorEl){
        showToast('Farbauswahl nicht möglich')
        return false
      }
      openColorPalette(anchorEl, {
        currentColor: meta.color || '',
        onSelect: color => {
          pushHistory()
          state.tabMeta[name] = state.tabMeta[name] || {}
          state.tabMeta[name].color = (color || '').toLowerCase()
          setDirty(true); render()
          closeTabMenu()
        }
      })
      requestAnimationFrame(() => closeTabMenu())
      return false
    }

    function changeGroupColor(group, anchor){
      if(!group) return false
      const targetId = group.id
      const anchorEl = anchor || document.querySelector(`.tab.is-group[data-group-id="${CSS && CSS.escape ? CSS.escape(targetId) : targetId}"] .tab-group-toggle`)
      if(!anchorEl){
        showToast('Farbauswahl nicht möglich')
        return false
      }
      openColorPalette(anchorEl, {
        currentColor: group.color || '',
        onSelect: color => {
          pushHistory()
          group.color = (color || '').toLowerCase()
          setDirty(true); render()
          closeTabMenu()
        }
      })
      requestAnimationFrame(() => closeTabMenu())
      return false
    }

    function renameGroupPrompt(group){
      if(!group) return
      const nn = prompt('Neuer Name für Gruppe', group.name)
      if(!nn) return
      const trimmed = nn.trim()
      if(!trimmed) return
      pushHistory()
      group.name = trimmed
      setDirty(true); render()
    }

    function deleteGroup(group){
      if(!group) return
      if(!confirm('Gruppe löschen? Tabs werden oben einsortiert.')) return
      pushHistory()
      const tabs = Array.isArray(group.tabs) ? [...group.tabs] : []
      tabs.forEach(name => {
        detachTabFromGroups(name)
        moveTabBefore(name)
      })
      state.tabGroups = state.tabGroups.filter(g => g.id !== group.id)
      state.tabOrder = state.tabOrder.filter(entry => entry !== 'group:' + group.id)
      ensureTabs()
      setDirty(true); render()
    }
  const bulkbar = document.getElementById('bulkbar')
  const bulkTarget = document.getElementById('bulkTarget')
  const selCount = document.getElementById('selCount')
  const tableView = document.getElementById('tableView')
  const timelineShell = document.getElementById('timelineShell')
  const timelineViewEl = document.getElementById('timelineView')
  const timelineTabSelect = document.getElementById('timelineTabSelect')
  const timelineAssigneeSelect = document.getElementById('timelineAssigneeSelect')
  const timelineZoomInput = document.getElementById('timelineZoom')
  const timelineZoomLabelsEl = document.getElementById('timelineZoomLabels')
  const assigneeViewEl = document.getElementById('assigneeView')
  const summaryView = document.getElementById('summaryView')
  window.addEventListener('resize', () => { requestAnimationFrame(layoutSummaryCards); });
  const repeatDialogEl = document.getElementById('repeatDlg')
  const repeatForm = document.getElementById('repeatForm')
  const repeatFreqInput = document.getElementById('repeatFreq')
  const repeatIntervalInput = document.getElementById('repeatInterval')
  const repeatIntervalLabelText = document.getElementById('repeatIntervalLabelText')
  const repeatStartInput = document.getElementById('repeatStart')
  const repeatCountInput = document.getElementById('repeatCount')
  const repeatEndInput = document.getElementById('repeatEnd')
  const repeatCancelBtn = document.getElementById('repeatCancel')
  const repeatRemoveBtn = document.getElementById('repeatRemove')
  const repeatWeekdayWrap = document.getElementById('repeatWeekdayWrap')
  const repeatWeekdayInputs = repeatWeekdayWrap ? Array.from(repeatWeekdayWrap.querySelectorAll('input[type="checkbox"]')) : []
  const calendarDialogEl = document.getElementById('calendarDlg')
  const calendarForm = document.getElementById('calendarForm')
  const calendarListEl = document.getElementById('calendarList')
  const calendarSelectAllBtn = document.getElementById('calendarSelectAll')
  const calendarSelectNoneBtn = document.getElementById('calendarSelectNone')
  const calendarSelectionCountEl = document.getElementById('calendarSelectionCount')
  const calendarCancelBtn = document.getElementById('calendarCancel')
  const dispoView = document.getElementById('dispoView')
    const dispoListEl = document.getElementById('dispoList')
    const dispoBreadcrumbsEl = document.getElementById('dispoBreadcrumbs')
    const dispoAssignSummaryEl = document.getElementById('dispoAssignSummary')
  const dispoWeekInput = document.getElementById('dispoWeekInput')
  const dispoTitleInput = document.getElementById('dispoTitleInput')
  const dispoAddWeekBtn = document.getElementById('dispoAddWeek')
  const toolbar = document.getElementById('addForm')
  const filterbar = document.querySelector('.filterbar')
  const manageTeamBtn = document.getElementById('manageTeamBtn')
  const csvMenuBtn = document.getElementById('csvMenuBtn')
  const csvMenu = document.getElementById('csvMenu')
  const TIMELINE_ZOOMS = [
      { value:'weeks',   label:'KW',       min:8,  max:16, showDays:false, labelStep:7, unitDays:7 },
      { value:'compact', label:'Kompakt',  min:14, max:26, showDays:true,  labelStep:2, unitDays:1 },
      { value:'days',    label:'Tage',     min:20, max:40, showDays:true,  labelStep:1, unitDays:1 }
    ]

    const MONTH_NAMES = ['Januar','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember']
    const dispoNavigator = { year:null, month:null }

  if(timelineAssigneeSelect){
    timelineAssigneeSelect.addEventListener('change', () => {
      const rawValues = Array.from(timelineAssigneeSelect.selectedOptions).map(opt => opt.value)
      if(rawValues.includes('__all__')){
        state.timelineAssignees = []
      }else{
        const normalized = []
        const seen = new Set()
        rawValues.forEach(val => {
          if(val === ASSIGNEE_UNASSIGNED){
            if(!seen.has(ASSIGNEE_UNASSIGNED)){
              seen.add(ASSIGNEE_UNASSIGNED)
              normalized.push(ASSIGNEE_UNASSIGNED)
            }
            return
          }
          const original = (state.team || []).find(name => name.toLowerCase() === val.toLowerCase()) || val
          const key = original.toLowerCase()
          if(seen.has(key)) return
          seen.add(key)
          normalized.push(original)
        })
        state.timelineAssignees = normalized
      }
      renderTimelineFilters()
      renderTimeline()
    })
  }

  if(manageTeamBtn){
    manageTeamBtn.addEventListener('click', () => {
      const raw = prompt('Bearbeiter mit ; trennen', (state.team || []).join(';'))
      if(raw == null) return
      const list = uniqueCaseInsensitive(raw.split(';').map(s => s.trim()).filter(Boolean))
      pushHistory()
      state.team = list
      state.timelineAssignees = state.timelineAssignees.filter(name => list.includes(name))
      state.assigneeFilter = state.assigneeFilter.filter(name => name === ASSIGNEE_UNASSIGNED || list.includes(name))
      setDirty(true)
      render()
    })
  }

  if(repeatForm){
    repeatForm.addEventListener('submit', e => {
      e.preventDefault()
      if(!repeatTarget || !repeatTarget.todo){
        repeatTarget = null
        repeatDialogEl?.close()
        return
      }
      const todo = repeatTarget.todo
      const dueDateObj = parseIsoDate(todo.due)
      if(!dueDateObj){
        showToast('Bitte zuerst ein Fälligkeitsdatum setzen.')
        return
      }
      const freq = repeatFreqInput ? repeatFreqInput.value : ''
      pushHistory()
      if(!freq){
        todo.repeat = null
      }else{
        const intervalVal = repeatIntervalInput ? Math.floor(Number(repeatIntervalInput.value)) : 1
        const interval = Number.isFinite(intervalVal) && intervalVal > 0 ? intervalVal : 1
        const spec = { freq, interval }
        const countVal = repeatCountInput ? Math.floor(Number(repeatCountInput.value)) : NaN
        if(Number.isFinite(countVal) && countVal > 0) spec.count = countVal
        const startVal = repeatStartInput && repeatStartInput.value ? repeatStartInput.value : ''
        if(startVal){
          const parsedStart = parseIsoDate(startVal)
          if(parsedStart) spec.start = formatIsoDate(parsedStart)
        }else if(dueDateObj){
          spec.start = formatIsoDate(dueDateObj)
        }
        const endVal = repeatEndInput && repeatEndInput.value ? repeatEndInput.value : ''
        if(endVal){
          const parsedEnd = parseIsoDate(endVal)
          if(parsedEnd){
            const isoEnd = formatIsoDate(parsedEnd)
            spec.end = isoEnd
            spec.until = isoEnd
          }
        }
        if((freq === 'weekly' || freq === 'monthly') && repeatWeekdayInputs.length){
          const selectedDays = repeatWeekdayInputs
            .filter(cb => cb.checked)
            .map(cb => parseInt(cb.value, 10))
            .filter(num => Number.isFinite(num) && num >= 1 && num <= 7)
          if(!selectedDays.length){
            const dueIso = parseIsoDate(todo.due)
            if(dueIso){
              const isoDay = ((dueIso.getUTCDay() + 6) % 7) + 1
              selectedDays.push(isoDay)
            }
          }
          if(selectedDays.length){
            const unique = Array.from(new Set(selectedDays)).sort((a,b) => a - b)
            spec.days = unique
          }
        }
        todo.repeat = spec
      }
      setDirty(true)
      render()
      repeatDialogEl?.close()
      repeatTarget = null
    })
  }
  if(repeatCancelBtn){
    repeatCancelBtn.addEventListener('click', () => {
      repeatTarget = null
      repeatDialogEl?.close()
    })
  }
  if(repeatRemoveBtn){
    repeatRemoveBtn.addEventListener('click', () => {
      if(repeatTarget && repeatTarget.todo){
        pushHistory()
        repeatTarget.todo.repeat = null
        setDirty(true)
        render()
      }
      repeatTarget = null
      repeatDialogEl?.close()
    })
  }
  if(repeatDialogEl){
    repeatDialogEl.addEventListener('close', () => { repeatTarget = null })
  }

  if(repeatFreqInput){
    repeatFreqInput.addEventListener('change', () => {
      updateRepeatWeekdayVisibility(repeatFreqInput.value || '')
    })
  }

  if(calendarSelectAllBtn){
    calendarSelectAllBtn.addEventListener('click', () => {
      if(!calendarListEl) return
      calendarListEl.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true })
      updateCalendarSelectionCount()
    })
  }
  if(calendarSelectNoneBtn){
    calendarSelectNoneBtn.addEventListener('click', () => {
      if(!calendarListEl) return
      calendarListEl.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false })
      updateCalendarSelectionCount()
    })
  }
  if(calendarCancelBtn){
    calendarCancelBtn.addEventListener('click', () => {
      if(calendarDialogEl) calendarDialogEl.close()
    })
  }
  if(calendarListEl){
    calendarListEl.addEventListener('change', e => {
      if(e.target && e.target.matches('input[type="checkbox"]')) updateCalendarSelectionCount()
    })
  }
  if(calendarForm){
    calendarForm.addEventListener('submit', e => {
      e.preventDefault()
      if(!calendarDialogState.tasks.length){
        if(calendarDialogEl) calendarDialogEl.close()
        return
      }
      const selected = []
      if(calendarListEl){
        calendarListEl.querySelectorAll('input[type="checkbox"]:checked').forEach(input => {
          const idx = Number(input.dataset.index)
          if(Number.isFinite(idx) && calendarDialogState.tasks[idx]) selected.push(calendarDialogState.tasks[idx])
        })
      }
      if(!selected.length){
        showToast('Bitte mindestens ein To-Do auswählen.')
        return
      }
      exportTodosToICS(selected, calendarDialogState.fileName || 'todos.ics')
      if(calendarDialogEl) calendarDialogEl.close()
    })
  }
  if(calendarDialogEl){
    calendarDialogEl.addEventListener('close', () => {
      calendarDialogState.tasks = []
      if(calendarListEl) calendarListEl.innerHTML = ''
      updateCalendarSelectionCount()
    })
  }

  function updateRepeatIntervalUi(freq){
    if(repeatIntervalLabelText){
      let label = '(Anzahl)'
      switch(freq){
        case 'daily': label = '(Tage)'; break
        case 'weekly': label = '(Wochen)'; break
        case 'monthly': label = '(Monate)'; break
        case 'yearly': label = '(Jahre)'; break
        default: label = '(Anzahl)'; break
      }
      repeatIntervalLabelText.textContent = label
    }
    if(repeatIntervalInput){
      switch(freq){
        case 'weekly':
          repeatIntervalInput.placeholder = 'z. B. 2 für alle 2 Wochen'
          repeatIntervalInput.title = '1 = jede Woche, 2 = alle 2 Wochen'
          break
        case 'monthly':
          repeatIntervalInput.placeholder = 'z. B. 3 für alle 3 Monate (4‑Wochen)'
          repeatIntervalInput.title = '1 = alle 4 Wochen, 3 = alle 12 Wochen'
          break
        case 'daily':
          repeatIntervalInput.placeholder = 'z. B. 2 für jeden 2. Tag'
          repeatIntervalInput.title = 'Anzahl der Tage zwischen den Terminen'
          break
        case 'yearly':
          repeatIntervalInput.placeholder = 'z. B. 1 für jedes Jahr'
          repeatIntervalInput.title = 'Anzahl der Jahre zwischen den Terminen'
          break
        default:
          repeatIntervalInput.placeholder = ''
          repeatIntervalInput.title = ''
          break
      }
    }
  }

  function updateRepeatWeekdayVisibility(freq){
    if(repeatWeekdayWrap){
      repeatWeekdayWrap.classList.toggle('show', freq === 'weekly' || freq === 'monthly')
    }
    updateRepeatIntervalUi(freq)
  }

  function scheduleVirtualRerender(){
    if(!virtualizationActive || state.view !== 'table') return
    const active = document.activeElement
    if(active && tableView && tableView.contains(active)) return
    if(virtualScrollScheduled) return
    virtualScrollScheduled = true
    requestAnimationFrame(() => {
      virtualScrollScheduled = false
      if(virtualizationActive && state.view === 'table') render()
    })
  }
  window.addEventListener('scroll', scheduleVirtualRerender, { passive:true })
  window.addEventListener('resize', scheduleVirtualRerender)

  if(timelineZoomLabelsEl){
    timelineZoomLabelsEl.innerHTML = ''
    TIMELINE_ZOOMS.forEach(z => {
      const span = document.createElement('span')
      span.textContent = z.label
      timelineZoomLabelsEl.appendChild(span)
    })
  }
  if(timelineZoomInput){
    timelineZoomInput.max = String(Math.max(0, TIMELINE_ZOOMS.length - 1))
  }

  function updateTimelineZoomIndicator(value){
    const idx = TIMELINE_ZOOMS.findIndex(z => z.value === (value || state.timelineZoom))
    const activeIdx = idx >= 0 ? idx : Math.max(0, TIMELINE_ZOOMS.length - 1)
    if(timelineZoomInput){
      timelineZoomInput.value = String(activeIdx)
    }
    if(timelineZoomLabelsEl){
      Array.from(timelineZoomLabelsEl.children).forEach((node, i) => {
        node.classList.toggle('active', i === activeIdx)
      })
    }
  }

  function clampPct(n){ n = Number.isFinite(+n) ? +n : 0; return Math.max(0, Math.min(100, Math.round(n))) }
  function uid(){ return Math.random().toString(36).slice(2,9) }
  function uniqueCaseInsensitive(list){
    const seen = new Map()
    const out = []
    list.forEach(item => {
      if(typeof item !== 'string') return
      const trimmed = item.trim()
      if(!trimmed) return
      const key = trimmed.toLowerCase()
      if(!seen.has(key)){
        seen.set(key, trimmed)
        out.push(trimmed)
      }
    })
    return out
  }
  function buildAssigneeMatcher(){
    const values = Array.isArray(state.assigneeFilter) ? state.assigneeFilter : []
    const includeUnassigned = values.includes(ASSIGNEE_UNASSIGNED)
    const allowed = new Set(values.filter(v => v && v !== ASSIGNEE_UNASSIGNED).map(v => v.toLowerCase()))
    const teamLookup = new Set((state.team || []).map(name => name.toLowerCase()))
    const active = includeUnassigned || allowed.size > 0
    return {
      active,
      includeUnassigned,
      matches(assignee){
        if(!active) return true
        const raw = typeof assignee === 'string' ? assignee.trim() : ''
        if(raw){
          const parts = raw.split(/[;,]/).map(part => part.trim()).filter(Boolean)
          if(!parts.length) return includeUnassigned
          return parts.some(part => {
            const key = part.toLowerCase()
            return teamLookup.has(key) && allowed.has(key)
          })
        }
        return includeUnassigned
      }
    }
  }
  function describeRepeat(spec){
    if(!spec || typeof spec !== 'object' || !spec.freq) return ''
    const freq = String(spec.freq).toLowerCase()
    const intervalVal = Number.isFinite(Number(spec.interval)) && Number(spec.interval) > 0 ? Math.floor(Number(spec.interval)) : 1
    const freqLabelMap = { daily:'Täglich', weekly:'Wöchentlich', monthly:'Monatlich', yearly:'Jährlich' }
    const baseLabel = freqLabelMap[freq] || ''
    const parts = []
    if(baseLabel){
      parts.push(intervalVal > 1 ? `${intervalVal}× ${baseLabel}` : baseLabel)
    }
    if(freq === 'weekly' && Array.isArray(spec.days) && spec.days.length){
      const labels = Array.from(new Set(spec.days
        .map(val => parseInt(val, 10))
        .filter(num => Number.isFinite(num) && num >= 1 && num <= 7)
      ))
        .sort((a,b)=>a-b)
        .map(num => ({1:'Mo',2:'Di',3:'Mi',4:'Do',5:'Fr',6:'Sa',7:'So'})[num] || String(num))
      if(labels.length) parts.push(labels.join(', '))
    }
    if(Number.isFinite(Number(spec.count)) && Number(spec.count) > 0){
      const count = Math.floor(Number(spec.count))
      parts.push(`${count} Termin${count === 1 ? '' : 'e'}`)
    }
    const startDate = spec.start && parseIsoDate(spec.start)
    if(startDate){
      parts.push(`ab ${formatGermanDate(startDate)}`)
    }
    const endDate = (spec.end && parseIsoDate(spec.end)) || (spec.until && parseIsoDate(spec.until))
    if(endDate){
      parts.push(`bis ${formatGermanDate(endDate)}`)
    }
    return parts.join(' · ') || 'Wiederholung aktiv'
  }
  function describeRepeatShort(spec){
    if(!spec || !spec.freq) return ''
    const freq = String(spec.freq)
    const baseLabels = { daily:'Täglich', weekly:'Wöchentlich', monthly:'Monatlich', yearly:'Jährlich' }
    let text = baseLabels[freq] || 'Wiederholung'
    const intervalVal = Number.isFinite(Number(spec.interval)) && Number(spec.interval) > 1
      ? Math.floor(Number(spec.interval))
      : 1
    if(intervalVal > 1){
      const unitLabels = { daily:'Tage', weekly:'Wochen', monthly:'Monate', yearly:'Jahre' }
      const unit = unitLabels[freq] || 'Intervalle'
      text += ` alle ${intervalVal} ${unit}`
    }
    if(freq === 'weekly' && Array.isArray(spec.days) && spec.days.length){
      const dayMap = {1:'Mo',2:'Di',3:'Mi',4:'Do',5:'Fr',6:'Sa',7:'So'}
      const labels = Array.from(new Set(spec.days
        .map(val => parseInt(val, 10))
        .filter(num => Number.isFinite(num) && num >= 1 && num <= 7)
      ))
        .sort((a,b)=>a-b)
        .map(num => dayMap[num] || String(num))
      if(labels.length){
        text += ` (${labels.join(', ')})`
      }
    }
    return text
  }
  function todayYMD(){ return new Date().toISOString().slice(0,10) }
  function progressOf(p){
    const todos = Array.isArray(p.todos) ? p.todos : []
    let total = 0
    let done = 0
    todos.forEach(todo => {
      total += 1
      if(todo && todo.done) done += 1
      const subtasks = Array.isArray(todo?.subtasks) ? todo.subtasks : []
      total += subtasks.length
      subtasks.forEach(sub => { if(sub && sub.done) done += 1 })
    })
    const emptyComplete = !!p.emptyDone && total === 0
    let pct
    let status
    if(total === 0){
      pct = emptyComplete ? 100 : 0
      status = emptyComplete ? 'done' : 'open'
    }else{
      pct = Math.round((done/total)*100)
      status = done === 0 ? 'open' : done === total ? 'done' : 'partial'
    }
    return { total, done, pct, status, emptyComplete }
  }
  function orderKeyForTab(tab){
    return (tab && tab !== 'Alle') ? tab : 'Alle'
  }
  function projectIdsForTab(tab){
    const key = orderKeyForTab(tab)
    return (state.projects || [])
      .filter(p => key === 'Alle' ? true : (p.tab || 'Alle') === key)
      .map(p => p.id)
      .filter(Boolean)
  }
  function getManualOrderArray(tab){
    const key = orderKeyForTab(tab)
    if(key === 'Alle'){
      if(!Array.isArray(state.order)) state.order = []
      return state.order
    }
    if(!state.orderByTab || typeof state.orderByTab !== 'object') state.orderByTab = {}
    if(!Array.isArray(state.orderByTab[key])) state.orderByTab[key] = []
    const ids = projectIdsForTab(key)
    const allowed = new Set(ids)
    const unique = new Set()
    state.orderByTab[key] = state.orderByTab[key].filter(id => {
      if(!allowed.has(id) || unique.has(id)) return false
      unique.add(id)
      return true
    })
    ids.forEach(id => {
      if(!unique.has(id)){
        state.orderByTab[key].push(id)
        unique.add(id)
      }
    })
    return state.orderByTab[key]
  }
  function ensureManualOrder(idList, tab){
    const order = getManualOrderArray(tab)
    const key = orderKeyForTab(tab)
    const validIds = new Set(projectIdsForTab(key))
    const seen = new Set()
    for(let i = order.length - 1; i >= 0; i--){
      const id = order[i]
      if(!validIds.has(id) || seen.has(id)) order.splice(i,1)
      else seen.add(id)
    }
    const source = Array.isArray(idList) && idList.length ? idList : Array.from(validIds)
    source.forEach(id => {
      if(validIds.has(id) && !seen.has(id)){
        order.push(id)
        seen.add(id)
      }
    })
    if(key === 'Alle'){
      state.order = order
      if(Array.isArray(state.orderByTab['Alle'])) state.orderByTab['Alle'] = order.slice()
    }else{
      state.orderByTab[key] = order
    }
    return order
  }
  function getDragProjectId(evt){
    if(!evt || !evt.dataTransfer) return draggingProjectId
    const types = evt.dataTransfer.types || []
    let id = ''
    if(types.includes && types.includes('text/proj')){
      id = evt.dataTransfer.getData('text/proj')
    }
    if(!id){
      try{ id = evt.dataTransfer.getData('text/plain') }catch(err){ /* ignore */ }
    }
    if(!id){ id = draggingProjectId }
    return id || ''
  }
  function isoWeekOf(date){
    const target = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()))
    const day = target.getUTCDay() || 7
    target.setUTCDate(target.getUTCDate() + 4 - day)
    const yearStart = new Date(Date.UTC(target.getUTCFullYear(), 0, 1))
    const weekNo = Math.ceil(((target - yearStart) / DAY_MS + 1) / 7)
    return { week: weekNo, year: target.getUTCFullYear() }
  }
  function parseWeekValue(value){
    const match = /^\s*(\d{4})-W(\d{1,2})\s*$/.exec(value || '')
    if(match){
      const year = parseInt(match[1], 10)
      let week = parseInt(match[2], 10)
      if(Number.isFinite(year) && Number.isFinite(week)){
        week = Math.max(1, Math.min(53, week))
        return { year, week }
      }
    }
    return isoWeekOf(new Date())
  }
  function formatWeekValue(year, week){
    return `${year}-W${String(week).padStart(2,'0')}`
  }
  function weekRange(year, week){
    const simple = new Date(Date.UTC(year, 0, 4))
    const day = (simple.getUTCDay() + 6) % 7
    simple.setUTCDate(simple.getUTCDate() - day + (week - 1) * 7)
    const start = new Date(simple)
    const end = new Date(simple)
    end.setUTCDate(start.getUTCDate() + 6)
    return { start, end }
  }
  function formatWeekRange(year, week){
    const { start, end } = weekRange(year, week)
    const fmt = (d) => `${String(d.getUTCDate()).padStart(2,'0')}.${String(d.getUTCMonth()+1).padStart(2,'0')}.`
    return `${fmt(start)} – ${fmt(end)}${end.getUTCFullYear()}`
  }
  function ensureDispo(){ if(!Array.isArray(state.dispo)) state.dispo = [] }
  function projectLabel(project){
    if(!project) return ''
    const parts = []
    if(project.number) parts.push(project.number)
    if(project.name) parts.push(project.name)
    return parts.join(' · ')
  }
  function cleanupDispoItems(project, todoText){
    if(!project) return
    ensureDispo()
    const label = projectLabel(project)
    if(!label) return
    let changed = false
    state.dispo.forEach(entry => {
      if(!entry || !Array.isArray(entry.items)) return
      const nextItems = entry.items.filter(item => {
        if(!item || item.project !== label) return true
        if(todoText){
          return item.todo !== todoText
        }
        return false
      })
      if(nextItems.length !== entry.items.length){
        entry.items = nextItems
        changed = true
      }
    })
    if(changed) setDirty(true)
  }

  // Fällig-Badge
  function dueBadge(dateYMD){
    if(!dateYMD) return null;
    const d = new Date(dateYMD + 'T00:00:00');
    const t = new Date(); t.setHours(0,0,0,0);
    const diff = Math.round((d - t) / 86400000);
    // Hilfsfunktion: y-m-d → dd.mm.yyyy
    function formatGerman(ymd){
      const parts = (ymd||'').split('-');
      if(parts.length === 3){ return `${parts[2]}.${parts[1]}.${parts[0]}`; }
      return ymd;
    }
    if(diff < 0) return { cls:'b-red', label:'Überfällig' };
    if(diff === 0) return { cls:'b-amber', label:'Heute' };
    if(diff <= 3) return { cls:'b-yellow', label:`In ${diff} Tag${diff===1?'':'en'}` };
    return { cls:'b-green', label:`Am ${formatGerman(dateYMD)}` };
  }

  // ===== Eingabehilfe: Blur bei Enter =====
  // Einige Editierfelder (contenteditable und Inputs) sollen beim Drücken von Enter die Eingabe abschließen,
  // ohne eine neue Zeile zu erzeugen. Diese Hilfsfunktionen fangen die Enter‑Taste ab,
  // verhindern den Standard und entfernen den Fokus vom aktuellen Element.
  function blurOnEnter(e){
    if(e && e.key === 'Enter'){
      e.preventDefault();
      if(e.target && typeof e.target.blur === 'function') e.target.blur();
      // Selektion entfernen, damit Cursor ausgeblendet wird
      if(window.getSelection){
        const sel = window.getSelection();
        if(sel) sel.removeAllRanges();
      }
    }
  }
  function blurOnEnterInput(e){
    if(e && e.key === 'Enter'){
      e.preventDefault();
      if(e.target && typeof e.target.blur === 'function') e.target.blur();
    }
  }

  function applyFilters(list){
    const f = state.filters
    let res = [...list]
    if(state.currentTab && state.currentTab !== 'Alle'){ res = res.filter(p => (p.tab || 'Alle') === state.currentTab) }
    res = res.filter(p => {
      const st = progressOf(p)
      if(f.status === 'all') return true
      return st.status === f.status
    })
    if(f.q && f.q.trim()){
      const needle = f.q.trim().toLowerCase()
      res = res.filter(p => (p.number||'').toLowerCase().includes(needle) || (p.name||'').toLowerCase().includes(needle))
    }
    const matcher = buildAssigneeMatcher()
    if(matcher.active){
      res = res.filter(project => {
        const todos = Array.isArray(project.todos) ? project.todos : []
        for(const todo of todos){
          if(!todo) continue
          if(matcher.matches(todo.assignee)) return true
          const subtasks = Array.isArray(todo.subtasks) ? todo.subtasks : []
          if(subtasks.some(sub => sub && matcher.matches(sub.assignee))) return true
        }
        return false
      })
    }
    const activeTab = state.currentTab || 'Alle'
    const cmpMap = {
      date_desc: (a,b) => (b.date||'').localeCompare(a.date||''),
      date_asc:  (a,b) => (a.date||'').localeCompare(b.date||''),
      name_asc:  (a,b) => (a.name||'').localeCompare(b.name||''),
      name_desc: (a,b) => (b.name||'').localeCompare(a.name||''),
      nr_asc:    (a,b) => (a.number||'').localeCompare(b.number||'', undefined, {numeric:true}),
      nr_desc:   (a,b) => (b.number||'').localeCompare(a.number||'', undefined, {numeric:true}),
      prog_desc: (a,b) => progressOf(b).pct - progressOf(a).pct,
      prog_asc:  (a,b) => progressOf(a).pct - progressOf(b).pct,
      manual:    (a,b) => {
        const order = getManualOrderArray(activeTab)
        const ia = order.indexOf(a.id)
        const ib = order.indexOf(b.id)
        return (ia < 0 ? Number.MAX_SAFE_INTEGER : ia) - (ib < 0 ? Number.MAX_SAFE_INTEGER : ib)
      }
    }
    if(f.sort !== 'manual'){
      res.sort(cmpMap[f.sort] || cmpMap.date_desc)
    }
    else{
      ensureManualOrder(res.map(p => p.id), activeTab)
      res.sort(cmpMap.manual)
    }
    return res
  }

  function ensureTabs(){
    if(!Array.isArray(state.tabs)) state.tabs = []
    if(!Array.isArray(state.tabGroups)) state.tabGroups = []
    if(!Array.isArray(state.tabOrder)) state.tabOrder = []
    if(!state.tabMeta || typeof state.tabMeta !== 'object') state.tabMeta = {}

    const fromProjects = new Set((state.projects || []).map(p => (p.tab || '').trim()).filter(name => name && name !== 'Alle'))
    const cleaned = state.tabs
      .filter(name => typeof name === 'string')
      .map(name => name.trim())
      .filter(name => name && name !== 'Alle')
    const unique = Array.from(new Set([...cleaned, ...fromProjects]))

    unique.forEach(name => {
      if(!state.tabMeta[name]) state.tabMeta[name] = {}
      if(typeof state.tabMeta[name].groupId !== 'string') state.tabMeta[name].groupId = state.tabMeta[name].groupId || ''
      if(typeof state.tabMeta[name].color !== 'string') state.tabMeta[name].color = state.tabMeta[name].color || ''
    })
    Object.keys(state.tabMeta).forEach(name => {
      if(name === 'Alle') return
      if(!unique.includes(name)) delete state.tabMeta[name]
    })

    const groupIds = new Set()
    state.tabGroups = state.tabGroups
      .filter(g => g && typeof g.name === 'string')
      .map(g => {
        const id = g.id || ('grp_' + uid())
        groupIds.add(id)
        return {
          id,
          name: (g.name || '').trim() || 'Gruppe',
          color: typeof g.color === 'string' ? g.color : '',
          tabs: Array.isArray(g.tabs) ? g.tabs.filter(t => unique.includes(t)) : []
        }
      })
    state.tabGroups.forEach(group => {
      const seen = new Set()
      group.tabs = group.tabs.filter(name => {
        if(!unique.includes(name) || seen.has(name)) return false
        seen.add(name)
        return true
      })
      group.tabs.forEach(name => {
        state.tabMeta[name] = state.tabMeta[name] || {}
        state.tabMeta[name].groupId = group.id
      })
    })

    unique.forEach(name => {
      const meta = state.tabMeta[name]
      if(meta && meta.groupId && !groupIds.has(meta.groupId)) meta.groupId = ''
    })

    const orderSet = new Set()
    state.tabOrder = state.tabOrder.filter(entry => {
      if(typeof entry !== 'string') return false
      if(entry.startsWith('tab:')){
        const name = entry.slice(4)
        if(name === 'Alle' || !unique.includes(name)) return false
        const meta = state.tabMeta[name]
        if(meta && meta.groupId) return false
        if(orderSet.has(entry)) return false
        orderSet.add(entry)
        return true
      }
      if(entry.startsWith('group:')){
        const id = entry.slice(6)
        if(!groupIds.has(id) || orderSet.has(entry)) return false
        orderSet.add(entry)
        return true
      }
      return false
    })

    const topTabs = unique.filter(name => !(state.tabMeta[name] && state.tabMeta[name].groupId))
    topTabs.forEach(name => {
      const key = 'tab:' + name
      if(!orderSet.has(key)){
        state.tabOrder.push(key)
        orderSet.add(key)
      }
    })
    state.tabGroups.forEach(group => {
      const key = 'group:' + group.id
      if(!orderSet.has(key)){
        state.tabOrder.push(key)
        orderSet.add(key)
      }
    })

    const ordered = []
    const groupsById = new Map(state.tabGroups.map(g => [g.id, g]))
    state.tabOrder.forEach(entry => {
      if(entry.startsWith('tab:')){
        const name = entry.slice(4)
        if(unique.includes(name) && !ordered.includes(name)) ordered.push(name)
      }else if(entry.startsWith('group:')){
        const group = groupsById.get(entry.slice(6))
        if(group){
          group.tabs.forEach(name => {
            if(unique.includes(name) && !ordered.includes(name)) ordered.push(name)
          })
        }
      }
    })
    unique.forEach(name => { if(!ordered.includes(name)) ordered.push(name) })
    state.tabs = ['Alle', ...ordered]

    if(!state.currentTab || !state.tabs.includes(state.currentTab)) state.currentTab = 'Alle'
    if(!state.timelineTab || !state.tabs.includes(state.timelineTab)) state.timelineTab = 'Alle'
  }
  function pushHistory(){ history.push(snapshot()); if(history.length>400) history.shift(); future.length=0 }
  function undo(){ if(!history.length) return; future.push(snapshot()); state = history.pop(); setDirty(true); render() }
  function redo(){ if(!future.length) return; history.push(snapshot()); state = future.pop(); setDirty(true); render() }

  // ===== Tabs render + Reorder =====
  function renderTabs(){
    ensureTabs()
    closeTabMenu()
    closeAllGroupDropdowns()
    if(!tabsEl) return

    const groupsById = new Map(state.tabGroups.map(g => [g.id, g]))
    const topOrder = state.tabOrder.filter(entry => entry.startsWith('tab:')).map(entry => entry.slice(4))
    const firstTopTab = topOrder.length ? topOrder[0] : null

    const previousScrollLeft = tabsScroll ? tabsScroll.scrollLeft : 0

    tabsEl.innerHTML = ''
    const fragment = document.createDocumentFragment()
    const renderedTabs = new Set()
    const renderedGroups = new Set()

    const appendTab = (name, opts = {}) => {
      if(renderedTabs.has(name)) return
      fragment.appendChild(createTabElement(name, opts))
      renderedTabs.add(name)
    }
    const appendGroup = group => {
      if(!group || renderedGroups.has(group.id)) return
      if(Array.isArray(group.tabs)) group.tabs.forEach(name => renderedTabs.add(name))
      fragment.appendChild(createGroupElement(group))
      renderedGroups.add(group.id)
    }

    appendTab('Alle', { allowMenu:false, draggable:false, firstTopTab })

    state.tabOrder.forEach(entry => {
      if(entry.startsWith('tab:')){
        const name = entry.slice(4)
        if(name === 'Alle') return
        appendTab(name, { firstTopTab })
      }else if(entry.startsWith('group:')){
        const group = groupsById.get(entry.slice(6))
        if(group) appendGroup(group)
      }
    })

    state.tabGroups.forEach(group => appendGroup(group))
    state.tabs.forEach(name => {
      if(name === 'Alle') return
      appendTab(name, { firstTopTab })
    })

    tabsEl.appendChild(fragment)

    const addBtn = document.createElement('button')
    addBtn.type = 'button'
    addBtn.className = 'tab-add'
    addBtn.innerHTML = '<span class="ms">add</span>'
    addBtn.title = 'Tab oder Gruppe hinzufügen'
    addBtn.addEventListener('click', e => {
      e.stopPropagation()
      openTabMenu(addBtn, [
        { label:'Neuer Tab', icon:'add', action: () => createTab() },
        { label:'Neue Gruppe', icon:'folder', action: () => createGroup() }
      ])
    })
    tabsEl.appendChild(addBtn)

    if(tabsScroll){
      const maxScroll = Math.max(0, tabsScroll.scrollWidth - tabsScroll.clientWidth)
      tabsScroll.scrollLeft = Math.min(previousScrollLeft, maxScroll)
      requestAnimationFrame(() => updateTabsOverflow())
    }

    // Bulk Move Ziel
    if(bulkTarget){
      const opts = state.tabs.map(t => {
        const opt = document.createElement('option')
        opt.value = t
        opt.textContent = t
        return opt
      })
      if(typeof bulkTarget.replaceChildren === 'function') bulkTarget.replaceChildren(...opts)
      else {
        bulkTarget.innerHTML = ''
        opts.forEach(opt => bulkTarget.appendChild(opt))
      }
    }
    if(timelineTabSelect){
      const current = state.timelineTab && state.tabs.includes(state.timelineTab) ? state.timelineTab : 'Alle'
      state.timelineTab = current
      const opts = state.tabs.map(tabName => {
        const opt = document.createElement('option')
        opt.value = tabName
        opt.textContent = tabName
        return opt
      })
      if(typeof timelineTabSelect.replaceChildren === 'function') timelineTabSelect.replaceChildren(...opts)
      else {
        timelineTabSelect.innerHTML = ''
        opts.forEach(opt => timelineTabSelect.appendChild(opt))
      }
      timelineTabSelect.value = current
    }

    const addTabSelect = document.getElementById('inTab')
    if(addTabSelect){
      const previous = addTabSelect.value
      addTabSelect.innerHTML = ''
      const placeholder = document.createElement('option')
      placeholder.value = ''
      placeholder.textContent = 'Tab wählen'
      addTabSelect.appendChild(placeholder)
      state.tabs.forEach(name => {
        const opt = document.createElement('option')
        opt.value = name
        opt.textContent = name
        addTabSelect.appendChild(opt)
      })
      const preferred = state.currentTab && state.tabs.includes(state.currentTab) ? state.currentTab : 'Alle'
      if(previous && state.tabs.includes(previous)) addTabSelect.value = previous
      else addTabSelect.value = preferred
    }

    function createTabMenuButton(name, firstTop){
      const btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'tab-more'
      const icon = document.createElement('span')
      icon.className = 'ms'
      icon.textContent = 'more_vert'
      btn.appendChild(icon)
      btn.addEventListener('click', e => {
        e.stopPropagation()
        const meta = state.tabMeta[name] || {}
        const currentGroup = meta.groupId || ''
        const items = [
          { label:'Umbenennen', icon:'edit', action: () => renameTabPrompt(name) },
          {
            label:'Füllfarbe ändern',
            icon:'palette',
            action: ctx => changeTabColor(name, ctx && ctx.anchor ? ctx.anchor : btn),
            keepOpen:true
          }
        ]
        if(currentGroup){
          items.push({ label:'Aus Gruppe lösen', icon:'tab_unselected', action: () => {
            pushHistory()
            const before = firstTop && firstTop !== name ? firstTop : null
            moveTabBefore(name, before)
            setDirty(true); render()
          } })
        }
        const availableGroups = state.tabGroups.filter(group => group.id !== currentGroup)
        if(availableGroups.length){
          items.push({ type:'divider' })
          items.push({
            label:'Zu Gruppe hinzufügen',
            icon:'folder',
            submenu: availableGroups.map(group => ({
              label:`${group.name}`,
              icon:'folder',
              action: () => { pushHistory(); moveTabToGroup(name, group.id); setDirty(true); render() }
            }))
          })
        }
        items.push({ type:'divider' })
        items.push({ label:'Löschen', icon:'delete', action: () => deleteTabByName(name) })
        openTabMenu(btn, items)
      })
      return btn
    }

    function createTabElement(name, opts = {}){
      const inDropdown = !!opts.inDropdown
      const allowMenu = opts.allowMenu !== false
      const draggable = opts.draggable !== false && name !== 'Alle'
      const groupId = opts.groupId || (state.tabMeta[name] && state.tabMeta[name].groupId) || ''
      const firstTop = opts.firstTopTab || firstTopTab
      const onActivated = typeof opts.onActivated === 'function' ? opts.onActivated : null
      const onDropped = typeof opts.onDrop === 'function' ? opts.onDrop : null

      const el = document.createElement('div')
      el.className = 'tab' + (inDropdown ? ' in-dropdown' : '')
      if(state.currentTab === name) el.classList.add('active')
      el.dataset.name = name
      el.setAttribute('role', 'button')
      el.tabIndex = 0
      if(draggable) el.draggable = true

      const label = document.createElement('span')
      label.className = 'name'
      label.textContent = name
      el.appendChild(label)

      if(allowMenu && name !== 'Alle'){
        el.appendChild(createTabMenuButton(name, firstTop))
      }

      const color = state.tabMeta[name] && state.tabMeta[name].color
      if(color){
        el.style.setProperty('--tab-bg', color)
        el.style.setProperty('--tab-fg', contrastColor(color))
      }else{
        el.style.removeProperty('--tab-bg')
        el.style.removeProperty('--tab-fg')
      }

      const activate = () => {
        if(state.currentTab === name) return
        if(onActivated) onActivated()
        state.currentTab = name
        if(state.view === 'timeline') state.timelineTab = name
        render()
      }

      el.addEventListener('click', ev => {
        if(ev.target.closest('.tab-more')) return
        activate()
      })
      el.addEventListener('keydown', ev => {
        if(ev.key === 'Enter' || ev.key === ' '){
          ev.preventDefault()
          if(ev.target.closest('.tab-more')) return
          activate()
        }
      })

      if(draggable){
        el.addEventListener('dragstart', e => {
          draggingTabName = name
          el.classList.add('dragging')
          e.dataTransfer.setData('text/tab', name)
          e.dataTransfer.effectAllowed = 'move'
        })
        el.addEventListener('dragend', () => {
          draggingTabName = null
          el.classList.remove('dragging')
        })
      }

      el.addEventListener('dragover', e => {
        const projId = getDragProjectId(e)
        const hasTab = draggingTabName || e.dataTransfer.getData('text/tab')
        if(!projId && !hasTab) return
        e.preventDefault()
        el.classList.add('drop-hint')
      })
      el.addEventListener('dragleave', () => el.classList.remove('drop-hint'))
      el.addEventListener('drop', e => {
        e.preventDefault()
        el.classList.remove('drop-hint')
        closeTabMenu()
        const droppedTab = e.dataTransfer.getData('text/tab') || draggingTabName
        const projId = getDragProjectId(e)
        if(droppedTab){
          if(droppedTab !== name){
            if(onDropped) onDropped()
            pushHistory()
            if(inDropdown && groupId){
              moveTabWithinGroup(droppedTab, groupId, name)
            }else if(name === 'Alle'){
              const before = firstTop && firstTop !== droppedTab ? firstTop : null
              moveTabBefore(droppedTab, before)
            }else{
              moveTabBefore(droppedTab, name)
            }
            setDirty(true); render()
          }
        }else if(projId){
          if(onDropped) onDropped()
          pushHistory()
          assignProjectToTab(projId, name)
          setDirty(true); render()
        }
        draggingProjectId = null
      })

      return el
    }

    function createGroupElement(group){
      const container = document.createElement('div')
      container.className = 'tab-group'

      const header = document.createElement('div')
      header.className = 'tab is-group'
      header.dataset.groupId = group.id
      header.setAttribute('role', 'button')
      header.tabIndex = 0
      if(group.tabs && group.tabs.includes(state.currentTab)) header.classList.add('active')

      const nameSpan = document.createElement('span')
      nameSpan.className = 'name'
      nameSpan.textContent = group.name
      header.appendChild(nameSpan)

      const toggle = document.createElement('button')
      toggle.type = 'button'
      toggle.className = 'tab-group-toggle'
      const icon = document.createElement('span')
      icon.className = 'ms'
      icon.textContent = 'more_vert'
      toggle.appendChild(icon)
      toggle.addEventListener('click', e => {
        e.stopPropagation()
        openTabMenu(toggle, [
          { label:'Gruppe umbenennen', icon:'edit', action: () => renameGroupPrompt(group) },
          { label:'Füllfarbe ändern', icon:'palette', action: ctx => changeGroupColor(group, ctx && ctx.anchor ? ctx.anchor : toggle), keepOpen:true },
          { type:'divider' },
          { label:'Gruppe löschen', icon:'delete', action: () => deleteGroup(group) }
        ])
      })
      header.appendChild(toggle)

      if(group.color){
        header.style.setProperty('--tab-bg', group.color)
        header.style.setProperty('--tab-fg', contrastColor(group.color))
      }else{
        header.style.removeProperty('--tab-bg')
        header.style.removeProperty('--tab-fg')
      }

      container.appendChild(header)

      const dropdown = document.createElement('div')
      dropdown.className = 'tab-dropdown'
      dropdown.__home = container
      container.appendChild(dropdown)

      const syncExpanded = () => header.setAttribute('aria-expanded', container.classList.contains('open') ? 'true' : 'false')
      let hideTimer = null
      let floatingActive = false
      let showDropZoneFn = () => {}
      let hideDropZoneFn = () => {}
      const repositionDropdown = () => {
        if(container.classList.contains('open')){
          positionGroupDropdown(header, dropdown)
        }
      }
      const activateFloating = () => {
        if(floatingActive) return
        floatingActive = true
        window.addEventListener('resize', repositionDropdown, true)
        window.addEventListener('scroll', repositionDropdown, true)
      }
      const deactivateFloating = () => {
        if(!floatingActive) return
        floatingActive = false
        window.removeEventListener('resize', repositionDropdown, true)
        window.removeEventListener('scroll', repositionDropdown, true)
      }
      const openDropdown = () => {
        clearTimeout(hideTimer)
        hideTimer = null
        container.classList.add('open')
        syncExpanded()
        positionGroupDropdown(header, dropdown)
        activateFloating()
        openTabGroupDropdowns.add(dropdown)
        hideDropZoneFn()
      }
      const closeDropdownNow = () => {
        clearTimeout(hideTimer)
        hideTimer = null
        container.classList.remove('open')
        syncExpanded()
        deactivateFloating()
        hideDropZoneFn()
        resetGroupDropdown(dropdown, container)
        openTabGroupDropdowns.delete(dropdown)
      }
      dropdown.__close = closeDropdownNow
      const cancelClose = () => { clearTimeout(hideTimer); hideTimer = null }
      const requestClose = () => {
        cancelClose()
        hideTimer = setTimeout(closeDropdownNow, 220)
      }
      const withinSurface = target => {
        if(!target) return false
        return target === container || target === header || container.contains(target) ||
          target === dropdown || dropdown.contains(target)
      }
      container.addEventListener('pointerenter', () => {
        cancelClose()
        openDropdown()
      })
      container.addEventListener('pointerleave', e => {
        if(withinSurface(e.relatedTarget) || draggingTabName) return
        requestClose()
      })
      dropdown.addEventListener('pointerenter', cancelClose)
      dropdown.addEventListener('pointerleave', e => {
        if(withinSurface(e.relatedTarget) || draggingTabName) return
        requestClose()
      })
      header.addEventListener('click', e => {
        if(e.target.closest('.tab-group-toggle')) return
        if(container.classList.contains('open')) closeDropdownNow()
        else openDropdown()
      })
      header.addEventListener('keydown', e => {
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault()
          if(container.classList.contains('open')) closeDropdownNow()
          else openDropdown()
        }
      })
      syncExpanded()

      if(group.tabs && group.tabs.length){
        group.tabs.forEach(tabName => dropdown.appendChild(createTabElement(tabName, { inDropdown:true, groupId:group.id, firstTopTab, onActivated: closeDropdownNow, onDrop: closeDropdownNow })))
      }

      const dropZone = document.createElement('div')
      dropZone.className = 'group-drop-zone'
      const showDropZone = () => {
        dropZone.textContent = 'Hier ablegen'
        dropZone.classList.add('show')
      }
      const hideDropZone = () => {
        dropZone.textContent = ''
        dropZone.classList.remove('show', 'drag-over')
      }
      showDropZoneFn = showDropZone
      hideDropZoneFn = hideDropZone
      dropZone.addEventListener('dragover', e => {
        const tabName = e.dataTransfer.getData('text/tab') || draggingTabName
        if(!tabName) return
        e.preventDefault()
        showDropZone()
        dropZone.classList.add('drag-over')
      })
      dropZone.addEventListener('dragleave', () => hideDropZone())
      dropZone.addEventListener('drop', e => {
        e.preventDefault()
        hideDropZone()
        closeTabMenu()
        closeDropdownNow()
        const tabName = e.dataTransfer.getData('text/tab') || draggingTabName
        if(tabName){
          pushHistory()
          moveTabToGroup(tabName, group.id)
          setDirty(true); render()
        }
        draggingTabName = null
      })
      dropdown.appendChild(dropZone)
      closeDropdownNow()

      header.draggable = true
      header.addEventListener('dragstart', e => {
        draggingGroupId = group.id
        header.classList.add('dragging')
        e.dataTransfer.setData('text/tab-group', group.id)
        e.dataTransfer.effectAllowed = 'move'
      })
      header.addEventListener('dragend', () => {
        draggingGroupId = null
        header.classList.remove('dragging')
      })
      header.addEventListener('dragover', e => {
        const tabName = e.dataTransfer.getData('text/tab') || draggingTabName
        const groupMove = e.dataTransfer.getData('text/tab-group') || draggingGroupId
        if(tabName || (groupMove && groupMove !== group.id)){
          e.preventDefault()
          header.classList.add('drop-hint')
        }
      })
      header.addEventListener('dragleave', () => header.classList.remove('drop-hint'))
      header.addEventListener('drop', e => {
        e.preventDefault()
        header.classList.remove('drop-hint')
        closeTabMenu()
        closeDropdownNow()
        const tabName = e.dataTransfer.getData('text/tab') || draggingTabName
        const groupMove = e.dataTransfer.getData('text/tab-group') || draggingGroupId
        const projId = getDragProjectId(e)
        if(tabName){
          pushHistory()
          moveTabToGroup(tabName, group.id)
          setDirty(true); render()
        }else if(groupMove && groupMove !== group.id){
          pushHistory()
          moveGroupBefore(groupMove, group.id)
          setDirty(true); render()
        }else if(projId){
          showToast('Bitte Tab innerhalb der Gruppe wählen.')
        }
        draggingProjectId = null
        draggingGroupId = null
        draggingTabName = null
      })

      return container
    }
  }

  if(tabsEl){
    tabsEl.addEventListener('dragover', e => {
      const hasTab = draggingTabName || e.dataTransfer.getData('text/tab')
      const hasGroup = draggingGroupId || e.dataTransfer.getData('text/tab-group')
      if((hasTab || hasGroup) && e.target === tabsEl){
        e.preventDefault()
      }
    })
    tabsEl.addEventListener('drop', e => {
      if(e.target !== tabsEl) return
      e.preventDefault()
      closeTabMenu()
      const droppedTab = e.dataTransfer.getData('text/tab') || draggingTabName
      const droppedGroup = e.dataTransfer.getData('text/tab-group') || draggingGroupId
      if(droppedTab){
        pushHistory()
        moveTabBefore(droppedTab)
        setDirty(true); render()
      }else if(droppedGroup){
        pushHistory()
        moveGroupBefore(droppedGroup)
        setDirty(true); render()
      }
      draggingTabName = null
      draggingGroupId = null
    })
  }

  // ===== Rendering =====
  function renderTimelineFilters(){
    if(!timelineAssigneeSelect) return
    const values = Array.isArray(state.timelineAssignees) ? state.timelineAssignees : []
    const selected = new Set(values)
    const team = Array.isArray(state.team) ? state.team : []
    timelineAssigneeSelect.innerHTML = ''
    const optionCount = team.length + 2
    timelineAssigneeSelect.size = optionCount <= 3 ? optionCount : 3
    const addOption = (value, label, isSelected) => {
      const opt = document.createElement('option')
      opt.value = value
      opt.textContent = label
      opt.selected = !!isSelected
      timelineAssigneeSelect.appendChild(opt)
    }
    addOption('__all__', 'Alle Bearbeiter', selected.size === 0)
    addOption(ASSIGNEE_UNASSIGNED, 'Unzugewiesen', selected.has(ASSIGNEE_UNASSIGNED))
    team.forEach(name => addOption(name, name, selected.has(name)))
  }

  function render(){
    applyTheme(); setTitle(); renderTabs();
    renderTimelineFilters();
    if(q) q.value = state.filters.q ?? '';
    if(status) status.value = state.filters.status ?? 'all';
    if(sort) sort.value = state.filters.sort ?? 'date_desc';
    renderAssigneeFilterControl();
    const isTimeline = state.view === 'timeline';
    const isSummary = state.view === 'summary';
    const isAssignees = state.view === 'assignees';
    const isDispo = state.view === 'dispo';
    const viewClassMap = {
      table: 'view-table',
      timeline: 'view-timeline',
      summary: 'view-summary',
      assignees: 'view-assignees',
      dispo: 'view-dispo'
    };
    const activeViewClass = viewClassMap[state.view] || 'view-table';
    const viewClasses = Object.values(viewClassMap);
    viewClasses.forEach(cls => document.body.classList.toggle(cls, cls === activeViewClass));
    // Toggle view buttons
    document.getElementById('viewTable').classList.toggle('on', !isTimeline && !isSummary && !isAssignees && !isDispo);
    const viewTimelineBtn = document.getElementById('viewTimeline');
    if(viewTimelineBtn) viewTimelineBtn.classList.toggle('on', isTimeline);
    const viewSummaryBtn = document.getElementById('viewSummary');
    if(viewSummaryBtn) viewSummaryBtn.classList.toggle('on', isSummary);
  const viewAssigneesBtn = document.getElementById('viewAssignees');
    if(viewAssigneesBtn) viewAssigneesBtn.classList.toggle('on', isAssignees);
    const viewDispoBtn = document.getElementById('viewDispo');
    if(viewDispoBtn) viewDispoBtn.classList.toggle('on', isDispo);
    // Show/hide main sections
    tableView.style.display = (!isTimeline && !isSummary && !isAssignees && !isDispo) ? 'block' : 'none';
    if(timelineShell) timelineShell.classList.toggle('show', isTimeline);
    if(timelineViewEl) timelineViewEl.classList.toggle('show', isTimeline);
    if(assigneeViewEl) assigneeViewEl.classList.toggle('show', isAssignees);
    if(summaryView) summaryView.classList.toggle('show', isSummary);
    if(dispoView) dispoView.classList.toggle('show', isDispo);
    if(toolbar) toolbar.style.display = (isTimeline || isSummary || isAssignees || isDispo) ? 'none' : 'grid';
    if(filterbar) filterbar.style.display = (!isTimeline && !isSummary && !isAssignees && !isDispo) ? 'grid' : 'none';
    if(timelineZoomInput || timelineZoomLabelsEl){
      updateTimelineZoomIndicator();
    }
    // Render per view
    if(isTimeline){
      virtualizationActive = false;
      renderTimeline();
      updateBulkUi();
      return;
    }
    if(isSummary){
      virtualizationActive = false;
      renderSummary();
      updateBulkUi();
      return;
    }
    if(isAssignees){
      virtualizationActive = false;
      renderAssignees();
      updateBulkUi();
      return;
    }
    if(isDispo){
      virtualizationActive = false;
      renderDispo();
      updateBulkUi();
      return;
    }
    // Table view
    tbody.innerHTML = '';
    const list = applyFilters(state.projects || []);
    if(list.length === 0){
      virtualizationActive = false;
      tbody.appendChild(emptyRow);
    }else{
      const VIRTUAL_THRESHOLD = 150;
      if(list.length > VIRTUAL_THRESHOLD){
        virtualizationActive = true;
        const ROW_HEIGHT = 136;
        const BUFFER = 8;
        const tableRect = tableView.getBoundingClientRect();
        const tableTop = tableRect.top + window.scrollY;
        const viewportTop = window.scrollY;
        const viewportBottom = viewportTop + window.innerHeight;
        const offsetTop = Math.max(0, viewportTop - tableTop);
        let startIndex = Math.max(0, Math.floor(offsetTop / ROW_HEIGHT) - BUFFER);
        const visibleCount = Math.ceil((viewportBottom - viewportTop) / ROW_HEIGHT) + BUFFER * 2;
        let endIndex = Math.min(list.length, startIndex + visibleCount);
        if(endIndex - startIndex < visibleCount && endIndex === list.length){
          startIndex = Math.max(0, list.length - visibleCount);
        }
        const topSpacerHeight = startIndex * ROW_HEIGHT;
        if(topSpacerHeight > 0){
          const topSpacer = document.createElement('tr');
          topSpacer.className = 'virtual-spacer';
          const td = document.createElement('td');
          td.colSpan = 6;
          td.style.height = `${topSpacerHeight}px`;
          topSpacer.appendChild(td);
          tbody.appendChild(topSpacer);
        }
        for(let i = startIndex; i < endIndex; i++){
          tbody.appendChild(rowFor(list[i]));
        }
        const bottomHeight = Math.max(0, (list.length - endIndex) * ROW_HEIGHT);
        if(bottomHeight > 0){
          const bottomSpacer = document.createElement('tr');
          bottomSpacer.className = 'virtual-spacer';
          const td = document.createElement('td');
          td.colSpan = 6;
          td.style.height = `${bottomHeight}px`;
          bottomSpacer.appendChild(td);
          tbody.appendChild(bottomSpacer);
        }
      }else{
        virtualizationActive = false;
        list.forEach(p => tbody.appendChild(rowFor(p)));
      }
    }
    updateBulkUi();
  }

  // ===== Zeilenaufbau =====
function rowFor(p){
  const tr = document.createElement('tr');
  // Row identifier
  tr.dataset.id = p.id;

// Auswahl/Farbe
  if (selected.has(p.id)) tr.classList.add('row-selected');
  if (p.color){ tr.classList.add('colored'); tr.style.setProperty('--pcolor', p.color); }

  // NEU: collapsed-Klasse initial setzen
  tr.classList.toggle('collapsed', !!p.collapsed);

    // Drag events: verwenden Sie die linke Steuerzelle als Drag‑Handle für Projektverschiebungen
    // Beim Dragstart wird die Projekt‑ID übermittelt. Das Ziehen auf einen Tab verschiebt das Projekt dorthin.
    // Beim Ziehen über eine Tabellenzeile wird die Reihenfolge geändert (manuelle Sortierung).

     // Linke Zelle: Pfeil, Auswahl, Farbe (mit Popover)
  const tdCtl = document.createElement('td'); tdCtl.className='leftCell';
  const caret = document.createElement('button'); caret.className='caret';
  caret.title = p.collapsed ? 'Aufklappen' : 'Einklappen';
  
// NEU: Icon initial nach Zustand
  caret.innerHTML = `<span class="ms">${p.collapsed ? 'chevron_right' : 'expand_more'}</span>`;
  caret.addEventListener('click', () => {
    pushHistory();
    p.collapsed = !p.collapsed;
    tr.classList.toggle('collapsed', p.collapsed);
    caret.innerHTML = `<span class="ms">${p.collapsed ? 'chevron_right' : 'expand_more'}</span>`;
    setDirty(true); render();
  });
  const select = document.createElement('input'); select.type='checkbox'; select.className='selectCb';
  select.checked = selected.has(p.id);
  select.addEventListener('change', () => { if(select.checked) selected.add(p.id); else selected.delete(p.id); render(); });
  const colorBtn = document.createElement('button'); colorBtn.className='colorBtn'; colorBtn.title='Projektfarbe';
  colorBtn.style.setProperty('--pcolor', p.color || '#7c3aed');
  colorBtn.addEventListener('click', (e)=> openColorPopover(e.currentTarget, p));
  tdCtl.appendChild(caret); tdCtl.appendChild(select); tdCtl.appendChild(colorBtn);

    // === Drag‑Handle auf der linken Zelle ===
    tdCtl.draggable = true;
    tdCtl.addEventListener('dragstart', e => {
      // Kennzeichne das aktuell gezogene Projekt
      e.dataTransfer.setData('text/proj', p.id);
      e.dataTransfer.setData('text/plain', p.id);
      draggingProjectId = p.id;
      // Erlaube Verschieben (statt Kopieren) im Browser
      e.dataTransfer.effectAllowed = 'move';
      if(state.filters.sort !== 'manual'){
        state.filters.sort = 'manual';
        showToast('Sortierung auf „Manuell“ umgeschaltet.');
        const sortSelect = document.getElementById('sort');
        if(sortSelect) sortSelect.value = 'manual';
      }
      // Leicht transparent bei manuellem Sortieren
      if(state.filters.sort === 'manual'){ tr.style.opacity = .5; }
    });
    tdCtl.addEventListener('dragend', () => {
      tr.style.opacity = '';
      draggingProjectId = null;
    });
    // Ziehen über Tabellenzeilen zum Reorden
    tr.addEventListener('dragover', e => {
      e.preventDefault();
      if(state.filters.sort !== 'manual'){
        e.dataTransfer.dropEffect = 'none';
        tr.style.outline = '';
        return;
      }
      // Zeige dem Browser, dass hier ein Verschieben erlaubt ist
      e.dataTransfer.dropEffect = 'move';
      tr.style.outline = '2px dashed #64748b';
    });
    tr.addEventListener('dragleave', () => {
      tr.style.outline = '';
    });
    tr.addEventListener('drop', e => {
      e.preventDefault();
      e.stopPropagation();
      tr.style.outline = '';
      const dragId = getDragProjectId(e);
      if(!dragId || dragId === p.id) return;
      if(state.filters.sort !== 'manual'){
        showToast('Sortierung auf „Manuell“ stellen, um die Reihenfolge zu ändern.');
        return;
      }
      pushHistory();
      const activeTab = state.currentTab || 'Alle';
      const order = ensureManualOrder(projectIdsForTab(activeTab), activeTab);
      const a = order.indexOf(dragId);
      const b = order.indexOf(p.id);
      if(a >= 0 && b >= 0){
        order.splice(a, 1);
        let targetIndex = b;
        // Wenn nach unten gezogen wird, muss das Ziel nach dem Entfernen angepasst werden
        if(a < b) targetIndex = b - 1;
        // Entscheide anhand der Cursorposition, ob vor oder nach der Zeile eingefügt wird
        const bounds = tr.getBoundingClientRect();
        const insertAfter = (e.clientY - bounds.top) > bounds.height / 2;
        order.splice(insertAfter ? targetIndex + 1 : targetIndex, 0, dragId);
        if(activeTab === 'Alle'){
          state.order = order;
          state.orderByTab['Alle'] = order.slice();
        }else{
          state.orderByTab[activeTab] = order;
        }
        setDirty(true);
        render();
      }
      draggingProjectId = null;
    });

    // Nummer
    const tdNr = document.createElement('td')
    const nr = document.createElement('div'); nr.className='editable'; nr.contentEditable='true'; nr.textContent = p.number || ''
    nr.addEventListener('keydown', blurOnEnter)
    nr.addEventListener('input', () => { pushHistory(); p.number = nr.textContent.trim(); setDirty(true) })
    tdNr.appendChild(nr)

    // Name
    const tdName = document.createElement('td')
    const name = document.createElement('div'); name.className='editable'; name.contentEditable='true'; name.textContent = p.name || ''
    name.addEventListener('keydown', blurOnEnter)
    name.addEventListener('input', () => { pushHistory(); p.name = name.textContent.trim(); setDirty(true) })
    tdName.appendChild(name)


    // To-Dos
    const tdTodos = document.createElement('td')
    const todoCol = document.createElement('div'); todoCol.className='todoCol'
    const stats = progressOf(p)
    const head = document.createElement('div'); head.className='todoHead'
    const headLeft = document.createElement('span')
    headLeft.textContent = stats.total === 0
      ? (stats.emptyComplete ? 'Projekt erledigt' : 'Keine To-Dos erfasst')
      : `${stats.done} von ${stats.total} erledigt`
    const headRight = document.createElement('span')
    headRight.style.marginLeft = 'auto'
    headRight.textContent = `${stats.pct}%`
    head.appendChild(headLeft)
    head.appendChild(headRight)
    const bar = document.createElement('div'); bar.className='progress'
    const fill = document.createElement('i'); fill.style.background=`linear-gradient(90deg, var(--progress), #34d399)`; fill.style.width=`${stats.pct}%`; bar.appendChild(fill)

    const list = document.createElement('div'); list.className='todoList'
    // Reorder Todos: dropzone
    list.addEventListener('dragover', e => e.preventDefault())
    list.addEventListener('drop', e => {
      e.preventDefault()
      const from = +e.dataTransfer.getData('text/todoIndex')
      const pid  = e.dataTransfer.getData('text/todoProj')
      if(pid !== p.id || isNaN(from)) return
      const to = p.todos.length
      if(from === to) return
      pushHistory()
      const [it] = p.todos.splice(from,1); p.todos.splice(to,0,it)
      setDirty(true); render()
    })

    p.todos.forEach((t, idx) => list.appendChild(todoItem(p, t, idx)))

    // Für zusammengeklappte Projekte zeigen wir nur die Statistik und den Fortschrittsbalken an.
    todoCol.appendChild(head);
    todoCol.appendChild(bar);
    if(stats.total === 0 && !p.collapsed){
      const noTodoToggle = document.createElement('label')
      noTodoToggle.className = 'todoEmptyToggle'
      const check = document.createElement('input')
      check.type = 'checkbox'
      check.checked = stats.emptyComplete
      check.addEventListener('change', () => {
        pushHistory()
        p.emptyDone = check.checked
        setDirty(true)
        render()
      })
      const caption = document.createElement('span')
      caption.textContent = 'Projekt als erledigt markieren'
      noTodoToggle.appendChild(check)
      noTodoToggle.appendChild(caption)
      todoCol.appendChild(noTodoToggle)
    }
    if(!p.collapsed){
      // Detaillierte Liste und Eingabe nur im ausgeklappten Zustand hinzufügen
      todoCol.appendChild(list);
      const add = document.createElement('div');
      add.className = 'todoAdd';
      const inTask = document.createElement('input');
      inTask.type = 'text';
      inTask.className = 'todoCustom';
      inTask.placeholder = 'To-Do hinzufügen';
      const addDue = document.createElement('input');
      addDue.type = 'date';
      addDue.className = 'todoDueInput';
      addDue.title = 'Fälligkeitsdatum';
      addDue.placeholder = '';
      let addAssigneeSelect = null;
      if(Array.isArray(state.team) && state.team.length){
        addAssigneeSelect = document.createElement('select');
        addAssigneeSelect.className = 'todoAssignee';
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'Bearbeiter wählen';
        addAssigneeSelect.appendChild(opt);
        state.team.forEach(name => {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          addAssigneeSelect.appendChild(option);
        });
      }
      const addBtn = document.createElement('button');
      addBtn.className = 'btnPrimary';
      addBtn.textContent = '+';
      const commitTodo = () => {
        const custom = inTask.value.trim();
        if(!custom) return;
        const tokens = custom.split(';').map(s => s.trim()).filter(Boolean);
        if(!tokens.length) return;
        const assignee = addAssigneeSelect && state.team.includes(addAssigneeSelect.value)
          ? addAssigneeSelect.value
          : '';
        const dueValue = addDue.value && parseIsoDate(addDue.value)
          ? addDue.value
          : '';
        pushHistory();
        tokens.forEach(text => {
          p.todos.push({ text, done:false, due:dueValue, assignee, repeat:null, acknowledged:false, subtasks:[] });
        });
        setDirty(true);
        render();
        queueMicrotask(() => {
          const nextInput = document.querySelector(`tr[data-id="${p.id}"] .todoCustom`);
          if(nextInput) nextInput.focus();
        });
        inTask.value = '';
        addDue.value = '';
        if(addAssigneeSelect) addAssigneeSelect.value = '';
      };
      addBtn.addEventListener('click', () => {
        commitTodo();
      });
      inTask.addEventListener('keydown', e => {
        if(e.key === 'Enter'){
          e.preventDefault();
          commitTodo();
        }
      });
      add.appendChild(inTask);
      if(addAssigneeSelect) add.appendChild(addAssigneeSelect);
      add.appendChild(addDue);
      add.appendChild(addBtn);
      todoCol.appendChild(add);
    } else {
      // Bei zusammengeklappten Projekten sollen die To‑Do Liste und das Eingabefeld nicht angezeigt werden
    }
    tdTodos.appendChild(todoCol)

    // Notizen
    const tdNote = document.createElement('td')
    const note = document.createElement('div'); note.className='note'; note.contentEditable='true'; note.innerHTML = p.notes || ''
    note.addEventListener('keydown', e => { if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); note.blur(); window.getSelection().removeAllRanges() } })
    note.addEventListener('input', () => { pushHistory(); p.notes = note.innerHTML; setDirty(true) })
    tdNote.appendChild(note)

    // Pfad (Eingabe + Vorschau + Dialog)
const tdFolder = document.createElement('td');
const fold = document.createElement('div'); fold.className='folderWrap';

const fin = document.createElement('input');
fin.type='text'; fin.className='folderInput';
fin.placeholder='Pfad oder URL';
fin.value = p.folder || '';
fin.addEventListener('keydown', blurOnEnterInput);
fin.addEventListener('input', () => {
  pushHistory(); p.folder = fin.value; setDirty(true); updatePathPreview();
});

fold.appendChild(fin);
tdFolder.appendChild(fold);

// Vorschau (nur sichtbar, wenn NICHT zugeklappt)
const preview = document.createElement('div');
preview.className = 'pathPreview';
function shorten(s){ s=String(s); return s.length<=44 ? s : (s.slice(0,18)+'…'+s.slice(-22)); }
function updatePathPreview(){
  preview.dataset.full = p.folder || '';
  preview.textContent = p.folder ? shorten(p.folder) : '';
  preview.style.display = (p.folder && !p.collapsed) ? 'block' : 'none';
}
preview.addEventListener('click', () => {
  const dlg = document.getElementById('pathDlg');
  document.getElementById('pathFull').textContent = p.folder || '(kein Pfad)';
  dlg.showModal();
});
updatePathPreview();
tdFolder.appendChild(preview);

  // To-Do Item (draggable)
  function openRepeatDialog(project, todo){
    if(!repeatDialogEl || !todo) return
    const dueDate = parseIsoDate(todo.due)
    if(!dueDate){
      showToast('Bitte zuerst ein Fälligkeitsdatum setzen.')
      return
    }
    repeatTarget = { project, todo }
    const freqValue = (todo.repeat && todo.repeat.freq) || ''
    if(repeatFreqInput) repeatFreqInput.value = freqValue
    updateRepeatIntervalUi(freqValue)
    const intervalVal = todo.repeat && Number.isFinite(Number(todo.repeat.interval)) && Number(todo.repeat.interval) > 0
      ? Math.floor(Number(todo.repeat.interval))
      : 1
    if(repeatIntervalInput) repeatIntervalInput.value = String(intervalVal)
    const countVal = todo.repeat && Number.isFinite(Number(todo.repeat.count)) && Number(todo.repeat.count) > 0
      ? Math.floor(Number(todo.repeat.count))
      : ''
    if(repeatCountInput) repeatCountInput.value = countVal === '' ? '' : String(countVal)
    const startIso = (() => {
      const rawStart = todo.repeat && typeof todo.repeat.start === 'string' ? todo.repeat.start.trim() : ''
      if(rawStart){
        const parsed = parseIsoDate(rawStart)
        if(parsed) return formatIsoDate(parsed)
      }
      const dueParsed = parseIsoDate(todo.due)
      return dueParsed ? formatIsoDate(dueParsed) : ''
    })()
    if(repeatStartInput) repeatStartInput.value = startIso
    const endIso = (() => {
      const rawEnd = todo.repeat && typeof todo.repeat.end === 'string' ? todo.repeat.end.trim() : ''
      if(rawEnd){
        const parsed = parseIsoDate(rawEnd)
        if(parsed) return formatIsoDate(parsed)
      }
      const rawUntil = todo.repeat && typeof todo.repeat.until === 'string' ? todo.repeat.until.trim() : ''
      if(rawUntil){
        const parsedUntil = parseIsoDate(rawUntil)
        if(parsedUntil) return formatIsoDate(parsedUntil)
      }
      return ''
    })()
    if(repeatEndInput) repeatEndInput.value = endIso
    if(repeatWeekdayInputs.length){
      const selected = Array.isArray(todo.repeat?.days)
        ? todo.repeat.days.map(val => parseInt(val, 10)).filter(num => Number.isFinite(num) && num >= 1 && num <= 7)
        : []
      repeatWeekdayInputs.forEach(cb => {
        const val = parseInt(cb.value, 10)
        cb.checked = selected.includes(val)
      })
      if((freqValue === 'weekly' || freqValue === 'monthly') && !repeatWeekdayInputs.some(cb => cb.checked)){
        const dueIso = parseIsoDate(todo.due)
        if(dueIso){
          const isoDay = ((dueIso.getUTCDay() + 6) % 7) + 1
          repeatWeekdayInputs.forEach(cb => {
            cb.checked = parseInt(cb.value, 10) === isoDay
          })
        }
      }
    }
    if(repeatRemoveBtn) repeatRemoveBtn.disabled = !(todo.repeat && todo.repeat.freq)
    updateRepeatWeekdayVisibility(freqValue)
    repeatDialogEl.showModal()
    if(repeatFreqInput) repeatFreqInput.focus()
  }

  function todoItem(project, t, idx){
    if(!Array.isArray(t.subtasks)) t.subtasks = []
    const block = document.createElement('div')
    block.className = 'todoBlock'

    const wrap = document.createElement('div'); wrap.className='todoItem' + (t.done ? ' done' : '')
    wrap.dataset.projectId = project.id || ''
    wrap.dataset.todoIndex = String(idx)
    wrap.draggable = true
    wrap.addEventListener('dragstart', e => {
      wrap.classList.add('dragging')
      e.dataTransfer.setData('text/todoProj', project.id)
      e.dataTransfer.setData('text/todoIndex', String(idx))
    })
    wrap.addEventListener('dragend', ()=> wrap.classList.remove('dragging'))

    const cb = document.createElement('input'); cb.type='checkbox'; cb.checked=!!t.done
    cb.addEventListener('change', () => {
      pushHistory();
      t.done = cb.checked;
      if(cb.checked) t.acknowledged = true;
      setDirty(true);
      render();
    })

    const main = document.createElement('div'); main.className = 'todoMain'
    const txt = document.createElement('div'); txt.className='todoText editable'; txt.contentEditable='true'; txt.textContent = t.text || ''
    txt.addEventListener('keydown', blurOnEnter)
    txt.addEventListener('input', () => { pushHistory(); t.text = txt.textContent.trim(); setDirty(true) })
    main.appendChild(txt)

    const assigneeChip = document.createElement('span')
    assigneeChip.className = 'assigneeChip'
    assigneeChip.style.display = 'none'

    const repeatBadge = document.createElement('span')
    repeatBadge.className = 'repeatBadge'
    repeatBadge.style.display = 'none'
    const repeatInfo = document.createElement('div')
    repeatInfo.className = 'repeatInfo'
    repeatInfo.style.display = 'none'

    const due = document.createElement('input')
    due.type = 'text'
    due.className = 'dateInput'
    const initialDueDate = parseIsoDate(t.due)
    due.value = initialDueDate ? formatGermanDate(initialDueDate) : ''
    due.title = 'Deadline'
    due.placeholder = 'tt.mm.jjjj'
    due.addEventListener('keydown', blurOnEnterInput)
    const commitDue = (dateObj) => {
      const nextIso = dateObj ? formatIsoDate(dateObj) : ''
      if(t.due === nextIso) return
      pushHistory()
      const prevDueIso = t.due
      const prevRepeat = t.repeat && typeof t.repeat === 'object' ? { ...t.repeat } : null
      t.due = nextIso
      if(!nextIso){
        t.repeat = null
      }else if(prevRepeat){
        if(prevRepeat.start === prevDueIso || !prevRepeat.start){
          prevRepeat.start = nextIso
        }
        const normalizedRepeat = normalizeRepeatSpec(prevRepeat, { dueDate: nextIso || dateObj })
        t.repeat = normalizedRepeat || null
      }
      setDirty(true)
      due.value = dateObj ? formatGermanDate(dateObj) : ''
      updateRepeatSummary()
    }
    const updateDueFromInput = () => {
      const raw = due.value.trim()
      const parsed = parseGermanDate(raw)
      if(!parsed && raw){
        const prevDate = parseIsoDate(t.due)
        due.value = prevDate ? formatGermanDate(prevDate) : ''
        return
      }
      commitDue(parsed)
    }
    due.addEventListener('blur', updateDueFromInput)
    due.addEventListener('change', updateDueFromInput)
    const calBtn = document.createElement('button')
    calBtn.className = 'iconbtn miniCal'
    calBtn.title = 'Datum auswählen'
    calBtn.innerHTML = '<span class="ms">event</span>'
    calBtn.addEventListener('click', (ev) => {
      ev.preventDefault()
      const current = parseGermanDate(due.value.trim()) || parseIsoDate(t.due)
      openDatePicker(calBtn, {
        value: current,
        onSelect: (dateObj) => {
          commitDue(dateObj)
        }
      })
    })

    let assigneeSelect = null
    const updateAssigneeChip = () => {
      const current = state.team.includes(t.assignee) ? t.assignee : ''
      if(current){
        assigneeChip.textContent = current
        assigneeChip.style.display = 'inline-flex'
      }else{
        assigneeChip.textContent = ''
        assigneeChip.style.display = 'none'
      }
    }

    const updateRepeatSummary = () => {
      if(t.repeat && t.repeat.freq){
        const badgeText = describeRepeatShort(t.repeat)
        const detailText = describeRepeat(t.repeat)
        if(badgeText){
          repeatBadge.textContent = badgeText
          repeatBadge.style.display = 'inline-flex'
        }else{
          repeatBadge.textContent = ''
          repeatBadge.style.display = 'none'
        }
        if(detailText){
          repeatInfo.textContent = detailText
          repeatInfo.style.display = 'block'
        }else{
          repeatInfo.textContent = ''
          repeatInfo.style.display = 'none'
        }
        return
      }
      repeatBadge.textContent = ''
      repeatBadge.style.display = 'none'
      repeatInfo.textContent = ''
      repeatInfo.style.display = 'none'
    }

    if(Array.isArray(state.team) && state.team.length){
      main.appendChild(assigneeChip)
      assigneeSelect = document.createElement('select')
      assigneeSelect.className = 'todoAssignee'
      const defaultOpt = document.createElement('option')
      defaultOpt.value = ''
      defaultOpt.textContent = 'Bearbeiter wählen'
      assigneeSelect.appendChild(defaultOpt)
      state.team.forEach(name => {
        const opt = document.createElement('option')
        opt.value = name
        opt.textContent = name
        assigneeSelect.appendChild(opt)
      })
      assigneeSelect.value = state.team.includes(t.assignee) ? t.assignee : ''
      assigneeSelect.addEventListener('change', () => {
        const next = assigneeSelect.value
        if(next === (t.assignee || '')) return
        pushHistory()
        t.assignee = next
        setDirty(true)
        updateAssigneeChip()
        render()
      })
      assigneeChip.addEventListener('click', () => {
        if(assigneeSelect){
          assigneeSelect.focus()
        }
      })
    }

    main.appendChild(repeatBadge)

    const repeatBtn = document.createElement('button')
    repeatBtn.type = 'button'
    repeatBtn.className = 'repeatEditBtn'
    repeatBtn.textContent = 'Wiederholung'
    if(repeatDialogEl){
      repeatBtn.addEventListener('click', (ev) => {
        ev.preventDefault()
        openRepeatDialog(project, t)
      })
    }else{
      repeatBtn.disabled = true
      repeatBtn.title = 'Wiederholung nicht verfügbar'
    }
    main.appendChild(repeatBtn)

    const moreBtn = document.createElement('button')
    moreBtn.type = 'button'
    moreBtn.className = 'moreBtn'
    moreBtn.textContent = 'Mehr'
    moreBtn.setAttribute('aria-expanded','false')
    main.appendChild(moreBtn)

    const todoMore = document.createElement('div')
    todoMore.className = 'todoMore hidden'

    const subBtn = document.createElement('button')
    subBtn.type = 'button'
    subBtn.className = 'subAddBtn'
    subBtn.title = 'Unter-To-Do hinzufügen'
    subBtn.innerHTML = '<span class="ms">playlist_add</span>'

    const del = document.createElement('button'); del.className='todoDel'; del.innerHTML='✕'; del.title='Aufgabe entfernen'
    del.addEventListener('click', () => {
      pushHistory()
      cleanupDispoItems(project, t.text || '')
      project.todos.splice(idx,1)
      setDirty(true)
      render()
    })

    const b = dueBadge(t.due)
    if(b?.cls === 'b-red') wrap.style.boxShadow = 'inset 0 0 0 2px rgba(239,68,68,.7)'
    else if(b?.cls === 'b-amber') wrap.style.boxShadow = 'inset 0 0 0 2px rgba(245,158,11,.6)'
    else if(b?.cls === 'b-yellow') wrap.style.boxShadow = 'inset 0 0 0 2px rgba(234,179,8,.5)'
    else if(b?.cls === 'b-green') wrap.style.boxShadow = 'inset 0 0 0 2px rgba(16,185,129,.45)'

    const toggleMore = (force) => {
      const show = typeof force === 'boolean' ? force : todoMore.classList.contains('hidden')
      if(show){
        todoMore.classList.remove('hidden')
        moreBtn.textContent = 'Weniger'
        moreBtn.setAttribute('aria-expanded','true')
      }else{
        todoMore.classList.add('hidden')
        moreBtn.textContent = 'Mehr'
        moreBtn.setAttribute('aria-expanded','false')
      }
    }
    moreBtn.addEventListener('click', () => toggleMore())

    const metaRow = document.createElement('div')
    metaRow.className = 'todoMetaRow'
    const dueWrap = document.createElement('div')
    dueWrap.className = 'todoDueWrap'
    dueWrap.appendChild(due)
    dueWrap.appendChild(calBtn)
    metaRow.appendChild(dueWrap)
    if(assigneeSelect){
      assigneeSelect.classList.add('todoAssigneeSelect')
      metaRow.appendChild(assigneeSelect)
    }
    todoMore.appendChild(metaRow)
    todoMore.appendChild(repeatInfo)
    const moreActions = document.createElement('div')
    moreActions.className = 'todoMoreActions'
    moreActions.appendChild(subBtn)
    moreActions.appendChild(del)
    todoMore.appendChild(moreActions)

    wrap.appendChild(cb)
    wrap.appendChild(main)
    wrap.appendChild(todoMore)
    updateAssigneeChip()
    updateRepeatSummary()

    const subList = document.createElement('div')
    subList.className = 'subList'
    const ensureSubtasks = () => { if(!Array.isArray(t.subtasks)) t.subtasks = []; return t.subtasks }

    const focusSubtask = (subIndex) => {
      queueMicrotask(() => {
        const selector = `.subItem[data-project-id="${project.id}"][data-todo-index="${idx}"][data-sub-index="${subIndex}"] .todoText`
        const target = document.querySelector(selector)
        if(target){
          target.focus()
          const selection = window.getSelection()
          if(selection){
            const range = document.createRange()
            range.selectNodeContents(target)
            range.collapse(false)
            selection.removeAllRanges()
            selection.addRange(range)
          }
        }
      })
    }

    const buildSubtaskRow = (sub, subIndex) => {
      const row = document.createElement('div')
      row.className = 'subItem' + (sub.done ? ' done' : '')
      row.dataset.projectId = project.id || ''
      row.dataset.todoIndex = String(idx)
      row.dataset.subIndex = String(subIndex)

      const subCb = document.createElement('input')
      subCb.type = 'checkbox'
      subCb.checked = !!sub.done
        subCb.addEventListener('change', () => {
          pushHistory()
          sub.done = subCb.checked
          if(subCb.checked){
            sub.acknowledged = true
          }
          setDirty(true)
          render()
        })

      const subText = document.createElement('div')
      subText.className = 'todoText editable'
      subText.contentEditable = 'true'
      subText.textContent = sub.text || ''
      subText.addEventListener('keydown', blurOnEnter)
      subText.addEventListener('input', () => {
        pushHistory()
        sub.text = subText.textContent.trim()
        setDirty(true)
      })

      const subDue = document.createElement('input')
      subDue.type = 'text'
      subDue.className = 'dateInput dateInput--compact'
      const subDueDate = parseIsoDate(sub.due)
      subDue.value = subDueDate ? formatGermanDate(subDueDate) : ''
      subDue.placeholder = 'tt.mm.jjjj'
      subDue.title = 'Deadline'
      subDue.addEventListener('keydown', blurOnEnterInput)
      const commitSubDue = (dateObj) => {
        const nextIso = dateObj ? formatIsoDate(dateObj) : ''
        if(sub.due === nextIso) return
        pushHistory()
        sub.due = nextIso
        setDirty(true)
        subDue.value = dateObj ? formatGermanDate(dateObj) : ''
      }
      const updateSubDue = () => {
        const raw = subDue.value.trim()
        const parsed = parseGermanDate(raw)
        if(!parsed && raw){
          const prevDate = parseIsoDate(sub.due)
          subDue.value = prevDate ? formatGermanDate(prevDate) : ''
          return
        }
        commitSubDue(parsed)
      }
      subDue.addEventListener('blur', updateSubDue)
      subDue.addEventListener('change', updateSubDue)
      const subCalBtn = document.createElement('button')
      subCalBtn.className = 'iconbtn miniCal'
      subCalBtn.title = 'Datum auswählen'
      subCalBtn.innerHTML = '<span class="ms">event</span>'
      subCalBtn.addEventListener('click', (ev) => {
        ev.preventDefault()
        const current = parseGermanDate(subDue.value.trim()) || parseIsoDate(sub.due)
        openDatePicker(subCalBtn, {
          value: current,
          onSelect: (dateObj) => commitSubDue(dateObj)
        })
      })

      let subAssignee = null
      if(Array.isArray(state.team) && state.team.length){
        subAssignee = document.createElement('select')
        subAssignee.className = 'todoAssignee'
        const defaultOpt = document.createElement('option')
        defaultOpt.value = ''
        defaultOpt.textContent = 'Bearbeiter wählen'
        subAssignee.appendChild(defaultOpt)
        state.team.forEach(name => {
          const opt = document.createElement('option')
          opt.value = name
          opt.textContent = name
          subAssignee.appendChild(opt)
        })
        subAssignee.value = state.team.includes(sub.assignee) ? sub.assignee : ''
        subAssignee.addEventListener('change', () => {
          const next = subAssignee.value
          if(next === (sub.assignee || '')) return
          pushHistory()
          sub.assignee = next
          setDirty(true)
          render()
        })
      }

      const remove = document.createElement('button')
      remove.type = 'button'
      remove.className = 'todoDel'
      remove.innerHTML = '✕'
      remove.title = 'Unter-Aufgabe entfernen'
      remove.addEventListener('click', () => {
        pushHistory()
        const list = ensureSubtasks()
        cleanupDispoItems(project, sub.text || '')
        list.splice(subIndex, 1)
        setDirty(true)
        render()
      })

      row.appendChild(subCb)
      row.appendChild(subText)
      row.appendChild(subDue)
      row.appendChild(subCalBtn)
      if(subAssignee) row.appendChild(subAssignee)
      row.appendChild(remove)
      return row
    }

    const subtasks = Array.isArray(t.subtasks) ? t.subtasks : []
    if(!subtasks.length) subList.style.display = 'none'
    subtasks.forEach((sub, subIndex) => {
      subList.appendChild(buildSubtaskRow(sub, subIndex))
    })

    subBtn.addEventListener('click', () => {
      toggleMore(true)
      const list = ensureSubtasks()
      pushHistory()
      list.push({ text:'', done:false, due:'', assignee:'', acknowledged:false })
      setDirty(true)
      render()
      focusSubtask(list.length - 1)
    })

    block.appendChild(wrap)
    block.appendChild(subList)
    return block
  }

    // Alle aufgebauten Zellen zum Tabellen‑Row hinzufügen und Zeile zurückgeben
    tr.appendChild(tdCtl);
    tr.appendChild(tdNr);
    tr.appendChild(tdName);
    tr.appendChild(tdTodos);
    tr.appendChild(tdNote);
    tr.appendChild(tdFolder);
    return tr;
  }

  // ===== Auswahlabhängige UI =====
  function updateBulkUi(){
    selCount.textContent = `${selected.size} ausgewählt`;
    const allow = state.view === 'table';
    bulkbar.classList.toggle('show', allow && selected.size > 0);
  }

  // ===== CSV / Kalender-Export =====
  function parseCSV(text){
    const rows=[]; let i=0, field='', row=[], inQ=false
    while(i<text.length){
      const ch=text[i]
      if(inQ){ if(ch === '"'){ if(text[i+1] === '"'){ field+='"'; i+=2 } else { inQ=false; i++ } } else { field+=ch; i++ } }
      else{
        if(ch === '"'){ inQ=true; i++ }
        else if(ch === ',' || ch === ';'){ row.push(field.trim()); field=''; i++ }
        else if(ch === '\n' || ch === '\r'){ if(field!=='' || row.length){ row.push(field.trim()); rows.push(row); row=[]; field='' } if(ch==='\r' && text[i+1]==='\n') i++; i++ }
        else { field+=ch; i++ }
      }
    }
    if(field!=='' || row.length){ row.push(field.trim()); rows.push(row) }
    return rows
  }
  function buildProjectCsvRows(list){
    const header = [
      'ProjektID','Projektnummer','Projektname','Tab','ProjektNotizenHTML','ProjektPfad','ProjektFarbe','ProjektEingeklappt',
      'ProjektDeadline','ProjektDeadlineSichtbar','ProjektLeerErledigt','ProjektDatum','ProjektSortierung',
      'TodoTyp','TodoIndex','SubtaskIndex','TodoText','TodoDone','TodoStart','TodoDue','TodoAssignee','TodoAcknowledged',
      'TodoRepeatFreq','TodoRepeatInterval','TodoRepeatCount','TodoRepeatStart','TodoRepeatEnd','TodoRepeatUntil','TodoRepeatDays','ParentTodoText'
    ]
    const rows = [header]
    const manualOrder = (state.order && state.order.length) ? state.order.slice() : (state.projects || []).map(p => p.id)
    const dayLabel = { 1:'Mo', 2:'Di', 3:'Mi', 4:'Do', 5:'Fr', 6:'Sa', 7:'So' }
    const stringifyRepeatDays = (days) => {
      if(!Array.isArray(days) || !days.length) return ''
      const sorted = Array.from(new Set(days.map(num => parseInt(num, 10)).filter(num => Number.isFinite(num) && num >= 1 && num <= 7))).sort((a,b)=>a-b)
      return sorted.map(num => dayLabel[num] || String(num)).join(' ')
    }
    const pushRow = ({
      project, todoType, todo, todoIndex, subIndex, parentText
    }) => {
      const repeat = todo?.repeat && typeof todo.repeat === 'object' ? todo.repeat : null
      const repeatDays = repeat?.days ? stringifyRepeatDays(repeat.days) : ''
      rows.push([
        project.id || '',
        project.number || '',
        project.name || '',
        project.tab || 'Alle',
        project.notes || '',
        project.folder || '',
        project.color || '',
        project.collapsed ? 'true' : 'false',
        project.deadline || '',
        project.showDeadline ? 'true' : 'false',
        project.emptyDone ? 'true' : 'false',
        project.date || '',
        (() => { const idx = manualOrder.indexOf(project.id); return idx >= 0 ? String(idx) : '' })(),
        todoType,
        todoIndex != null ? String(todoIndex) : '',
        subIndex != null ? String(subIndex) : '',
        todo?.text || '',
        todo?.done ? 'true' : 'false',
        todo?.start || '',
        todo?.due || '',
        todo?.assignee || '',
        todo?.acknowledged ? 'true' : 'false',
        repeat?.freq || '',
        repeat?.interval != null ? String(repeat.interval) : '',
        repeat?.count != null ? String(repeat.count) : '',
        repeat?.start || '',
        repeat?.end || '',
        repeat?.until || '',
        repeatDays,
        parentText || ''
      ])
    }
    list.forEach(project => {
      const todos = Array.isArray(project.todos) ? project.todos : []
      if(!todos.length){
        pushRow({ project, todoType:'Projekt', todo:null, todoIndex:null, subIndex:null, parentText:'' })
        return
      }
      todos.forEach((todo, todoIndex) => {
        pushRow({ project, todoType:'To-Do', todo, todoIndex, subIndex:null, parentText:'' })
        const subtasks = Array.isArray(todo.subtasks) ? todo.subtasks : []
        const parentText = typeof todo.text === 'string' ? todo.text : ''
        subtasks.forEach((sub, subIndex) => {
          pushRow({ project, todoType:'Subtask', todo:sub, todoIndex, subIndex, parentText })
        })
      })
    })
    return rows
  }
  function stringifyCsv(rows){
    return rows.map(r => r.map(c => `"${String(c ?? '').replace(/"/g,'""')}"`).join(',')).join('\n')
  }
  function triggerCsvDownload(csv, name){
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8'})
    const a = document.createElement('a')
    a.href = URL.createObjectURL(blob)
    a.download = name
    a.click()
    URL.revokeObjectURL(a.href)
  }
  function inferCsvFileName(){
    const title = (state.title || '').trim()
    if(title){
      return `${title.replace(/\s+/g,'_')}.csv`
    }
    return 'projekte.csv'
  }
  async function exportCSV(list, name){
    const rows = buildProjectCsvRows(list)
    const csv = stringifyCsv(rows)
    const fileName = name || inferCsvFileName()
    triggerCsvDownload(csv, fileName)
    return 'download'
  }
  async function saveCsv(){
    const list = gatherProjectsForExport()
    return await exportCSV(list, inferCsvFileName())
  }
  function gatherProjectsForExport(){
    const projects = Array.isArray(state.projects) ? state.projects : []
    switch(state.view){
      case 'table':
        return applyFilters(projects)
      case 'timeline': {
        const tab = (state.timelineTab && state.tabs?.includes(state.timelineTab)) ? state.timelineTab : 'Alle'
        const selected = Array.isArray(state.timelineAssignees) ? state.timelineAssignees.filter(Boolean) : []
        const normalizedSet = new Set(selected)
        const includeUnassigned = normalizedSet.has(ASSIGNEE_UNASSIGNED)
        normalizedSet.delete(ASSIGNEE_UNASSIGNED)
        const lowerLookup = new Set(Array.from(normalizedSet).map(val => val.toLowerCase()))
        const team = Array.isArray(state.team) ? state.team.map(name => name.trim()) : []
        const teamLookup = new Set(team.map(name => name.toLowerCase()))
        const matcherActive = includeUnassigned || normalizedSet.size > 0
        const matches = (assignee) => {
          if(!matcherActive) return true
          const raw = typeof assignee === 'string' ? assignee.trim() : ''
          if(raw){
            const parts = raw.split(/[;,]/).map(part => part.trim()).filter(Boolean)
            if(!parts.length) return includeUnassigned
            return parts.some(part => {
              const key = part.toLowerCase()
              return teamLookup.has(key) && lowerLookup.has(key)
            })
          }
          return includeUnassigned
        }
        return projects.filter(project => {
          if(tab !== 'Alle' && (project.tab || 'Alle') !== tab) return false
          if(!matcherActive) return true
          const todos = Array.isArray(project.todos) ? project.todos : []
          return todos.some(todo => {
            if(!todo || todo.done || !todo.due) return false
            if(matches(todo.assignee)) return true
            const subs = Array.isArray(todo.subtasks) ? todo.subtasks : []
            return subs.some(sub => sub && !sub.done && sub.due && matches(sub.assignee))
          })
        })
      }
      case 'assignees': {
        const matcher = buildAssigneeMatcher()
        if(!matcher.active) return projects
        return projects.filter(project => {
          const todos = Array.isArray(project.todos) ? project.todos : []
          for(const todo of todos){
            if(!todo) continue
            if(!todo.done && matcher.matches(todo.assignee)) return true
            const subs = Array.isArray(todo.subtasks) ? todo.subtasks : []
            if(subs.some(sub => sub && !sub.done && matcher.matches(sub.assignee))) return true
          }
          return false
        })
      }
      default:
        return projects
    }
  }
  function buildDispoCsvRows(){
    const rows = [['DispoID','Jahr','Woche','Titel','Notizen','Eingeklappt','ItemID','Projekt','Bearbeiter','Aufgabe','Fälligkeitsdatum','ItemReihenfolge']]
    const entries = Array.isArray(state.dispo) ? state.dispo : []
    entries.forEach(entry => {
      const items = Array.isArray(entry.items) && entry.items.length ? entry.items : [null]
      items.forEach((item, idx) => {
        rows.push([
          entry.id || '',
          entry.year ?? '',
          entry.week ?? '',
          entry.title || '',
          entry.notes || '',
          entry.collapsed ? 'true' : 'false',
          item ? (item.id || '') : '',
          item ? (item.project || '') : '',
          item ? (item.assignee || '') : '',
          item ? (item.todo || '') : '',
          item ? (item.due || '') : '',
          item ? String(idx) : ''
        ])
      })
    })
    return rows
  }
  function exportDispoCSV(name){
    const rows = buildDispoCsvRows()
    const csv = rows.map(r => r.map(c => `"${String(c ?? '').replace(/"/g,'""')}"`).join(',')).join('\n')
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8'})
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; a.click(); URL.revokeObjectURL(a.href)
  }
  function importDispoFromRows(rows){
    if(!rows.length){ alert('CSV leer.'); return }
    const header = rows[0].map(h => String(h||'').toLowerCase())
    const idx = {
      entryId: header.findIndex(h => h.includes('dispoid') || h === 'dispo id' || h === 'dispoid' || h === 'id'),
      year: header.findIndex(h => h === 'jahr' || h.includes('year')),
      week: header.findIndex(h => h === 'woche' || h.includes('week')),
      title: header.findIndex(h => h.includes('titel') || h.includes('title')),
      notes: header.findIndex(h => h.includes('notiz') || h.includes('note')),
      collapsed: header.findIndex(h => h.includes('eingeklappt') || h.includes('collapsed')),
      itemId: header.findIndex(h => h.includes('itemid') || h === 'item id' || h === 'itemid'),
      itemProject: header.findIndex(h => h.includes('projekt') || h.includes('project')),
      itemAssignee: header.findIndex(h => h.includes('bearbeiter') || h.includes('assignee') || h.includes('verantwortlich')),
      itemTodo: header.findIndex(h => h.includes('aufgabe') || h.includes('todo')),
      itemDue: header.findIndex(h => h.includes('fällig') || h.includes('due')),
      itemOrder: header.findIndex(h => h.includes('reihenfolge') || h.includes('order'))
    }
    const entriesByKey = new Map()
    const orderedEntries = []
    for(let r=1; r<rows.length; r++){
      const cells = rows[r] || []
      if(!cells.length || cells.every(c => !c)) continue
      const rawId = idx.entryId >= 0 ? (cells[idx.entryId] || '').trim() : ''
      const key = rawId || `auto-${r}`
      let entry = entriesByKey.get(key)
      if(!entry){
        const now = new Date()
        entry = {
          id: rawId || uid(),
          year: parseInteger(idx.year >=0 ? cells[idx.year] : null, now.getUTCFullYear()),
          week: parseInteger(idx.week >=0 ? cells[idx.week] : null, 1),
          title: idx.title>=0 ? (cells[idx.title] || '') : '',
          notes: idx.notes>=0 ? (cells[idx.notes] || '') : '',
          collapsed: idx.collapsed>=0 ? parseCsvBoolean(cells[idx.collapsed]) : false,
          items: []
        }
        entriesByKey.set(key, entry)
        orderedEntries.push(entry)
      }else{
        if(idx.title>=0 && cells[idx.title] !== undefined) entry.title = cells[idx.title] || ''
        if(idx.notes>=0 && cells[idx.notes] !== undefined) entry.notes = cells[idx.notes] || ''
        if(idx.collapsed>=0 && cells[idx.collapsed] !== undefined) entry.collapsed = parseCsvBoolean(cells[idx.collapsed])
        if(idx.year>=0 && cells[idx.year] !== undefined){
          const y = parseInteger(cells[idx.year], entry.year)
          if(y !== null) entry.year = y
        }
        if(idx.week>=0 && cells[idx.week] !== undefined){
          const w = parseInteger(cells[idx.week], entry.week)
          if(w !== null) entry.week = w
        }
      }
      const itemProject = idx.itemProject>=0 ? (cells[idx.itemProject] || '') : ''
      const itemAssignee = idx.itemAssignee>=0 ? (cells[idx.itemAssignee] || '') : ''
      const itemTodo = idx.itemTodo>=0 ? (cells[idx.itemTodo] || '') : ''
      const itemDue = idx.itemDue>=0 ? (cells[idx.itemDue] || '') : ''
      const itemId = idx.itemId>=0 ? (cells[idx.itemId] || '').trim() : ''
      const itemHasContent = itemProject || itemAssignee || itemTodo || itemDue || itemId
      if(itemHasContent){
        const orderRaw = idx.itemOrder>=0 ? parseInteger(cells[idx.itemOrder], entry.items.length) : entry.items.length
        entry.items.push({
          id: itemId || uid(),
          project: itemProject,
          assignee: itemAssignee,
          todo: itemTodo,
          due: itemDue,
          __order: orderRaw === null ? entry.items.length : orderRaw
        })
      }
    }
    orderedEntries.forEach(entry => {
      if(entry.items && entry.items.length){
        entry.items.sort((a,b) => (a.__order||0) - (b.__order||0))
        entry.items.forEach(item => delete item.__order)
      }
    })
    pushHistory()
    ensureDispo()
    state.dispo = orderedEntries
    if(typeof dispoNavigator === 'object'){
      dispoNavigator.year = null
      dispoNavigator.month = null
    }
    setDirty(true)
    render()
    showToast('Dispo CSV importiert')
  }
  function ymdToICS(ymd){ return ymd.replaceAll('-','') }
  function foldLine(s){ const out=[]; for(let i=0;i<s.length;i+=70) out.push(s.slice(i,i+70)); return out.join('\r\n ') }
  function vevent({uid, summary, description, ymdDate}){
    const dtstamp = new Date().toISOString().replace(/[-:]/g,'').split('.')[0] + 'Z'
    const lines = ['BEGIN:VEVENT',`UID:${uid}`,`DTSTAMP:${dtstamp}`,`DTSTART;VALUE=DATE:${ymdToICS(ymdDate)}`, foldLine(`SUMMARY:${summary}`)]
    if(description) lines.push(foldLine(`DESCRIPTION:${description}`))
    lines.push('END:VEVENT'); return lines.join('\r\n')
  }
  function exportTodosToICS(entries, name){
    const tasks = Array.isArray(entries) ? entries.filter(entry => entry && entry.due && parseIsoDate(entry.due)) : []
    if(!tasks.length){
      showToast('Keine To-Dos mit Fälligkeitsdatum ausgewählt.')
      return
    }
    const parts=['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//ProjektToDos//DE','CALSCALE:GREGORIAN','METHOD:PUBLISH']
    tasks.forEach(entry => {
      const dueDate = parseIsoDate(entry.due)
      if(!dueDate) return
      const project = entry.project || {}
      const todo = entry.todo || {}
      const parent = entry.parent || null
      const projectLabelParts = []
      if(project.number) projectLabelParts.push(project.number)
      if(project.name) projectLabelParts.push(project.name)
      const projectLabel = projectLabelParts.join(' · ').trim()
      const baseText = todo.text || 'To-Do'
      let summaryText = baseText
      if(entry.type === 'subtask' && parent){
        summaryText = `${parent.text || 'To-Do'} → ${baseText}`
      }
      const fullSummary = projectLabel ? `${summaryText} — ${projectLabel}` : summaryText
      const descriptionParts = []
      if(entry.type === 'subtask') descriptionParts.push('Unter-Aufgabe')
      descriptionParts.push(`Projekt: ${projectLabel || '—'}`)
      if(todo.assignee) descriptionParts.push(`Bearbeiter: ${todo.assignee}`)
      descriptionParts.push(`Status: ${todo.done ? 'Erledigt' : 'Offen'}`)
      if(project.tab) descriptionParts.push(`Tab: ${project.tab}`)
      const uid = `${project.id || 'proj'}-${entry.type || 'todo'}-${entry.todoIndex ?? 0}-${entry.subIndex ?? 0}@projtodos`
      const summary = fullSummary.replace(/\r?\n/g, '\\n')
      const description = descriptionParts.join('\n').replace(/\r?\n/g, '\\n')
      parts.push(vevent({ uid, summary, description, ymdDate: entry.due }))
    })
    parts.push('END:VCALENDAR')
    const blob = new Blob([parts.join('\r\n')], {type:'text/calendar;charset=utf-8'})
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href)
  }

  function buildCalendarTasks(projects){
    const list = Array.isArray(projects) ? projects : []
    const tasks = []
    list.forEach(project => {
      if(!project || typeof project !== 'object') return
      const todos = Array.isArray(project.todos) ? project.todos : []
      todos.forEach((todo, todoIndex) => {
        if(!todo || !todo.due) return
        const dueDate = parseIsoDate(todo.due)
        if(!dueDate) return
        tasks.push({ project, todo, todoIndex, subIndex:null, parent:null, type:'todo', due:todo.due, dueDate })
        const subs = Array.isArray(todo.subtasks) ? todo.subtasks : []
        subs.forEach((sub, subIndex) => {
          if(!sub || !sub.due) return
          const subDue = parseIsoDate(sub.due)
          if(!subDue) return
          tasks.push({ project, todo:sub, parent:todo, todoIndex, subIndex, type:'subtask', due:sub.due, dueDate:subDue })
        })
      })
    })
    tasks.sort((a,b) => {
      const aTime = a.dueDate ? a.dueDate.getTime() : Number.MAX_SAFE_INTEGER
      const bTime = b.dueDate ? b.dueDate.getTime() : Number.MAX_SAFE_INTEGER
      if(aTime !== bTime) return aTime - bTime
      const aProj = `${a.project?.number || ''} ${a.project?.name || ''}`.toLowerCase()
      const bProj = `${b.project?.number || ''} ${b.project?.name || ''}`.toLowerCase()
      if(aProj !== bProj) return aProj.localeCompare(bProj, 'de')
      const aLabel = (a.todo?.text || '').toLowerCase()
      const bLabel = (b.todo?.text || '').toLowerCase()
      return aLabel.localeCompare(bLabel, 'de')
    })
    return tasks
  }

  function updateCalendarSelectionCount(){
    if(!calendarSelectionCountEl){
      return
    }
    const total = calendarDialogState.tasks.length
    if(!calendarListEl){
      calendarSelectionCountEl.textContent = '0 ausgewählt'
      return
    }
    const checked = calendarListEl.querySelectorAll('input[type="checkbox"]:checked').length
    if(total){
      calendarSelectionCountEl.textContent = `${checked} von ${total} ausgewählt`
    }else{
      calendarSelectionCountEl.textContent = '0 ausgewählt'
    }
  }

  function openCalendarExportDialog(projects, { fileName = 'todos.ics' } = {}){
    const tasks = buildCalendarTasks(projects).filter(entry => entry && entry.dueDate)
    if(!calendarDialogEl || typeof calendarDialogEl.showModal !== 'function'){
      if(!tasks.length){
        showToast('Keine To-Dos mit Fälligkeitsdatum vorhanden.')
        return
      }
      exportTodosToICS(tasks, fileName)
      return
    }
    calendarDialogState.tasks = tasks
    calendarDialogState.fileName = fileName
    if(calendarListEl){
      calendarListEl.innerHTML = ''
      if(!tasks.length){
        const empty = document.createElement('p')
        empty.className = 'calendarEmpty'
        empty.textContent = 'Keine To-Dos mit Fälligkeitsdatum vorhanden.'
        calendarListEl.appendChild(empty)
      }else{
        const groups = new Map()
        tasks.forEach((task, index) => {
          const project = task.project || {}
          const key = project.id || `${project.number || ''}::${project.name || ''}`
          if(!groups.has(key)) groups.set(key, { project, entries: [] })
          groups.get(key).entries.push({ task, index })
        })
        const orderedGroups = Array.from(groups.values()).map(group => {
          const minTime = Math.min(...group.entries.map(entry => entry.task.dueDate?.getTime() ?? Number.MAX_SAFE_INTEGER))
          return { ...group, minTime }
        }).sort((a,b) => a.minTime - b.minTime)
        orderedGroups.forEach(group => {
          group.entries.sort((a,b) => {
            const aTime = a.task.dueDate?.getTime() ?? Number.MAX_SAFE_INTEGER
            const bTime = b.task.dueDate?.getTime() ?? Number.MAX_SAFE_INTEGER
            if(aTime !== bTime) return aTime - bTime
            const aLabel = (a.task.todo?.text || '').toLowerCase()
            const bLabel = (b.task.todo?.text || '').toLowerCase()
            return aLabel.localeCompare(bLabel, 'de')
          })
          const wrapper = document.createElement('div')
          wrapper.className = 'calendarGroup'
          const header = document.createElement('div')
          header.className = 'calendarGroupHeader'
          const labelParts = []
          if(group.project.number) labelParts.push(group.project.number)
          if(group.project.name) labelParts.push(group.project.name)
          header.textContent = labelParts.join(' · ') || 'Projekt'
          if(group.project.tab){
            const tabSpan = document.createElement('span')
            tabSpan.textContent = group.project.tab
            header.appendChild(tabSpan)
          }
          wrapper.appendChild(header)
          const listEl = document.createElement('div')
          listEl.className = 'calendarTodos'
          group.entries.forEach(({ task, index }) => {
            const row = document.createElement('label')
            row.className = 'calendarTodo'
            const cb = document.createElement('input')
            cb.type = 'checkbox'
            cb.checked = true
            cb.dataset.index = String(index)
            row.appendChild(cb)
            const details = document.createElement('div')
            details.className = 'calendarTodoDetails'
            const summary = document.createElement('div')
            summary.className = 'calendarTodoSummary'
            const baseText = task.todo?.text || 'To-Do'
            if(task.type === 'subtask' && task.parent){
              summary.textContent = `${task.parent.text || 'To-Do'} → ${baseText}`
            }else{
              summary.textContent = baseText
            }
            details.appendChild(summary)
            const meta = document.createElement('div')
            meta.className = 'calendarTodoMeta'
            const metaParts = []
            if(task.dueDate) metaParts.push(`Fällig am ${formatGermanDate(task.dueDate)}`)
            metaParts.push(task.todo?.done ? 'Erledigt' : 'Offen')
            if(task.todo?.assignee) metaParts.push(`Bearbeiter: ${task.todo.assignee}`)
            meta.textContent = metaParts.join(' · ')
            details.appendChild(meta)
            row.appendChild(details)
            listEl.appendChild(row)
          })
          wrapper.appendChild(listEl)
          calendarListEl.appendChild(wrapper)
        })
      }
    }
    if(calendarSelectAllBtn) calendarSelectAllBtn.disabled = !tasks.length
    if(calendarSelectNoneBtn) calendarSelectNoneBtn.disabled = !tasks.length
    updateCalendarSelectionCount()
    calendarDialogEl.showModal()
  }

  // ===== Timeline (Gantt‑ähnliche Ansicht) =====
  /**
   * Rendert die Timeline‑Ansicht. Sie sammelt alle To‑Dos mit gesetzter Deadline
   * und sortiert sie nach dem Fälligkeitsdatum. Für jedes Element wird eine
   * horizontale Leiste positioniert, deren horizontale Position dem Datum
   * entspricht. Die heutige Linie wird als rote vertikale Linie dargestellt.
   */


  function layoutSummaryCards(){
    if(!summaryView || !summaryView.classList.contains('show')) return;
    const cards = Array.from(summaryView.querySelectorAll('.summaryCard'));
    if(!cards.length){
      summaryView.style.height = '0px';
      return;
    }
    const styles = getComputedStyle(summaryView);
    const rawColumns = Number.parseInt(styles.getPropertyValue('--summary-columns'), 10);
    const columns = Math.max(1, Number.isFinite(rawColumns) ? rawColumns : 5);
    const gap = Number.parseFloat(styles.getPropertyValue('--summary-gap')) || 16;
    const edgeGap = Number.parseFloat(styles.getPropertyValue('--summary-edge-gap')) || 0;
    const containerWidth = summaryView.clientWidth;
    const usableWidth = Math.max(0, containerWidth - edgeGap * 2);
    const columnWidth = columns > 1 ? (usableWidth - gap * (columns - 1)) / columns : usableWidth;
    const heights = new Array(columns).fill(0);

    cards.forEach((card, index) => {
      const col = index % columns;
      const left = edgeGap + (columnWidth + gap) * col;
      const top = edgeGap + heights[col];
      card.style.width = `${Math.max(0, columnWidth)}px`;
      card.style.left = `${Math.round(left)}px`;
      card.style.top = `${Math.round(top)}px`;
      heights[col] += card.offsetHeight + gap;
    });

    summaryView.style.height = `${Math.max(0, ...heights) - gap + edgeGap * 2}px`;
  }

  function renderSummary() {
    if (!summaryView) return;
    summaryView.innerHTML = '';
    const team = Array.isArray(state.team) ? state.team.slice() : [];
    team.forEach(member => {
      const projectIds = new Set();
      const projectLabels = new Map();
      let todoCount = 0;
      (state.projects || []).forEach(project => {
        let activeTodoCountInProject = 0;
        (project.todos || []).forEach(todo => {
          if (!todo) return;
          if (todo.assignee === member && !todo.done) {
            activeTodoCountInProject++;
            todoCount++;
          }
          (todo.subtasks || []).forEach(sub => {
            if (sub.assignee === member && !sub.done) {
              activeTodoCountInProject++;
              todoCount++;
            }
          });
        });
        if (activeTodoCountInProject > 0) {
          projectIds.add(project.id);
          const labelParts = [];
          if (project.number) labelParts.push(project.number);
          if (project.name) labelParts.push(project.name);
          const projectLabel = labelParts.join(' · ') || 'Unbenanntes Projekt';
          projectLabels.set(project.id, { label: projectLabel, count: activeTodoCountInProject });
        }
      });
      const card = document.createElement('div');
      card.className = 'summaryCard';
      const header = document.createElement('div');
      header.className = 'summaryCardHeader';
      header.textContent = member;
      const arrow = document.createElement('span');
      arrow.className = 'summaryCardArrow ms';
      arrow.textContent = 'expand_more';
      arrow.addEventListener('mouseenter', e => {
        const tooltip = document.createElement('div');
        tooltip.className = 'summaryArrowTooltip';
        tooltip.textContent = 'alle Projekte anzeigen';
        document.body.appendChild(tooltip);
        arrow.__tooltipEl = tooltip;
        tooltip.style.left = `${e.clientX + 14}px`;
        tooltip.style.top = `${e.clientY + 14}px`;
      });
      arrow.addEventListener('mousemove', e => {
        if(!arrow.__tooltipEl) return;
        arrow.__tooltipEl.style.left = `${e.clientX + 14}px`;
        arrow.__tooltipEl.style.top = `${e.clientY + 14}px`;
      });
      arrow.addEventListener('mouseleave', () => {
        if(arrow.__tooltipEl){
          arrow.__tooltipEl.remove();
          arrow.__tooltipEl = null;
        }
      });
      header.appendChild(arrow);
      card.appendChild(header);
      const stats = document.createElement('div');
      stats.className = 'summaryCardStats';
      const projStat = document.createElement('div');
      projStat.className = 'summaryStat';
      projStat.innerHTML = '<span class="label">Aktive Projekte</span><span class="value">' + projectIds.size + '</span>';
      const todoStat = document.createElement('div');
      todoStat.className = 'summaryStat';
      todoStat.innerHTML = '<span class="label">Aktive To-Dos</span><span class="value">' + todoCount + '</span>';
      stats.appendChild(projStat);
      stats.appendChild(todoStat);
      card.appendChild(stats);
      const dropdown = document.createElement('div');
      dropdown.className = 'summaryDropdown';
      const ul = document.createElement('ul');
      (state.projects || []).forEach(project => {
        if (projectIds.has(project.id)) {
          const li = document.createElement('li');
          const info = projectLabels.get(project.id);
          if(info && typeof info === 'object') {
            li.innerHTML = `${info.label} <strong>(${info.count})</strong>`;
          }else{
            li.textContent = 'Unbenanntes Projekt';
          }
          ul.appendChild(li);
        }
      });
      dropdown.appendChild(ul);
      card.appendChild(dropdown);
      header.addEventListener('click', () => {
        if(arrow.__tooltipEl){ arrow.__tooltipEl.remove(); arrow.__tooltipEl = null; }
        const isOpen = dropdown.style.display === 'block';
        dropdown.style.display = isOpen ? 'none' : 'block';
        arrow.textContent = isOpen ? 'expand_more' : 'expand_less';
        requestAnimationFrame(layoutSummaryCards);
      });
      summaryView.appendChild(card);
    });
    requestAnimationFrame(layoutSummaryCards);
  }


  function renderAssignees(){
    if(!assigneeViewEl) return;
    assigneeViewEl.innerHTML = '';
    const team = Array.isArray(state.team) ? state.team.slice() : [];
    const SELECT_ALL = '__all__';
    const selectedValues = Array.isArray(state.assigneeFilter) ? state.assigneeFilter.slice() : [];

    const filterBar = document.createElement('div');
    filterBar.className = 'assigneeFilterBar';
    const filterLabel = document.createElement('label');
    filterLabel.textContent = 'Bearbeiter filtern:';
    filterLabel.setAttribute('for', 'assigneeFilterSelect');
    filterBar.appendChild(filterLabel);

    const select = document.createElement('select');
    select.id = 'assigneeFilterSelect';
    select.multiple = true;
    const optionCount = team.length + 2;
    select.size = optionCount <= 3 ? optionCount : 3;
    const selectedSet = new Set(selectedValues);
    const filterActiveInitial = selectedSet.size > 0;

    const appendOption = (value, label, isSelected) => {
      const opt = document.createElement('option');
      opt.value = value;
      opt.textContent = label;
      opt.selected = !!isSelected;
      select.appendChild(opt);
    };

    appendOption(SELECT_ALL, 'Alle Bearbeiter', !filterActiveInitial);
    appendOption(ASSIGNEE_UNASSIGNED, 'Unzugewiesen', selectedSet.has(ASSIGNEE_UNASSIGNED));
    team.forEach(name => appendOption(name, name, selectedSet.has(name)));

    select.addEventListener('change', () => {
      const rawValues = Array.from(select.selectedOptions).map(opt => opt.value);
      if(rawValues.includes(SELECT_ALL)){
        state.assigneeFilter = [];
        renderAssignees();
        return;
      }
      const normalized = [];
      const seen = new Set();
      rawValues.forEach(val => {
        if(val === ASSIGNEE_UNASSIGNED){
          if(!seen.has(ASSIGNEE_UNASSIGNED)){
            seen.add(ASSIGNEE_UNASSIGNED);
            normalized.push(ASSIGNEE_UNASSIGNED);
          }
        }else{
          const original = (team.find(name => name.toLowerCase() === val.toLowerCase()) || val).trim();
          if(!original) return;
          const key = original.toLowerCase();
          if(seen.has(key)) return;
          seen.add(key);
          normalized.push(original);
        }
      });
      state.assigneeFilter = normalized;
      renderAssignees();
    });

    filterBar.appendChild(select);
    if(team.length){
      const hint = document.createElement('span');
      hint.textContent = 'Mehrfachauswahl mit Strg/⌘';
      hint.style.fontSize = '12px';
      hint.style.color = 'var(--muted)';
      filterBar.appendChild(hint);
    }
    assigneeViewEl.appendChild(filterBar);

    const filterSet = new Set(Array.isArray(state.assigneeFilter) ? state.assigneeFilter : []);
    const filterActive = filterSet.size > 0;
    const includeUnassigned = filterSet.has(ASSIGNEE_UNASSIGNED);
    const parseAssignees = (value) => {
      if(typeof value !== 'string') return []
      return value.split(/[;,]/).map(part => part.trim()).filter(Boolean).map(part => {
        return team.find(name => name.toLowerCase() === part.toLowerCase()) || ''
      }).filter(Boolean)
    }
    const matchesAssignee = assignees => {
      if(!filterActive) return true;
      if(assignees.length) return assignees.some(name => filterSet.has(name));
      return includeUnassigned;
    };

    const groups = [];
    (state.projects || []).forEach(project => {
      const tasks = [];
      (project.todos || []).forEach((todo, todoIndex) => {
        if(!todo) return;
        const todoAssignees = parseAssignees(todo.assignee)
        if(!todo.done && matchesAssignee(todoAssignees)){
          tasks.push({
            project,
            todo,
            todoIndex,
            subIndex: null,
            parent: null,
            isSubtask: false,
            assignee: todoAssignees.join(', ')
          });
        }
        const subtasks = Array.isArray(todo.subtasks) ? todo.subtasks : [];
        subtasks.forEach((sub, subIndex) => {
          if(!sub || sub.done) return;
          const subAssignees = parseAssignees(sub.assignee)
          if(matchesAssignee(subAssignees)){
            tasks.push({
              project,
              todo: sub,
              todoIndex,
              subIndex,
              parent: todo,
              isSubtask: true,
              assignee: subAssignees.join(', ')
            });
          }
        });
      });
      if(tasks.length) groups.push({ project, tasks });
    });

    if(!groups.length){
      const empty = document.createElement('div');
      empty.className = 'assigneeEmpty';
      empty.textContent = filterActive ? 'Keine offenen To-Dos für die Auswahl.' : 'Keine offenen To-Dos mit Bearbeitung.';
      assigneeViewEl.appendChild(empty);
      return;
    }

    const container = document.createElement('div');
    container.className = 'assigneeProjects';
    groups.forEach(({ project, tasks }) => {
      const block = document.createElement('div');
      block.className = 'assigneeProjectBlock';
      const heading = document.createElement('div');
      heading.className = 'assigneeProjectHeading';
      const labelParts = [];
      if(project.number) labelParts.push(project.number);
      if(project.name) labelParts.push(project.name);
      heading.textContent = labelParts.join(' · ') || 'Unbenanntes Projekt';
      block.appendChild(heading);

      const list = document.createElement('div');
      list.className = 'assigneeTodoList';
      tasks.sort((a,b) => {
        const aDue = parseIsoDate(a.todo?.due || '')
        const bDue = parseIsoDate(b.todo?.due || '')
        const aTime = aDue ? aDue.getTime() : Number.MAX_SAFE_INTEGER
        const bTime = bDue ? bDue.getTime() : Number.MAX_SAFE_INTEGER
        if(aTime !== bTime) return aTime - bTime
        const aText = (a.todo?.text || '').toLowerCase()
        const bText = (b.todo?.text || '').toLowerCase()
        return aText.localeCompare(bText)
      });
      tasks.forEach(task => {
        const row = document.createElement('div');
        row.className = 'assigneeTodoRow';
        if(task.isSubtask) row.classList.add('is-subtask');
        const ackNeeded = !task.todo.acknowledged;
        row.classList.toggle('unacknowledged', ackNeeded);
        const targetTodo = task.todo;

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = !!task.todo.done;
        cb.addEventListener('change', () => {
          pushHistory();
          if(task.isSubtask && task.parent && Array.isArray(task.parent.subtasks) && task.subIndex != null){
            task.parent.subtasks[task.subIndex].done = cb.checked;
            if(cb.checked) task.parent.subtasks[task.subIndex].acknowledged = true;
          }else{
            task.todo.done = cb.checked;
            if(cb.checked) task.todo.acknowledged = true;
          }
          setDirty(true);
          render();
        });

        const body = document.createElement('div');
        body.className = 'assigneeTodoBody';
        const header = document.createElement('div');
        header.className = 'assigneeTodoHeader';
        const indicator = document.createElement('span');
        indicator.className = 'ackIndicator' + (ackNeeded ? '' : ' acknowledged');
        header.appendChild(indicator);

        const baseText = task.todo.text || 'To-Do';
        const title = document.createElement('div');
        title.className = 'assigneeTodoTitle';
        title.textContent = task.isSubtask && task.parent
          ? `${task.parent.text || 'To-Do'} → ${baseText}`
          : baseText;
        header.appendChild(title);

        if(task.assignee){
          const chip = document.createElement('span');
          chip.className = 'assigneeChip';
          chip.textContent = task.assignee;
          header.appendChild(chip);
        }

        body.appendChild(header);

        const due = document.createElement('div');
        due.className = 'assigneeTodoMeta';
        const dueDate = parseIsoDate(task.todo.due);
        due.textContent = dueDate ? `Fällig am ${formatGermanDate(dueDate)}` : 'Kein Fälligkeitsdatum';
        body.appendChild(due);

        const editFields = document.createElement('div');
        editFields.className = 'assigneeTodoEdit';
        const editTitle = document.createElement('input');
        editTitle.type = 'text';
        editTitle.value = baseText;
        editTitle.placeholder = 'To-Do';
        editFields.appendChild(editTitle);
        const editDue = document.createElement('input');
        editDue.type = 'date';
        editDue.value = task.todo.due || '';
        editFields.appendChild(editDue);

        let subtaskInput = null;
        if(!task.isSubtask){
          const subtaskRow = document.createElement('div');
          subtaskRow.className = 'assigneeTodoEditActions';
          subtaskInput = document.createElement('input');
          subtaskInput.type = 'text';
          subtaskInput.placeholder = 'Unter-To-Do hinzufügen';
          const subtaskBtn = document.createElement('button');
          subtaskBtn.type = 'button';
          subtaskBtn.className = 'miniBtn';
          subtaskBtn.textContent = 'Unter-To-Do hinzufügen';
          subtaskBtn.addEventListener('click', () => {
            const value = (subtaskInput.value || '').trim();
            if(!value) return;
            pushHistory();
            const list = Array.isArray(targetTodo.subtasks) ? targetTodo.subtasks : (targetTodo.subtasks = []);
            list.push({ text: value, done: false, due: '', assignee: task.assignee || '', acknowledged: false });
            subtaskInput.value = '';
            setDirty(true);
            render();
          });
          subtaskRow.appendChild(subtaskInput);
          subtaskRow.appendChild(subtaskBtn);
          editFields.appendChild(subtaskRow);
        }

        const editActions = document.createElement('div');
        editActions.className = 'assigneeTodoEditActions';
        const confirmBtn = document.createElement('button');
        confirmBtn.type = 'button';
        confirmBtn.className = 'miniBtn';
        confirmBtn.textContent = 'Änderung speichern';
        confirmBtn.addEventListener('click', () => {
          const nextText = (editTitle.value || '').trim();
          const nextDue = (editDue.value || '').trim();
          if(!nextText && !nextDue) return;
          pushHistory();
          if(nextText) targetTodo.text = nextText;
          targetTodo.due = nextDue;
          setDirty(true);
          render();
        });
        editActions.appendChild(confirmBtn);
        editFields.appendChild(editActions);
        body.appendChild(editFields);

        const actions = document.createElement('div');
        actions.className = 'assigneeTodoActions';
        if(ackNeeded){
          const ackBtn = document.createElement('button');
          ackBtn.type = 'button';
          ackBtn.className = 'miniBtn';
          ackBtn.textContent = 'Gesehen';
          ackBtn.title = 'Als gelesen bestätigen';
          ackBtn.addEventListener('click', () => {
            pushHistory();
            task.todo.acknowledged = true;
            setDirty(true);
            render();
          });
          actions.appendChild(ackBtn);
        }else{
          const undoBtn = document.createElement('button');
          undoBtn.type = 'button';
          undoBtn.className = 'miniBtn';
          undoBtn.textContent = 'Rückgängig';
          undoBtn.title = 'Als neu markieren';
          undoBtn.addEventListener('click', () => {
            pushHistory();
            task.todo.acknowledged = false;
            setDirty(true);
            render();
          });
          actions.appendChild(undoBtn);
        }

        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'miniBtn assigneeEditBtn';
        editBtn.title = 'Bearbeiten';
        editBtn.setAttribute('aria-label', 'Bearbeiten');
        editBtn.innerHTML = '<span class="ms">edit</span>';
        editBtn.addEventListener('click', () => {
          const nextState = !row.classList.contains('editing');
          row.classList.toggle('editing', nextState);
          if(nextState) editTitle.focus();
        });
        actions.appendChild(editBtn);

        row.appendChild(cb);
        row.appendChild(body);
        row.appendChild(actions);
        list.appendChild(row);
      });

      block.appendChild(list);
      container.appendChild(block);
    });

    assigneeViewEl.appendChild(container);
  }

  function renderTimeline(){
    const timeline = timelineViewEl;
    if(!timeline) return;
    timeline.innerHTML = '';

    const dayMs = 86400000;
    const timelineStyle = getComputedStyle(timeline);
    const labelWidth = parseInt(timelineStyle.getPropertyValue('--timeline-label-width'), 10) || 220;
    const parseDate = (ymd) => {
      if(!ymd) return null;
      const parts = ymd.split('-').map(Number);
      if(parts.length !== 3 || parts.some(n => Number.isNaN(n))) return null;
      return new Date(Date.UTC(parts[0], parts[1]-1, parts[2]));
    };
    const startOfToday = () => {
      const now = new Date();
      return new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
    };
    const diffDays = (later, earlier) => {
      const toUtcMidnight = (date) => Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      return Math.round((toUtcMidnight(later) - toUtcMidnight(earlier)) / dayMs);
    };
    const clamp = (val, min, max) => Math.min(max, Math.max(min, val));
    const formatDate = (d) => `${String(d.getUTCDate()).padStart(2,'0')}.${String(d.getUTCMonth()+1).padStart(2,'0')}.${d.getUTCFullYear()}`;
    const daysInMonth = (yr, mo) => new Date(Date.UTC(yr, mo + 1, 0)).getUTCDate();
    const addInterval = (baseDate, freq, interval) => {
      const year = baseDate.getUTCFullYear();
      const month = baseDate.getUTCMonth();
      const day = baseDate.getUTCDate();
      switch(freq){
        case 'daily':
          return new Date(Date.UTC(year, month, day + interval));
        case 'weekly':
          return new Date(Date.UTC(year, month, day + interval * 7));
        case 'monthly': {
          const target = new Date(Date.UTC(year, month + interval, 1));
          const maxDay = daysInMonth(target.getUTCFullYear(), target.getUTCMonth());
          target.setUTCDate(Math.min(day, maxDay));
          return target;
        }
        case 'yearly': {
          const target = new Date(Date.UTC(year + interval, month, 1));
          const maxDay = daysInMonth(target.getUTCFullYear(), target.getUTCMonth());
          target.setUTCDate(Math.min(day, maxDay));
          return target;
        }
        default:
          return null;
      }
    };
    const isoDay = (date) => ((date.getUTCDay() + 6) % 7) + 1;
    const repeatLimit = (spec) => {
      if(!spec || typeof spec !== 'object') return 0;
      if(Number.isFinite(spec.count) && spec.count > 0) return Math.min(Math.floor(spec.count), 1000);
      if(spec.end && parseDate(spec.end)) return 1000;
      if(spec.until && parseDate(spec.until)) return 1000;
      return 24;
    };
    const generateOccurrences = (baseDate, spec, windowStartMs, windowEndMs) => {
      if(!(baseDate instanceof Date)) return [];
      const normalized = normalizeRepeatSpec(spec, { dueDate: baseDate });
      if(!normalized) return [];
      const startAnchor = normalized.start ? parseDate(normalized.start) : null;
      const anchorDate = (startAnchor instanceof Date && !Number.isNaN(startAnchor.getTime())) ? startAnchor : baseDate;
      const startLimitMs = (startAnchor instanceof Date && !Number.isNaN(startAnchor.getTime())) ? startAnchor.getTime() : null;
      const endLimitMs = normalized.end ? (parseDate(normalized.end)?.getTime() ?? null) : null;
      const untilMsRaw = normalized.until ? (parseDate(normalized.until)?.getTime() ?? null) : null;
      const limitMs = endLimitMs ?? untilMsRaw;
      const interval = Number.isFinite(normalized.interval) && normalized.interval > 0 ? Math.floor(normalized.interval) : 1;
      const cap = Math.max(1, repeatLimit(normalized));
      const occurrences = [];
      let produced = 0;
      const pushOccurrence = (occMs) => {
        if(limitMs && occMs > limitMs) return false;
        produced++;
        if((!windowStartMs || occMs >= windowStartMs) && (!windowEndMs || occMs <= windowEndMs)){
          occurrences.push(new Date(occMs));
        }
        if(Number.isFinite(normalized.count) && normalized.count > 0 && produced >= normalized.count) return false;
        if(produced >= cap) return false;
        return true;
      };
      if(normalized.freq === 'weekly'){
        const days = normalizeRepeatDays(normalized.days);
        const baseDay = isoDay(anchorDate);
        const effectiveDays = days.length ? days : [baseDay];
        const dayOffsets = effectiveDays
          .map(day => day - baseDay)
          .sort((a, b) => a - b);
        const baseMs = anchorDate.getTime();
        let weekIndex = 0;
        while(produced < cap){
          for(const offset of dayOffsets){
            const occMs = baseMs + (weekIndex * interval * 7 + offset) * dayMs;
            if(limitMs && occMs > limitMs) return occurrences;
            if(startLimitMs && occMs < startLimitMs) continue;
            if(weekIndex === 0 && occMs < baseMs) continue;
            if(!pushOccurrence(occMs)) return occurrences;
          }
          weekIndex++;
          if(limitMs && (baseMs + weekIndex * interval * 7 * dayMs) > limitMs) break;
        }
      }else if(normalized.freq === 'monthly'){
        const days = normalizeRepeatDays(normalized.days);
        const baseMs = anchorDate.getTime();
        if(!days.length){
          let current = new Date(baseMs);
          while(produced < cap){
            const currentMs = current.getTime();
            if(limitMs && currentMs > limitMs) break;
            if(startLimitMs && currentMs < startLimitMs){
              current = addInterval(current, 'monthly', interval);
              if(!current || Number.isNaN(current.getTime())) break;
              continue;
            }
            if(!pushOccurrence(currentMs)) break;
            const next = addInterval(current, 'monthly', interval);
            if(!next || next.getTime() === current.getTime()) break;
            current = next;
          }
        }else{
          const effectiveDays = days.slice().sort((a, b) => a - b);
          const baseOrdinal = clamp(Math.floor((anchorDate.getUTCDate() - 1) / 7) + 1, 1, 5);
          const baseYear = anchorDate.getUTCFullYear();
          const baseMonth = anchorDate.getUTCMonth();
          const monthOccurrences = (year, month) => {
            const dim = daysInMonth(year, month);
            const firstOfMonth = new Date(Date.UTC(year, month, 1));
            const firstIso = isoDay(firstOfMonth);
            const list = [];
            effectiveDays.forEach(day => {
              if(!Number.isFinite(day)) return;
              const firstOffset = ((day - firstIso + 7) % 7 + 7) % 7;
              const firstDay = 1 + firstOffset;
              let occDay = firstDay + (baseOrdinal - 1) * 7;
              if(occDay > dim){
                const maxSteps = Math.floor((dim - firstDay) / 7);
                occDay = firstDay + Math.max(0, maxSteps) * 7;
              }
              if(occDay >= 1 && occDay <= dim){
                list.push(new Date(Date.UTC(year, month, occDay)));
              }
            });
            list.sort((a, b) => a.getTime() - b.getTime());
            return list;
          };
          let step = 0;
          while(produced < cap){
            const offsetMonths = step * interval;
            const monthStart = new Date(Date.UTC(baseYear, baseMonth + offsetMonths, 1));
            if(limitMs && monthStart.getTime() > limitMs) break;
            const targetYear = monthStart.getUTCFullYear();
            const targetMonth = monthStart.getUTCMonth();
            const occList = monthOccurrences(targetYear, targetMonth);
            for(const occ of occList){
              const occMs = occ.getTime();
              if(limitMs && occMs > limitMs) return occurrences;
              if(startLimitMs && occMs < startLimitMs) continue;
              if(step === 0 && occMs < baseMs) continue;
              if(!pushOccurrence(occMs)) return occurrences;
            }
            step++;
          }
        }
      }else{
        let current = new Date(anchorDate.getTime());
        while(produced < cap){
          const currentMs = current.getTime();
          if(limitMs && currentMs > limitMs) break;
          if(startLimitMs && currentMs < startLimitMs){
            current = addInterval(current, normalized.freq, interval);
            if(!current || Number.isNaN(current.getTime())) break;
            continue;
          }
          if(!pushOccurrence(currentMs)) break;
          const next = addInterval(current, normalized.freq, interval);
          if(!next || next.getTime() === current.getTime()) break;
          current = next;
        }
      }
      return occurrences;
    };
    const activeTab = (state.timelineTab && state.tabs?.includes(state.timelineTab)) ? state.timelineTab : 'Alle';
    const teamList = Array.isArray(state.team) ? state.team : [];
    const selectedAssignees = Array.isArray(state.timelineAssignees) ? state.timelineAssignees : [];
    const assigneeFilterActive = selectedAssignees.length > 0;
    const assigneeSet = new Set(selectedAssignees);
    const includeUnassigned = assigneeSet.has(ASSIGNEE_UNASSIGNED);
    const matchesAssignee = assignee => {
      if(!assigneeFilterActive) return true;
      const normalized = typeof assignee === 'string' ? assignee.trim() : '';
      if(normalized) return assigneeSet.has(normalized);
      return includeUnassigned;
    };

    const tasks = [];
    (state.projects || []).forEach(p => {
      const tabName = p.tab || 'Alle';
      if(activeTab !== 'Alle' && tabName !== activeTab) return;
      const projectStart = parseDate(p.date);
      (p.todos || []).forEach((t, todoIndex) => {
        if(!t) return;
        const todoStart = parseDate(t.start) || projectStart;
        const todoAssignee = typeof t.assignee === 'string' ? t.assignee.trim() : '';
        if(t.due && !t.done){
          const dueDate = parseDate(t.due);
          if(dueDate){
            if(!(assigneeFilterActive && !matchesAssignee(todoAssignee))){
              const repeatSpec = normalizeRepeatSpec(t.repeat, { dueDate: t.due });
              if(repeatSpec?.freq){
                tasks.push({
                  type: 'milestone',
                  project: p,
                  todo: t,
                  baseDue: dueDate,
                  dueDate,
                  startDate: todoStart || dueDate,
                  todoIndex,
                  subIndex: null,
                  parentTodo: null,
                  repeat: repeatSpec
                });
              }else{
                tasks.push({ type: 'bar', project: p, todo: t, dueDate, startDate: todoStart || dueDate, todoIndex, subIndex: null, parentTodo: null });
              }
            }
          }
        }

        const subtasks = Array.isArray(t.subtasks) ? t.subtasks : [];
        subtasks.forEach((sub, subIndex) => {
          if(!sub || sub.done || !sub.due) return;
          const subDue = parseDate(sub.due);
          if(!subDue) return;
          const subAssignee = typeof sub.assignee === 'string' ? sub.assignee.trim() : '';
          if(assigneeFilterActive && !matchesAssignee(subAssignee)) return;
          tasks.push({
            type: 'bar',
            project: p,
            todo: sub,
            dueDate: subDue,
            startDate: todoStart || projectStart || subDue,
            todoIndex,
            subIndex,
            parentTodo: t
          });
        });
      });
    });

    const today = startOfToday();
    const todayMs = today.getTime();
    tasks.forEach(task => {
      if(task.type === 'milestone'){
        const allOccurrences = generateOccurrences(task.baseDue, task.repeat, null, null);
        const firstMs = allOccurrences.length ? allOccurrences[0].getTime() : task.dueDate.getTime();
        const lastMs = allOccurrences.length ? allOccurrences[allOccurrences.length - 1].getTime() : task.dueDate.getTime();
        task.firstOccurrenceMs = firstMs;
        task.lastOccurrenceMs = lastMs;
        const upcoming = generateOccurrences(task.baseDue, task.repeat, todayMs, null);
        const nextMs = upcoming.length ? upcoming[0].getTime() : lastMs;
        task.sortDueMs = nextMs;
        task.nextOccurrenceMs = nextMs;
      }else{
        const dueMs = task.dueDate.getTime();
        const startMs = task.startDate.getTime();
        task.firstOccurrenceMs = Math.min(startMs, dueMs);
        task.lastOccurrenceMs = dueMs;
        task.sortDueMs = dueMs;
      }
    });
    tasks.forEach(task => {
      const dueMs = task.sortDueMs ?? task.dueDate.getTime();
      task.daysToDue = diffDays(new Date(dueMs), today);
      task.isOverdue = dueMs < todayMs;
    });
    tasks.sort((a,b) => {
      if(a.isOverdue && !b.isOverdue) return -1;
      if(!a.isOverdue && b.isOverdue) return 1;
      const aMs = a.sortDueMs ?? (a.dueDate?.getTime() || 0);
      const bMs = b.sortDueMs ?? (b.dueDate?.getTime() || 0);
      return aMs - bMs;
    });
    if(tasks.length === 0){
      const msg = document.createElement('p');
      msg.textContent = 'Keine To‑Dos mit Deadline vorhanden';
      msg.style.color = 'var(--muted)';
      timeline.appendChild(msg);
      return;
    }

    const earliestStart = tasks.reduce((min, task) => Math.min(min, task.startDate.getTime()), todayMs);
    const earliestDue = tasks.reduce((min, task) => {
      const candidate = task.type === 'milestone'
        ? (task.firstOccurrenceMs ?? task.dueDate.getTime())
        : task.dueDate.getTime();
      return Math.min(min, candidate);
    }, todayMs);
    const latestDue = tasks.reduce((max, task) => {
      const candidate = task.type === 'milestone'
        ? (task.lastOccurrenceMs ?? task.dueDate.getTime())
        : task.dueDate.getTime();
      return Math.max(max, candidate);
    }, todayMs);
    const overdueSpan = Math.max(0, diffDays(today, new Date(earliestDue)));
    const futureSpan = Math.max(0, diffDays(new Date(latestDue), today));
    const paddingPast = Math.min(120, Math.max(7, overdueSpan + 7));
    const paddingFuture = Math.min(120, Math.max(14, futureSpan + 14));
    const minPastDate = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth() - 1, today.getUTCDate()));
    let startDate = new Date(Math.min(earliestStart, earliestDue, today.getTime()) - paddingPast * dayMs);
    let maxDate = new Date(Math.max(latestDue, today.getTime()) + paddingFuture * dayMs);
    startDate = startOfIsoWeek(startDate);
    maxDate = endOfIsoWeek(maxDate);
    if(startDate.getTime() < minPastDate.getTime()){
      startDate = new Date(minPastDate.getTime());
    }
    if(maxDate.getTime() < startDate.getTime()){
      maxDate = new Date(startDate.getTime());
    }
    let rangeDays = Math.max(1, diffDays(maxDate, startDate) + 1);
    const timelineStartMs = startDate.getTime();
    const timelineEndMs = maxDate.getTime();

    const MAX_MARKERS = 1000;
    let markerCount = 0;
    tasks.forEach(task => {
      if(task.type === 'milestone'){
        const allowance = MAX_MARKERS - markerCount;
        if(allowance <= 0){
          task.milestones = [];
          return;
        }
        const occurrences = generateOccurrences(task.baseDue, task.repeat, timelineStartMs, timelineEndMs);
        if(occurrences.length > allowance) occurrences.length = allowance;
        markerCount += occurrences.length;
        task.milestones = occurrences;
      }
    });

    const renderTasks = tasks.filter(task => task.type !== 'milestone' || (task.milestones && task.milestones.length));
    if(renderTasks.length === 0){
      const msg = document.createElement('p');
      msg.textContent = 'Keine To‑Dos im sichtbaren Zeitraum.';
      msg.style.color = 'var(--muted)';
      timeline.appendChild(msg);
      return;
    }

    const baseWidth = Math.max(timeline.clientWidth || timeline.offsetWidth || 0, 960);
    const targetDays = Math.min(rangeDays, 120);
    const zoomConfig = TIMELINE_ZOOMS.find(z => z.value === state.timelineZoom) || TIMELINE_ZOOMS[TIMELINE_ZOOMS.length - 1];
    if(state.timelineZoom !== zoomConfig.value){
      state.timelineZoom = zoomConfig.value;
      updateTimelineZoomIndicator(zoomConfig.value);
    } else {
      updateTimelineZoomIndicator(zoomConfig.value);
    }
    timeline.dataset.zoom = zoomConfig.value;
    let pxPerDay = Math.floor((baseWidth - labelWidth - 40) / Math.max(1, targetDays));
    if(!Number.isFinite(pxPerDay) || pxPerDay <= 0) pxPerDay = zoomConfig.min;
    pxPerDay = clamp(pxPerDay, zoomConfig.min, zoomConfig.max);
    timeline.style.setProperty('--timeline-px-day', `${pxPerDay}px`);
    timeline.style.setProperty('--timeline-grid-step', `${pxPerDay * (zoomConfig.unitDays || 1)}px`);
    const configuredRow = parseInt(timelineStyle.getPropertyValue('--timeline-row-height'), 10) || 40;
    const rowHeight = Math.max(40, configuredRow);
    const barHeight = Math.max(12, Math.round(rowHeight * 0.35));
    timeline.style.setProperty('--timeline-row-height', `${rowHeight}px`);
    timeline.style.setProperty('--timeline-bar-height', `${barHeight}px`);

    const monthNames = ['Jan','Feb','Mär','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez'];
    const monthsRow = document.createElement('div');
    monthsRow.className = 'timelineMonths';
    let iDay = 0;
    while(iDay < rangeDays){
      const current = new Date(startDate.getTime() + iDay * dayMs);
      const monthEnd = new Date(Date.UTC(current.getUTCFullYear(), current.getUTCMonth() + 1, 0));
      const endOffsetRaw = diffDays(monthEnd, startDate) + 1;
      const endOffset = Math.min(rangeDays, endOffsetRaw);
      let daysInSeg = endOffset - iDay;
      if(daysInSeg <= 0){ daysInSeg = 1; }
      const mCell = document.createElement('div');
      mCell.className = 'timeline-month';
      mCell.style.width = `${daysInSeg * pxPerDay}px`;
      const y = current.getUTCFullYear();
      mCell.textContent = `${monthNames[current.getUTCMonth()]} ${String(y).slice(-2)}`;
      monthsRow.appendChild(mCell);
      iDay += daysInSeg;
    }
    timeline.appendChild(monthsRow);

    const weeksRow = document.createElement('div');
    weeksRow.className = 'timelineWeeks';
    const totalWeeks = Math.ceil(rangeDays / 7);
    for(let w=0; w<totalWeeks; w++){
      const weekStartDate = new Date(startDate.getTime() + w * 7 * dayMs);
      const iso = isoWeekOf(weekStartDate);
      const segDays = Math.min(7, rangeDays - w * 7);
      const wCell = document.createElement('div');
      wCell.className = 'timeline-week';
      wCell.style.width = `${Math.max(segDays, 1) * pxPerDay}px`;
      const label = `KW ${String(iso.week).padStart(2,'0')}`;
      wCell.textContent = label;
      wCell.title = `${label} / ${iso.year}`;
      weeksRow.appendChild(wCell);
    }
    timeline.appendChild(weeksRow);

    if(zoomConfig.showDays){
      const daysRow = document.createElement('div');
      daysRow.className = 'timelineDays';
      for(let i=0; i<rangeDays; i++){
        const d = new Date(startDate.getTime() + i * dayMs);
        const cell = document.createElement('div');
        cell.className = 'timeline-day';
        cell.style.width = `${pxPerDay}px`;
        let label = '';
        if(zoomConfig.value === 'days'){
          label = d.getUTCDate();
        }else if(zoomConfig.value === 'compact'){
          const dow = d.getUTCDay();
          if(dow === 1){
            label = `Mo ${d.getUTCDate()}`;
          }else if(dow === 3){
            label = 'Mi';
          }else if(dow === 5){
            label = 'Fr';
          }
        }
        cell.textContent = label;
        daysRow.appendChild(cell);
      }
      timeline.appendChild(daysRow);
    }

    timeline.setAttribute('data-taskcount', renderTasks.length);

    const chart = document.createElement('div');
    chart.className = 'timelineChart';
    chart.style.height = `${renderTasks.length * rowHeight}px`;
    const chartWidth = rangeDays * pxPerDay;
    chart.style.width = `${chartWidth}px`;
    timeline.appendChild(chart);

    const weekLines = document.createElement('div');
    weekLines.className = 'timeline-week-boundaries';
    let lastBoundary = null;
    for(let offset = 0; offset <= rangeDays; offset += 7){
      const left = offset * pxPerDay;
      if(left > chartWidth + 1) break;
      const line = document.createElement('div');
      line.className = 'timeline-week-line';
      line.style.left = `${left}px`;
      weekLines.appendChild(line);
      lastBoundary = left;
    }
    if(lastBoundary === null || Math.abs(lastBoundary - chartWidth) > 1){
      const endLine = document.createElement('div');
      endLine.className = 'timeline-week-line';
      endLine.style.left = `${chartWidth}px`;
      weekLines.appendChild(endLine);
    }
    chart.appendChild(weekLines);

    const todayLine = document.createElement('div');
    todayLine.className = 'today-line';
    const todayOffsetDays = clamp(diffDays(today, startDate), 0, rangeDays);
    const isDayLikeZoom = zoomConfig.value === 'days' || zoomConfig.value === 'compact';
    let todayLeftPx = todayOffsetDays * pxPerDay;
    if(isDayLikeZoom){
      todayLeftPx += pxPerDay / 2;
    }
    const todayMarkerPx = Math.max(0, Math.min(todayLeftPx, chartWidth));
    todayLine.style.left = `${todayMarkerPx}px`;
    todayLine.style.height = `${renderTasks.length * rowHeight}px`;
    chart.appendChild(todayLine);

    let lastProjectId = null
    renderTasks.forEach((task, idx) => {
      const row = document.createElement('div');
      row.className = 'timeline-row' + (task.type === 'milestone' ? ' milestone-row' : '');
      row.style.top = `${idx * rowHeight}px`;
      const projectId = task.project?.id || '';
      if(projectId){
        row.dataset.projectId = projectId;
        if(projectId !== lastProjectId) row.classList.add('project-start');
      }
      lastProjectId = projectId;

      const label = document.createElement('div');
      label.className = 'timeline-label';
      const projNum = task.project.number || '';
      const baseText = (task.todo?.text || '').trim();
      const parentText = (task.parentTodo?.text || '').trim();
      const combinedText = (task.subIndex != null && parentText)
        ? (baseText ? `${parentText} → ${baseText}` : parentText)
        : baseText;
      const labelText = `${projNum} – ${combinedText || baseText || parentText || ''}`;
      const textSpan = document.createElement('span');
      textSpan.className = 'timeline-label-text';
      textSpan.textContent = labelText;
      const bubble = document.createElement('div');
      bubble.className = 'timeline-label-bubble';
      bubble.textContent = labelText;
      label.appendChild(textSpan);
      label.appendChild(bubble);
      const projLabel = `${projNum ? projNum + ' · ' : ''}${task.project.name || ''}`.trim();
      label.title = projLabel;
      row.appendChild(label);

      if(task.type === 'milestone'){
        const markerLayer = document.createElement('div');
        markerLayer.className = 'timeline-marker-layer';
        (task.milestones || []).forEach(date => {
          const occMs = date.getTime();
          const offsetDays = (occMs - timelineStartMs) / dayMs;
          const clampedOffset = clamp(offsetDays, 0, rangeDays);
          let leftPx = clampedOffset * pxPerDay;
          if(isDayLikeZoom){ leftPx += pxPerDay / 2; }
          const clampedLeft = Math.max(0, Math.min(chartWidth, leftPx));
          const marker = document.createElement('div');
          marker.className = 'timeline-milestone';
          marker.style.left = `${clampedLeft}px`;
          marker.style.background = task.project.color || 'var(--accent)';
          marker.dataset.id = `${task.project.id || ''}:${task.todoIndex}`;
          const tooltipText = task.todo?.text || '';
          const tooltip = `${projLabel || 'Projekt'} · ${tooltipText} · Fällig am ${formatDate(date)}`;
          marker.title = tooltip.trim().replace(/^ · /, '');
          markerLayer.appendChild(marker);
        });
        row.appendChild(markerLayer);
      }else{
        const { dueDate, startDate: start } = task;
        const effectiveStart = task.isOverdue
          ? (start <= dueDate ? start : dueDate)
          : today;
        const startMs = effectiveStart.getTime();
        const inclusiveSpanDays = Math.max(1, diffDays(dueDate, effectiveStart) + 1);
        const startVisibleMs = Math.min(Math.max(startMs, timelineStartMs), timelineEndMs);
        const dueOffsetDays = diffDays(dueDate, startDate);
        const clampedDueDays = clamp(dueOffsetDays, 0, rangeDays);
        const dueCenterPx = clampedDueDays * pxPerDay + (pxPerDay / 2);
        let leftPxRaw = ((startVisibleMs - timelineStartMs) / dayMs) * pxPerDay;
        if(!task.isOverdue && isDayLikeZoom){
          leftPxRaw += pxPerDay / 2;
        }
        let leftPx = Math.max(0, Math.min(chartWidth, leftPxRaw));
        let endPx = clamp(dueCenterPx, 0, chartWidth);
        if(endPx > leftPx){
          const gapPx = Math.min(Math.max(pxPerDay * 0.1, 2), endPx - leftPx);
          endPx -= gapPx;
        }
        if(endPx < leftPx){
          endPx = leftPx;
        }
        let widthPx = Math.max(0, endPx - leftPx);
        const rangeLabel = inclusiveSpanDays > 1 ? `${inclusiveSpanDays} Tage` : '1 Tag';
        const parentLabel = (task.parentTodo?.text || '').trim();
        const childLabel = (task.todo?.text || '').trim();
        const taskLabel = (task.subIndex != null && parentLabel)
          ? (childLabel ? `${parentLabel} → ${childLabel}` : parentLabel)
          : (childLabel || parentLabel || 'To-Do');
        const tooltip = `${taskLabel}\n${formatDate(effectiveStart)} → ${formatDate(dueDate)} (${rangeLabel})\n` + (task.daysToDue >= 0 ? `Noch ${task.daysToDue} Tag${task.daysToDue===1?'':'e'}` : `Überfällig seit ${Math.abs(task.daysToDue)} Tag${Math.abs(task.daysToDue)===1?'':'en'}`);

        row.classList.toggle('overdue', task.isOverdue);
        if(task.isOverdue){
          const overdueBar = document.createElement('div');
          overdueBar.className = 'timeline-bar overdue';
          const overdueDays = Math.abs(task.daysToDue);
          const dueOffset = diffDays(dueDate, startDate);
          const overdueStartDays = clamp(dueOffset, 0, rangeDays);
          let overdueLeftPx = dueOffset < 0 ? 0 : overdueStartDays * pxPerDay;
          let clampedLeft = Math.max(0, Math.min(overdueLeftPx, chartWidth));
          let overdueWidthPx = todayMarkerPx - clampedLeft;
          if(overdueWidthPx <= 0){
            overdueWidthPx = pxPerDay * 0.75;
            clampedLeft = Math.max(0, Math.min(todayMarkerPx - overdueWidthPx, chartWidth));
          }
          if(clampedLeft + overdueWidthPx > chartWidth){
            overdueWidthPx = Math.max(chartWidth - clampedLeft, pxPerDay * 0.5);
          }
          overdueWidthPx = Math.max(overdueWidthPx, pxPerDay * 0.5);
          overdueBar.style.left = `${clampedLeft}px`;
          overdueBar.style.width = `${overdueWidthPx}px`;
          const span = document.createElement('span');
          span.textContent = `${overdueDays} Tag${overdueDays === 1 ? '' : 'e'} überfällig`;
          overdueBar.appendChild(span);
          overdueBar.title = tooltip;
          row.appendChild(overdueBar);
        }else{
          const bar = document.createElement('div');
          bar.className = 'timeline-bar';
          bar.style.left = `${leftPx}px`;
          bar.style.width = `${widthPx}px`;
          bar.title = tooltip;
          if(task.todo.done){ bar.style.background = 'var(--muted)'; }
          else if(task.daysToDue < 0){ bar.style.background = 'var(--danger)'; }
          else { bar.style.background = task.project.color || 'var(--accent)'; }
          row.appendChild(bar);
        }
      }

      chart.appendChild(row);
    });

    const visibleWidth = (timeline.clientWidth || 0) - labelWidth;
    const scrollTarget = todayMarkerPx - (visibleWidth > 0 ? visibleWidth / 2 : 0);
    timeline.scrollLeft = scrollTarget > 0 ? scrollTarget : 0;
  }


  function renderDispoSummaryMessage(){
    if(!dispoAssignSummaryEl) return;
    dispoAssignSummaryEl.innerHTML = '';
    if(lastDispoAssignInfo.count > 0){
      const { count, label } = lastDispoAssignInfo;
      const strong = document.createElement('strong');
      strong.textContent = String(count);
      const noun = document.createElement('span');
      noun.textContent = ` ${count === 1 ? 'To-Do' : 'To-Dos'} erstellt`;
      dispoAssignSummaryEl.appendChild(strong);
      dispoAssignSummaryEl.appendChild(noun);
      if(label){
        const labelSpan = document.createElement('span');
        labelSpan.textContent = ` für ${label}`;
        dispoAssignSummaryEl.appendChild(labelSpan);
      }
    }else{
      dispoAssignSummaryEl.textContent = 'Noch keine To-Dos zugewiesen.';
    }
  }

  function renderDispo(){
    if(!dispoView || !dispoListEl) return;
    ensureDispo();
    if(dispoBreadcrumbsEl) dispoBreadcrumbsEl.innerHTML = '';
    dispoListEl.innerHTML = '';
    const entries = (state.dispo || []).slice();
    let normalized = false;
    const structure = new Map();
    const currentWeek = isoWeekOf(new Date());

    renderDispoSummaryMessage();

    entries.forEach(entry => {
      if(!entry || typeof entry !== 'object') return;
      if(!entry.id){ entry.id = uid(); normalized = true; }
      const rawYear = Number(entry.year);
      if(Number.isFinite(rawYear)){ entry.year = rawYear; }
      else { entry.year = currentWeek.year; normalized = true; }
      let rawWeek = Number(entry.week);
      if(!Number.isFinite(rawWeek)) rawWeek = currentWeek.week;
      rawWeek = Math.max(1, Math.min(53, rawWeek));
      if(rawWeek !== entry.week){ entry.week = rawWeek; normalized = true; }
      if(!Array.isArray(entry.items)){ entry.items = []; normalized = true; }
      entry.items.forEach(item => { if(item && !item.id){ item.id = uid(); normalized = true; } });
    });

    if(!entries.length){
      dispoListEl.classList.remove('chooser');
      const empty = document.createElement('div');
      empty.className = 'dispoEmpty';
      empty.textContent = 'Noch keine Dispo-Einträge erfasst.';
      dispoListEl.appendChild(empty);
      if(dispoBreadcrumbsEl){
        const hint = document.createElement('span');
        hint.textContent = 'Noch keine Dispo-Einträge vorhanden.';
        dispoBreadcrumbsEl.appendChild(hint);
      }
      if(normalized) setDirty(true);
      return;
    }

    entries.sort((a,b) => {
      if(b.year !== a.year) return b.year - a.year;
      return (b.week || 0) - (a.week || 0);
    });

    entries.forEach(entry => {
      const yr = entry.year;
      const wk = entry.week || 1;
      const { start } = weekRange(yr, wk);
      const month = start.getUTCMonth();
      if(!structure.has(yr)) structure.set(yr, new Map());
      const months = structure.get(yr);
      if(!months.has(month)) months.set(month, []);
      months.get(month).push(entry);
    });

    structure.forEach(months => {
      months.forEach(list => {
        list.sort((a,b) => (a.week || 0) - (b.week || 0));
      });
    });

    if(dispoNavigator.year && !structure.has(dispoNavigator.year)){
      dispoNavigator.year = null;
      dispoNavigator.month = null;
    }
    if(dispoNavigator.year && dispoNavigator.month !== null){
      const months = structure.get(dispoNavigator.year);
      if(!months || !months.has(dispoNavigator.month)){
        dispoNavigator.month = null;
      }
    }

    const renderBreadcrumbs = () => {
      if(!dispoBreadcrumbsEl) return;
      dispoBreadcrumbsEl.innerHTML = '';
      const addSep = () => {
        const sep = document.createElement('span');
        sep.className = 'sep';
        sep.textContent = '›';
        dispoBreadcrumbsEl.appendChild(sep);
      };
      const addBtn = (label, active, handler) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = label;
        if(active) btn.classList.add('active');
        if(handler){ btn.addEventListener('click', handler); }
        else { btn.disabled = true; }
        dispoBreadcrumbsEl.appendChild(btn);
      };
      addBtn('Jahre', !dispoNavigator.year, () => {
        dispoNavigator.year = null;
        dispoNavigator.month = null;
        renderDispo();
      });
      if(dispoNavigator.year){
        addSep();
        addBtn(String(dispoNavigator.year), dispoNavigator.month === null, () => {
          dispoNavigator.month = null;
          renderDispo();
        });
        if(dispoNavigator.month !== null){
          addSep();
          const monthLabel = MONTH_NAMES[dispoNavigator.month] || `Monat ${dispoNavigator.month + 1}`;
          addBtn(`${monthLabel} ${dispoNavigator.year}`, true, null);
        }
      }
    };

    const showYearSelection = () => {
      dispoListEl.classList.add('chooser');
      const years = Array.from(structure.keys()).sort((a,b) => b - a);
      years.forEach(year => {
        const months = structure.get(year);
        let weekCount = 0;
        months.forEach(list => { weekCount += list.length; });
        const monthCount = months.size;
        const card = document.createElement('div');
        card.className = 'dispoCard';
        const title = document.createElement('strong');
        title.textContent = String(year);
        const info = document.createElement('span');
        info.textContent = `${weekCount} Woche${weekCount === 1 ? '' : 'n'} in ${monthCount} Monat${monthCount === 1 ? '' : 'en'}`;
        card.appendChild(title);
        card.appendChild(info);
        card.addEventListener('click', () => {
          dispoNavigator.year = year;
          dispoNavigator.month = null;
          renderDispo();
        });
        dispoListEl.appendChild(card);
      });
    };

    const showMonthSelection = year => {
      dispoListEl.classList.add('chooser');
      const months = structure.get(year);
      const monthKeys = Array.from(months.keys()).sort((a,b) => a - b);
      monthKeys.forEach(month => {
        const list = months.get(month) || [];
        const card = document.createElement('div');
        card.className = 'dispoCard';
        const title = document.createElement('strong');
        title.textContent = `${MONTH_NAMES[month] || 'Monat'} ${year}`;
        const info = document.createElement('span');
        info.textContent = `${list.length} Woche${list.length === 1 ? '' : 'n'}`;
        card.appendChild(title);
        card.appendChild(info);
        card.addEventListener('click', () => {
          dispoNavigator.month = month;
          renderDispo();
        });
        dispoListEl.appendChild(card);
      });
    };

    const showWeekEntries = (year, month) => {
      dispoListEl.classList.remove('chooser');
      const months = structure.get(year);
      const list = months ? months.get(month) || [] : [];
      if(!list.length){
        const empty = document.createElement('div');
        empty.className = 'dispoEmpty';
        empty.textContent = 'Für diesen Monat wurden noch keine Wochen erfasst.';
        dispoListEl.appendChild(empty);
        return;
      }
      list.forEach(entry => {
        dispoListEl.appendChild(buildDispoEntry(entry));
      });
    };

    renderBreadcrumbs();

    dispoListEl.classList.remove('chooser');

    if(!dispoNavigator.year){
      showYearSelection();
    }else if(dispoNavigator.month === null){
      showMonthSelection(dispoNavigator.year);
    }else{
      showWeekEntries(dispoNavigator.year, dispoNavigator.month);
    }

    if(normalized) setDirty(true);
  }
  function buildDispoEntry(entry){
    const details = document.createElement('details');
    details.className = 'dispoEntry';
    details.open = entry.collapsed ? false : true;
    details.addEventListener('toggle', () => {
      entry.collapsed = !details.open;
      setDirty(true);
    });
    const summary = document.createElement('summary');
    const titleWrap = document.createElement('div'); titleWrap.className = 'dispoSummaryTitle';
    const weekInfo = isoWeekOf(new Date());
    const year = entry.year || weekInfo.year;
    const week = entry.week || weekInfo.week;
    const heading = document.createElement('span');
    heading.textContent = `KW ${String(week).padStart(2,'0')} · ${formatWeekRange(year, week)}`;
    titleWrap.appendChild(heading);
    if(entry.title){
      const sub = document.createElement('span'); sub.className = 'dispoRange'; sub.textContent = entry.title; titleWrap.appendChild(sub);
    }
    summary.appendChild(titleWrap);
    const meta = document.createElement('span'); meta.className = 'dispoSummaryMeta'; meta.textContent = `${(entry.items||[]).length} To-Dos`;
    summary.appendChild(meta);
    const actions = document.createElement('div'); actions.className = 'dispoSummaryActions';
    const del = document.createElement('button'); del.type = 'button'; del.textContent = 'Löschen'; del.title = 'Dispo-Eintrag entfernen';
    del.addEventListener('click', e => {
      e.preventDefault(); e.stopPropagation();
      if(confirm('Diesen Dispo-Eintrag wirklich löschen?')){
        pushHistory();
        state.dispo = (state.dispo || []).filter(d => d.id !== entry.id);
        setDirty(true);
        render();
      }
    });
    actions.appendChild(del);
    summary.appendChild(actions);
    details.appendChild(summary);

    const body = document.createElement('div'); body.className = 'dispoBody';

    const titleField = document.createElement('div'); titleField.className = 'dispoField';
    const titleLabel = document.createElement('label'); titleLabel.textContent = 'Titel / Fokus';
    const titleInput = document.createElement('input'); titleInput.type = 'text'; titleInput.value = entry.title || '';
    titleInput.placeholder = 'z. B. Themen der Dispo';
    titleInput.addEventListener('change', () => {
      pushHistory();
      entry.title = titleInput.value.trim();
      setDirty(true);
      render();
    });
    titleField.appendChild(titleLabel); titleField.appendChild(titleInput);
    body.appendChild(titleField);

    const notesWrap = document.createElement('div'); notesWrap.className = 'dispoNotes dispoField';
    const notesLabel = document.createElement('label'); notesLabel.textContent = 'Notizen';
    const notesArea = document.createElement('textarea'); notesArea.value = entry.notes || '';
    notesArea.placeholder = 'Protokollnotizen für das Team…';
    notesArea.addEventListener('change', () => {
      pushHistory();
      entry.notes = notesArea.value.trim();
      setDirty(true);
      render();
    });
    notesWrap.appendChild(notesLabel); notesWrap.appendChild(notesArea);
    body.appendChild(notesWrap);

    const itemsWrap = document.createElement('div'); itemsWrap.className = 'dispoItems';
    const head = document.createElement('div'); head.className = 'dispoItemHead';
    head.innerHTML = '<span>Projekt</span><span>Bearbeiter/in</span><span>To-Do</span><span>Deadline</span><span></span>';
    itemsWrap.appendChild(head);
    (entry.items || []).forEach(item => itemsWrap.appendChild(buildDispoItemRow(entry, item)));

    const assignBar = document.createElement('div');
    assignBar.className = 'dispoAssignBar';
    const projectSelect = document.createElement('select');
    projectSelect.className = 'dispoProject';
    const projectDefault = document.createElement('option');
    projectDefault.value = '';
    projectDefault.textContent = state.projects && state.projects.length ? 'Projekt wählen' : 'Keine Projekte verfügbar';
    projectSelect.appendChild(projectDefault);
    const projectOptions = (state.projects || []).slice().sort((a,b) => {
      const aNum = (a.number || '').replace(/[^0-9]/g,'');
      const bNum = (b.number || '').replace(/[^0-9]/g,'');
      const aVal = aNum ? parseInt(aNum, 10) : NaN;
      const bVal = bNum ? parseInt(bNum, 10) : NaN;
      if(Number.isFinite(aVal) && Number.isFinite(bVal) && aVal !== bVal) return aVal - bVal;
      if(Number.isFinite(aVal) && !Number.isFinite(bVal)) return -1;
      if(!Number.isFinite(aVal) && Number.isFinite(bVal)) return 1;
      return (a.number || '').localeCompare(b.number || '');
    }).map(proj => {
      const opt = document.createElement('option');
      opt.value = proj.id || '';
      const labelParts = [];
      if(proj.number) labelParts.push(proj.number);
      if(proj.name) labelParts.push(proj.name);
      opt.textContent = labelParts.join(' · ') || 'Unbenanntes Projekt';
      return opt;
    });
    projectOptions.forEach(opt => projectSelect.appendChild(opt));
    projectSelect.disabled = !projectOptions.length;

    let assignAssignee = null;
    if(Array.isArray(state.team) && state.team.length){
      assignAssignee = document.createElement('select');
      assignAssignee.className = 'dispoAssignee';
      assignAssignee.multiple = true;
      assignAssignee.size = Math.min(3, state.team.length);
      state.team.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        assignAssignee.appendChild(opt);
      });
    }

    const lastItem = Array.isArray(entry.items) && entry.items.length
      ? entry.items[entry.items.length - 1]
      : null;
    if(lastItem){
      const matchProject = (state.projects || []).find(p => projectLabel(p) === lastItem.project);
      if(matchProject) projectSelect.value = matchProject.id || '';
      if(assignAssignee){
        const assignees = String(lastItem.assignee || '')
          .split(/[;,]/)
          .map(part => part.trim())
          .filter(Boolean);
        const assigneeSet = new Set(assignees.map(name => name.toLowerCase()));
        Array.from(assignAssignee.options).forEach(opt => {
          opt.selected = assigneeSet.has(String(opt.value).toLowerCase());
        });
      }
    }

    const todoInput = document.createElement('input');
    todoInput.type = 'text';
    todoInput.className = 'dispoTodoText';
    todoInput.placeholder = 'To-Dos durch ; trennen';

    const dueInput = document.createElement('input');
    dueInput.type = 'date';
    dueInput.className = 'dispoTodoDue';

    const assignBtn = document.createElement('button');
    assignBtn.type = 'button';
    assignBtn.className = 'btnPrimary';
    assignBtn.textContent = 'Zuweisen';

    const updateAssignState = () => {
      assignBtn.disabled = !projectSelect.value;
    };
    updateAssignState();
    projectSelect.addEventListener('change', updateAssignState);

    assignBtn.addEventListener('click', () => {
      const projectId = projectSelect.value;
      if(!projectId){
        projectSelect.focus();
        return;
      }
      const tokens = todoInput.value.split(';').map(s => s.trim()).filter(Boolean);
      if(!tokens.length){
        todoInput.focus();
        return;
      }
      const project = (state.projects || []).find(p => p.id === projectId);
      if(!project){
        showToast('Projekt nicht gefunden.');
        return;
      }
      const dueValue = dueInput.value && parseIsoDate(dueInput.value) ? dueInput.value : '';
      const assigneeValue = assignAssignee
        ? Array.from(assignAssignee.selectedOptions)
          .map(opt => opt.value)
          .filter(value => state.team.includes(value))
          .join(', ')
        : '';
      pushHistory();
      if(!Array.isArray(entry.items)) entry.items = [];
      const labelParts = [];
      if(project.number) labelParts.push(project.number);
      if(project.name) labelParts.push(project.name);
      tokens.forEach(text => {
        project.todos.push({ text, done:false, due:dueValue, assignee:assigneeValue, repeat:null, acknowledged:false, subtasks:[] });
        entry.items.push({
          id: uid(),
          project: labelParts.join(' · ') || 'Projekt',
          assignee: assigneeValue,
          todo: text,
          due: dueValue
        });
      });
      setDirty(true);
      lastDispoAssignInfo = { count: tokens.length, label: labelParts.join(' · ') || 'Projekt' };
      todoInput.value = '';
      updateAssignState();
      showToast(`${tokens.length} To-Do${tokens.length === 1 ? '' : 's'} hinzugefügt`);
      render();
    });

    assignBar.appendChild(projectSelect);
    if(assignAssignee) assignBar.appendChild(assignAssignee);
    assignBar.appendChild(todoInput);
    assignBar.appendChild(dueInput);
    assignBar.appendChild(assignBtn);

    body.appendChild(itemsWrap);
    body.appendChild(assignBar);
    details.appendChild(body);
    return details;
  }
  function buildDispoItemRow(entry, item){
    const row = document.createElement('div'); row.className = 'dispoItemRow';
    const project = document.createElement('input'); project.type='text'; project.value = item.project || ''; project.placeholder='Projekt / Bereich';
    project.addEventListener('change', () => { pushHistory(); item.project = project.value.trim(); setDirty(true); render(); });
    const assignee = document.createElement('input'); assignee.type='text'; assignee.value = item.assignee || ''; assignee.placeholder='Bearbeiter/in';
    assignee.addEventListener('change', () => { pushHistory(); item.assignee = assignee.value.trim(); setDirty(true); render(); });
    const todo = document.createElement('input'); todo.type='text'; todo.value = item.todo || ''; todo.placeholder='Aufgabe';
    todo.addEventListener('change', () => { pushHistory(); item.todo = todo.value.trim(); setDirty(true); render(); });
    const due = document.createElement('input'); due.type='date'; due.value = item.due || '';
    due.addEventListener('change', () => { pushHistory(); item.due = due.value; setDirty(true); render(); });
    const remove = document.createElement('button'); remove.type='button'; remove.innerHTML='&times;'; remove.title='To-Do entfernen';
    remove.addEventListener('click', () => {
      pushHistory();
      entry.items = entry.items.filter(it => it.id !== item.id);
      setDirty(true);
      render();
    });
    row.appendChild(project);
    row.appendChild(assignee);
    row.appendChild(todo);
    row.appendChild(due);
    row.appendChild(remove);
    return row;
  }

  // ===== Warnung für nahe Deadlines =====
  // Die Warnleiste für nahe Deadlines wurde entfernt. Deadlines werden nun über die Timeline sichtbar gemacht.

  // ===== Farb-Popover (OK/Abbrechen) =====
  const colorPop = document.getElementById('colorPop')
  const colorPicker = document.getElementById('colorPicker')
  const colorClear = document.getElementById('colorClear')
  const colorCancel = document.getElementById('colorCancel')
  const colorOk = document.getElementById('colorOk')
  let colorTarget = { project:null, original:'#7c3aed' }

  function openColorPopover(anchor, project){
    colorTarget.project = project
    colorTarget.original = project.color || '#7c3aed'
    colorPicker.value = colorTarget.original
    colorPop.style.display='block'
    if(colorClear){
      colorClear.disabled = !(project.color && project.color.trim())
    }
    // Position neben dem Button
    const r = anchor.getBoundingClientRect()
    colorPop.style.left = (r.left) + 'px'
    colorPop.style.top  = (r.bottom + 8) + 'px'
  }
  document.querySelectorAll('.colorPopover .sw').forEach(sw => sw.addEventListener('click', () => colorPicker.value = sw.dataset.v ))
  if(colorClear){
    colorClear.addEventListener('click', () => {
      if(!colorTarget.project) return
      pushHistory()
      colorTarget.project.color = ''
      setDirty(true)
      colorPop.style.display='none'
      colorClear.disabled = true
      render()
    })
  }
  colorCancel.addEventListener('click', () => { colorPop.style.display='none' })
  colorOk.addEventListener('click', () => {
    if(!colorTarget.project) return
    const v = colorPicker.value
    pushHistory(); colorTarget.project.color = v; setDirty(true); colorPop.style.display='none';
    if(colorClear) colorClear.disabled = false
    render()
  })
  window.addEventListener('resize', () => { if(colorPop.style.display==='block') colorPop.style.display='none' })
  window.addEventListener('scroll', () => { if(colorPop.style.display==='block') colorPop.style.display='none' })

  // ===== Datei Save/Open (mit AutoSave-to-file) =====
  function buildSelfContainedHTML(){
    const html = document.documentElement.cloneNode(true)
    html.querySelector('#APP_STATE').textContent = JSON.stringify(state)
    return '<!DOCTYPE html>\n' + html.outerHTML
  }
  const saveBtn = document.getElementById('saveBtn')
  if(saveBtn){
    saveBtn.onclick = e => { e.preventDefault(); save() }
  }
  const saveFab = document.getElementById('saveFab')
  if(saveFab){
    saveFab.onclick = e => { e.preventDefault(); save() }
  }

  // ===== Events =====
  document.getElementById('printBtn').addEventListener('click', () => window.print())
  document.getElementById('undoBtn').addEventListener('click', undo)
  document.getElementById('redoBtn').addEventListener('click', redo)
  document.getElementById('backupBtn').addEventListener('click', () => {
    const fname = 'projekte-backup-' + new Date().toISOString().replace(/[:.]/g,'-') + '.json'
    const blob = new Blob([JSON.stringify(state,null,2)], {type:'application/json'})
    if(window.showSaveFilePicker){
      window.showSaveFilePicker({ suggestedName: fname, types:[{description:'JSON', accept:{'application/json':['.json']}}]})
      .then(async handle => {
        const w = await handle.createWritable();
        await w.write(blob);
        await w.close();
        showToast('Backup gespeichert');
      })
      .catch(()=>{ /* Abbruch ignorieren */ });
    } else {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = fname;
      a.click();
      URL.revokeObjectURL(a.href);
      showToast('Backup gespeichert');
    }
  });
  const backupLoadBtn = document.getElementById('backupLoadBtn')
  if(backupLoadBtn){
    backupLoadBtn.addEventListener('click', () => {
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = 'application/json,.json'
      input.addEventListener('change', () => {
        const file = input.files && input.files[0]
        if(!file) return
        const reader = new FileReader()
        reader.onload = () => {
          try{
            const loaded = JSON.parse(String(reader.result) || '{}')
            if(!loaded || typeof loaded !== 'object') throw new Error('Ungültiges Backup')
            pushHistory()
            applyLoadedState(loaded, { preserveFilters:false })
            showToast('Backup importiert – Filter zurückgesetzt')
          }catch(err){
            console.error(err)
            alert('Backup konnte nicht geladen werden: ' + (err && err.message ? err.message : err))
          }
        }
        reader.onerror = () => {
          alert('Backup konnte nicht gelesen werden.')
        }
        reader.readAsText(file)
      })
      input.click()
    })
  }

  function importProjectsFromLegacyCsv(rows, headerLower){
    const idx = {
      id: headerLower.findIndex(h => h === 'id' || h.includes('projekt-id')),
      nr: headerLower.findIndex(h => h.includes('projektnummer') || h === 'nr'),
      name: headerLower.findIndex(h => h.includes('projektname') || h === 'name'),
      date: headerLower.findIndex(h => h === 'datum' || (h.includes('datum') && !h.includes('deadline'))),
      deadline: headerLower.findIndex(h => h.includes('deadline') || h.includes('fälligkeit')),
      showDeadline: headerLower.findIndex(h => h.includes('sichtbar') || h.includes('showdeadline')),
      todos: headerLower.findIndex(h => h.includes('todo') || h.includes('aufgaben')),
      notes: headerLower.findIndex(h => h.includes('notiz') || h.includes('notes')),
      tab: headerLower.findIndex(h => h === 'tab' || h.includes('gruppe')),
      folder: headerLower.findIndex(h => h.includes('pfad') || h.includes('ordner')),
      color: headerLower.findIndex(h => h.includes('farbe')),
      collapsed: headerLower.findIndex(h => h.includes('eingeklappt') || h.includes('collapsed')),
      order: headerLower.findIndex(h => h.includes('sort'))
    }
    const boolFrom = (val) => parseCsvBoolean(val)
    pushHistory()
    const initialOrder = state.order && state.order.length ? state.order.slice() : (state.projects || []).map(p => p.id)
    const importedOrder = []
    for(let r=1; r<rows.length; r++){
      const c = rows[r] || []
      if(!c.length || c.every(x => !x)) continue
      const todosRaw = idx.todos>=0 ? (c[idx.todos]||'') : ''
      const todos = todosRaw.split('|')
        .map(s => s.trim()).filter(Boolean)
        .map(item => {
          const done = item.startsWith('[x]')
          const text = item.replace(/^\[(x| )\]\s*/i,'')
          const m = text.match(/^(.*)\s@(\d{4}-\d{2}-\d{2})$/)
          return { text: (m?m[1]:text).trim(), done, due: m?m[2]:'' }
        })

      let projectId = idx.id>=0 ? (c[idx.id]||'').trim() : ''
      if(!projectId) projectId = uid()
      if(state.projects.some(x => x.id === projectId)) projectId = uid()

      const p = {
        id: projectId,
        number: idx.nr>=0 ? (c[idx.nr]||'') : '',
        name: idx.name>=0 ? (c[idx.name]||'') : '',
        date: idx.date>=0 ? (c[idx.date]||'') : '',
        deadline: idx.deadline>=0 ? (c[idx.deadline]||'') : '',
        showDeadline: idx.showDeadline>=0 ? boolFrom(c[idx.showDeadline]) : !!(idx.deadline>=0 && c[idx.deadline]),
        todos,
        notes: idx.notes>=0 ? (c[idx.notes]||'') : '',
        tab: (idx.tab>=0 && c[idx.tab]) ? c[idx.tab] : (state.currentTab||'Alle'),
        folder: idx.folder>=0 ? (c[idx.folder]||'') : '',
        color: idx.color>=0 ? (c[idx.color]||'') : '',
        collapsed: idx.collapsed>=0 ? boolFrom(c[idx.collapsed]) : false,
        emptyDone: false
      }
      state.projects.push(p)
      if(p.tab && !state.tabs.includes(p.tab) && p.tab!=='Alle') state.tabs.push(p.tab)
      if(idx.order>=0){
        const sortToken = Number((c[idx.order]||'').trim())
        if(Number.isFinite(sortToken)) importedOrder.push({ id: p.id, order: sortToken })
      }
    }
    if(importedOrder.length){
      importedOrder.sort((a,b) => a.order - b.order)
      const orderedIds = importedOrder.map(o => o.id)
      const merged = initialOrder.filter(id => !orderedIds.includes(id))
      importedOrder.forEach(({id}) => merged.push(id))
      state.order = merged
      state.orderByTab['Alle'] = merged.slice()
      state.filters.sort = 'manual'
    }else{
      const merged = initialOrder.slice()
      state.projects.forEach(proj => { if(!merged.includes(proj.id)) merged.push(proj.id) })
      state.order = merged
      state.orderByTab['Alle'] = merged.slice()
    }
    setDirty(true); render(); showToast('CSV importiert')
  }

  function importProjectsFromDetailedCsv(rows, header, headerLower){
    const findIndex = (keywords) => {
      for(let i=0; i<headerLower.length; i++){
        const name = headerLower[i]
        for(const keyword of keywords){
          if(name === keyword || name.includes(keyword)) return i
        }
      }
      return -1
    }
    const idx = {
      projectId: findIndex(['projektid','projectid','projekt-id','project-id','id']),
      projectNumber: findIndex(['projektnummer','projectnumber','nummer','nr']),
      projectName: findIndex(['projektname','projectname','name']),
      projectTab: findIndex(['tab','gruppe']),
      projectNotes: findIndex(['projektnotizenhtml','projectnotes','notizen','notes','beschreibung']),
      projectFolder: findIndex(['projektpfad','projectpath','pfad','ordner','folder']),
      projectColor: findIndex(['projektfarbe','projectcolor','farbe','color']),
      projectCollapsed: findIndex(['projekteingeklappt','collapsed']),
      projectDeadline: findIndex(['projektdeadline','deadline']),
      projectShowDeadline: findIndex(['projektdeadlinesichtbar','showdeadline','deadlinesichtbar']),
      projectEmptyDone: findIndex(['projektleererledigt','emptydone','leer erledigt']),
      projectDate: findIndex(['projektdatum','projectdate','startdatum']),
      projectSort: findIndex(['projektsortierung','sortierung','sort'])
    }
    const todoIdx = {
      type: findIndex(['todotyp','todo typ','todotype']),
      todoIndex: findIndex(['todoindex','todo index']),
      subIndex: findIndex(['subtaskindex','subindex','subtask index']),
      text: findIndex(['todotext','todo text','aufgabe']),
      done: findIndex(['tododone','todo done','erledigt']),
      start: findIndex(['todostart']),
      due: findIndex(['tododue','todo due','fällig']),
      assignee: findIndex(['todoassignee','bearbeiter','assignee']),
      ack: findIndex(['todoacknowledged','acknowledged','gelesen']),
      repeatFreq: findIndex(['todorepeatfreq','repeatfreq','frequenz']),
      repeatInterval: findIndex(['todorepeatinterval','repeatinterval','intervall']),
      repeatCount: findIndex(['todorepeatcount','repeatcount']),
      repeatStart: findIndex(['todorepeatstart','repeatstart','serienstart']),
      repeatEnd: findIndex(['todorepeatend','repeatend','serienende']),
      repeatUntil: findIndex(['todorepeatuntil','repeatuntil','enddatum']),
      repeatDays: findIndex(['todorepeatdays','repeatdays']),
      parentText: findIndex(['parenttodotext','parenttodo','parent'])
    }
    const boolFrom = (val) => parseCsvBoolean(val)
    const projectRecords = new Map()
    const createdProjects = []
    const sortEntries = []

    for(let r=1; r<rows.length; r++){
      const rawCells = rows[r] || []
      if(!rawCells.length || rawCells.every(cell => !cell)) continue
      const cells = rawCells.map(val => val == null ? '' : String(val))
      const projectIdRaw = idx.projectId >= 0 ? cells[idx.projectId].trim() : ''
      const key = projectIdRaw || `auto-${r}`
      let record = projectRecords.get(key)
      if(!record){
        const project = {
          id: projectIdRaw || uid(),
          number: '',
          name: '',
          tab: 'Alle',
          notes: '',
          folder: '',
          color: '',
          collapsed: false,
          deadline: '',
          showDeadline: false,
          emptyDone: false,
          date: '',
          todos: []
        }
        record = { project, todoEntries: new Map(), todoOrder: [], sortCaptured:false }
        projectRecords.set(key, record)
        createdProjects.push(project)
      }

      const project = record.project
      if(idx.projectNumber >=0 && cells[idx.projectNumber] !== undefined) project.number = cells[idx.projectNumber]
      if(idx.projectName >=0 && cells[idx.projectName] !== undefined) project.name = cells[idx.projectName]
      if(idx.projectTab >=0 && cells[idx.projectTab] !== undefined){
        const tabValue = cells[idx.projectTab].trim()
        project.tab = tabValue || 'Alle'
      }
      if(idx.projectNotes >=0 && cells[idx.projectNotes] !== undefined) project.notes = cells[idx.projectNotes]
      if(idx.projectFolder >=0 && cells[idx.projectFolder] !== undefined) project.folder = cells[idx.projectFolder]
      if(idx.projectColor >=0 && cells[idx.projectColor] !== undefined) project.color = cells[idx.projectColor]
      if(idx.projectCollapsed >=0 && cells[idx.projectCollapsed] !== undefined) project.collapsed = boolFrom(cells[idx.projectCollapsed])
      if(idx.projectDeadline >=0 && cells[idx.projectDeadline] !== undefined) project.deadline = cells[idx.projectDeadline]
      if(idx.projectShowDeadline >=0 && cells[idx.projectShowDeadline] !== undefined) project.showDeadline = boolFrom(cells[idx.projectShowDeadline])
      if(idx.projectEmptyDone >=0 && cells[idx.projectEmptyDone] !== undefined) project.emptyDone = boolFrom(cells[idx.projectEmptyDone])
      if(idx.projectDate >=0 && cells[idx.projectDate] !== undefined) project.date = cells[idx.projectDate]
      if(idx.projectSort >=0 && !record.sortCaptured){
        const orderVal = parseInteger(cells[idx.projectSort], null)
        if(orderVal !== null){
          sortEntries.push({ id: project.id, order: orderVal })
          record.sortCaptured = true
        }
      }

      const rawType = todoIdx.type >=0 ? cells[todoIdx.type].toLowerCase().trim() : ''
      const inferredType = rawType
        ? (rawType.startsWith('sub') ? 'subtask' : rawType.startsWith('proj') ? 'project' : 'todo')
        : ((todoIdx.text >=0 && cells[todoIdx.text].trim()) ? 'todo' : 'project')
      if(inferredType === 'project') continue

      const parseMaybeIso = (value) => {
        const raw = String(value || '').trim()
        if(!raw) return ''
        if(parseIsoDate(raw)) return raw
        const german = parseGermanDate(raw)
        return german ? formatIsoDate(german) : raw
      }

      if(inferredType === 'todo'){
        const idxValue = todoIdx.todoIndex >=0 ? parseInteger(cells[todoIdx.todoIndex], null) : null
        const entryIndex = idxValue !== null ? idxValue : record.todoOrder.length
        const existing = record.todoEntries.get(entryIndex)
        const todo = existing && existing.__placeholder ? existing : { text:'', done:false, due:'', assignee:'', acknowledged:false, repeat:null, subtasks:[] }
        todo.__placeholder = false
        if(todoIdx.text >=0 && cells[todoIdx.text] !== undefined) todo.text = cells[todoIdx.text]
        todo.done = todoIdx.done >=0 ? boolFrom(cells[todoIdx.done]) : false
        if(todoIdx.start >=0 && cells[todoIdx.start] !== undefined){
          todo.start = parseMaybeIso(cells[todoIdx.start])
        }
        todo.due = todoIdx.due >=0 ? parseMaybeIso(cells[todoIdx.due]) : ''
        todo.assignee = todoIdx.assignee >=0 ? cells[todoIdx.assignee].trim() : ''
        todo.acknowledged = todoIdx.ack >=0 ? boolFrom(cells[todoIdx.ack]) : false
        if(!Array.isArray(todo.subtasks)) todo.subtasks = []
        const repeatRaw = {}
        if(todoIdx.repeatFreq >=0 && cells[todoIdx.repeatFreq]) repeatRaw.freq = cells[todoIdx.repeatFreq]
        if(todoIdx.repeatInterval >=0 && cells[todoIdx.repeatInterval]) repeatRaw.interval = cells[todoIdx.repeatInterval]
        if(todoIdx.repeatCount >=0 && cells[todoIdx.repeatCount]) repeatRaw.count = cells[todoIdx.repeatCount]
        if(todoIdx.repeatStart >=0 && cells[todoIdx.repeatStart]) repeatRaw.start = cells[todoIdx.repeatStart]
        if(todoIdx.repeatEnd >=0 && cells[todoIdx.repeatEnd]) repeatRaw.end = cells[todoIdx.repeatEnd]
        if(todoIdx.repeatUntil >=0 && cells[todoIdx.repeatUntil]){
          repeatRaw.until = cells[todoIdx.repeatUntil]
          if(!repeatRaw.end) repeatRaw.end = cells[todoIdx.repeatUntil]
        }
        if(todoIdx.repeatDays >=0 && cells[todoIdx.repeatDays]) repeatRaw.days = normalizeRepeatDays(cells[todoIdx.repeatDays])
        const normalizedRepeat = normalizeRepeatSpec(repeatRaw, { dueDate: todo.due })
        todo.repeat = normalizedRepeat
        if(existing && existing !== todo && existing.subtasks && existing.subtasks.length && (!todo.subtasks || !todo.subtasks.length)){
          todo.subtasks = existing.subtasks
        }
        record.todoEntries.set(entryIndex, todo)
        if(!record.todoOrder.includes(entryIndex)) record.todoOrder.push(entryIndex)
        continue
      }

      if(inferredType === 'subtask'){
        const parentIndex = todoIdx.todoIndex >=0 ? parseInteger(cells[todoIdx.todoIndex], null) : null
        const parentKey = parentIndex !== null ? parentIndex : record.todoOrder.length
        let parent = record.todoEntries.get(parentKey)
        if(!parent){
          parent = { text: todoIdx.parentText>=0 ? cells[todoIdx.parentText] : '', done:false, due:'', assignee:'', acknowledged:false, repeat:null, subtasks:[], __placeholder:true }
          record.todoEntries.set(parentKey, parent)
          if(!record.todoOrder.includes(parentKey)) record.todoOrder.push(parentKey)
        }else if(parent.__placeholder && todoIdx.parentText>=0 && cells[todoIdx.parentText]){
          parent.text = cells[todoIdx.parentText]
        }
        if(!Array.isArray(parent.subtasks)) parent.subtasks = []
        const subtask = {
          text: todoIdx.text>=0 ? cells[todoIdx.text] : '',
          done: todoIdx.done>=0 ? boolFrom(cells[todoIdx.done]) : false,
          due: todoIdx.due>=0 ? parseMaybeIso(cells[todoIdx.due]) : '',
          assignee: todoIdx.assignee>=0 ? cells[todoIdx.assignee].trim() : '',
          acknowledged: todoIdx.ack>=0 ? boolFrom(cells[todoIdx.ack]) : false
        }
        const subIndex = todoIdx.subIndex>=0 ? parseInteger(cells[todoIdx.subIndex], parent.subtasks.length) : parent.subtasks.length
        subtask.__index = subIndex === null ? parent.subtasks.length : subIndex
        parent.subtasks.push(subtask)
        continue
      }
    }

    projectRecords.forEach(record => {
      const order = record.todoOrder.slice().sort((a,b) => a - b)
      const todos = []
      order.forEach(index => {
        const todo = record.todoEntries.get(index)
        if(!todo) return
        if(todo.__placeholder){
          if(Array.isArray(todo.subtasks) && todo.subtasks.length){
            todo.__placeholder = false
            todo.text = todo.text || 'To-Do'
          }else{
            return
          }
        }
        if(Array.isArray(todo.subtasks)){
          todo.subtasks.sort((a,b) => {
            const ai = Number.isFinite(a.__index) ? a.__index : 0
            const bi = Number.isFinite(b.__index) ? b.__index : 0
            return ai - bi
          })
          todo.subtasks.forEach(sub => delete sub.__index)
        }
        delete todo.__placeholder
        todos.push(todo)
      })
      record.project.todos = todos
    })

    pushHistory()
    createdProjects.forEach(project => {
      state.projects.push(project)
      if(project.tab && !state.tabs.includes(project.tab) && project.tab !== 'Alle') state.tabs.push(project.tab)
    })

    if(sortEntries.length){
      sortEntries.sort((a,b) => a.order - b.order)
      const orderedIds = sortEntries.map(entry => entry.id)
      const merged = Array.isArray(state.order) ? state.order.filter(id => !orderedIds.includes(id)) : []
      orderedIds.forEach(id => merged.push(id))
      state.order = merged
      state.orderByTab['Alle'] = merged.slice()
      state.filters.sort = 'manual'
    }else{
      const merged = Array.isArray(state.order) ? state.order.slice() : []
      createdProjects.forEach(project => { if(!merged.includes(project.id)) merged.push(project.id) })
      state.order = merged
      state.orderByTab['Alle'] = merged.slice()
    }

    setDirty(true); render(); showToast('CSV importiert')
  }

  const closeCsvMenu = () => { if(csvMenu) csvMenu.classList.remove('show') }
  if(csvMenuBtn && csvMenu){
    csvMenuBtn.addEventListener('click', (e) => {
      e.preventDefault()
      e.stopPropagation()
      csvMenu.classList.toggle('show')
    })
    csvMenu.addEventListener('click', (e) => e.stopPropagation())
    document.addEventListener('click', closeCsvMenu)
    document.addEventListener('keydown', (e) => { if(e.key === 'Escape') closeCsvMenu() })
  }

  // CSV Import
  document.getElementById('csvImportBtn').addEventListener('click', () => {
    closeCsvMenu()
    const inp = document.createElement('input');
    inp.type = 'file'; inp.accept = '.csv,text/csv';
    inp.onchange = () => {
      const f = inp.files[0]; if(!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        const rows = parseCSV(String(reader.result));
        if(!rows.length){ alert('CSV leer.'); return; }
        const headerRaw = rows[0].map(h => String(h ?? ''));
        const headerLower = headerRaw.map(h => h.trim().toLowerCase());
        try{
          const hasDetailed = headerLower.some(name => name.includes('todotyp') || name.includes('todoindex') || name.includes('todorepeatfreq'));
          if(hasDetailed){
            importProjectsFromDetailedCsv(rows, headerRaw, headerLower);
          }else{
            importProjectsFromLegacyCsv(rows, headerLower);
          }
        }catch(err){
          console.error(err);
          alert('CSV konnte nicht importiert werden: ' + (err && err.message ? err.message : err));
        }
      };
      reader.readAsText(f);
    };
    inp.click();
  });

  // CSV Export / Kalender-Export
  const csvExportBtn = document.getElementById('csvExportBtn')
  if(csvExportBtn){
    csvExportBtn.addEventListener('click', async () => {
      closeCsvMenu()
      const list = gatherProjectsForExport()
      try{
        await exportCSV(list, 'projekte.csv')
        showToast('CSV als Download bereitgestellt')
      }catch(err){
        console.error('CSV Export fehlgeschlagen', err)
        alert('CSV konnte nicht exportiert werden: ' + (err && err.message ? err.message : err))
      }
    })
  }
  document.getElementById('calendarExportBtn')
    .addEventListener('click', () => {
      const list = gatherProjectsForExport();
      openCalendarExportDialog(list, { fileName: 'todos.ics' });
    });
  const dispoCsvExportBtn = document.getElementById('dispoCsvExportBtn')
  if(dispoCsvExportBtn){
    dispoCsvExportBtn.addEventListener('click', () => {
      exportDispoCSV('dispo.csv')
      showToast('Dispo CSV exportiert')
    })
  }
  const dispoCsvImportBtn = document.getElementById('dispoCsvImportBtn')
  if(dispoCsvImportBtn){
    dispoCsvImportBtn.addEventListener('click', () => {
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = '.csv,text/csv'
      input.addEventListener('change', () => {
        const file = input.files && input.files[0]
        if(!file) return
        const reader = new FileReader()
        reader.onload = () => {
          try{
            const rows = parseCSV(String(reader.result))
            if(!rows.length){ alert('CSV leer.'); return }
            importDispoFromRows(rows)
          }catch(err){
            console.error(err)
            alert('Dispo CSV konnte nicht importiert werden: ' + (err && err.message ? err.message : err))
          }
        }
        reader.onerror = () => {
          alert('Dispo CSV konnte nicht gelesen werden.')
        }
        reader.readAsText(file)
      })
      input.click()
    })
  }

  // Projekt hinzufügen
  const inNr = document.getElementById('inNr'),
        inName = document.getElementById('inName'),
        inFolder = document.getElementById('inFolder'),
        inTodos = document.getElementById('inTodos'),
        inTab = document.getElementById('inTab');

  document.getElementById('addBtn').addEventListener('click', () => {
    const number = inNr.value.trim(),
          name   = inName.value.trim(),
          folder = inFolder.value.trim();
    let todoTexts = (inTodos.value||'').split(';').map(s=>s.trim()).filter(Boolean)
    const todos = todoTexts.map(text => ({ text, done:false, due:'', assignee:'', repeat:null, acknowledged:false, subtasks:[] }))
    if(!number && !name){ alert('Bitte Projektnummer oder Projektnamen eingeben.'); return; }
    pushHistory();
    const tabName = inTab && inTab.value ? inTab.value : (state.currentTab || 'Alle');
    const p = { id:uid(), number, name, date:'', deadline:'', showDeadline:false,
                todos, notes:'', tab: tabName, folder, color:'', collapsed:false };
    state.projects.unshift(p);
    if(state.filters.sort==='manual'){
      state.order = Array.isArray(state.order) ? state.order.filter(id => id !== p.id) : [];
      state.order.unshift(p.id);
      state.orderByTab['Alle'] = state.order.slice();
      const tabKey = orderKeyForTab(p.tab || state.currentTab || 'Alle');
      if(tabKey !== 'Alle'){
        const scoped = getManualOrderArray(tabKey).filter(id => id !== p.id);
        scoped.unshift(p.id);
        state.orderByTab[tabKey] = scoped;
      }
    }
    setDirty(true); render();
    inNr.value=''; inName.value=''; inFolder.value=''; inTodos.value='';
    if(inTab && state.tabs.includes(state.currentTab || '')) inTab.value = state.currentTab || '';
    inNr.focus();
  });

  // Filter
  const q = document.getElementById('q'),
        status = document.getElementById('status'),
        sort = document.getElementById('sort'),
        tableAssigneeFilter = document.getElementById('tableAssigneeFilter');
  // Hinweis: Der Warnzeitraum für Deadlines wurde entfernt. Es gibt daher kein alertInput mehr.

  // Kein Warnzeitraum mehr – Deadlines werden über die Timeline verwaltet.

  function updateFilters(){
    state.filters.q = q.value;
    state.filters.status = status.value;
    state.filters.sort = sort.value;
    render();
  }
    function renderAssigneeFilterControl(){
      if(!tableAssigneeFilter) return
      tableAssigneeFilter.innerHTML = ''
      const SELECT_ALL = '__all__'
      const teamList = Array.isArray(state.team) ? state.team : []
      const values = Array.isArray(state.assigneeFilter) ? state.assigneeFilter : []
      const selected = new Set(values)
      const addOption = (value, label, isSelected) => {
        const opt = document.createElement('option')
        opt.value = value
        opt.textContent = label
        opt.selected = !!isSelected
        tableAssigneeFilter.appendChild(opt)
      }
      addOption(SELECT_ALL, 'Alle Bearbeiter', selected.size === 0)
      addOption(ASSIGNEE_UNASSIGNED, 'Unzugewiesen', selected.has(ASSIGNEE_UNASSIGNED))
      teamList.forEach(name => addOption(name, name, selected.has(name)))
      const optionCount = teamList.length + 2
      tableAssigneeFilter.size = optionCount <= 3 ? optionCount : 3
    }
  q.addEventListener('input', updateFilters);
  status.addEventListener('change', updateFilters);
  sort.addEventListener('change', updateFilters);
  if(tableAssigneeFilter){
    tableAssigneeFilter.addEventListener('change', () => {
      const rawValues = Array.from(tableAssigneeFilter.selectedOptions).map(opt => opt.value)
      if(rawValues.includes('__all__')){
        state.assigneeFilter = []
        render()
        return
      }
      const normalized = []
      const seen = new Set()
      rawValues.forEach(val => {
        if(val === ASSIGNEE_UNASSIGNED){
          if(!seen.has(ASSIGNEE_UNASSIGNED)){
            seen.add(ASSIGNEE_UNASSIGNED)
            normalized.push(ASSIGNEE_UNASSIGNED)
          }
        }else{
          const original = (state.team || []).find(name => name.toLowerCase() === val.toLowerCase()) || val
          const key = original.toLowerCase()
          if(!seen.has(key)){
            seen.add(key)
            normalized.push(original)
          }
        }
      })
      state.assigneeFilter = normalized
      render()
    })
  }
  // Auswahl / Bulk
  document.getElementById('selectAllBtn').addEventListener('click', ()=>{
    selected.clear();
    applyFilters(state.projects).forEach(p=>selected.add(p.id));
    render();
  });
  document.getElementById('clearSelBtn').addEventListener('click', ()=>{ selected.clear(); render(); });

  // Alle Projekte ausklappen / zuklappen
  const expandAllBtn  = document.getElementById('expandAllBtn');
  const collapseAllBtn = document.getElementById('collapseAllBtn');
  if(expandAllBtn) expandAllBtn.addEventListener('click', () => {
    pushHistory();
    (state.projects || []).forEach(p => { p.collapsed = false; });
    setDirty(true);
    render();
  });
  if(collapseAllBtn) collapseAllBtn.addEventListener('click', () => {
    pushHistory();
    (state.projects || []).forEach(p => { p.collapsed = true; });
    setDirty(true);
    render();
  });
  document.getElementById('bulkAction').addEventListener('change', e=>{
    document.getElementById('bulkTarget').style.display = e.target.value==='move' ? 'inline-block' : 'none';
  });
  document.getElementById('bulkGo').addEventListener('click', async ()=>{
    const action = document.getElementById('bulkAction').value;
    if(!action){ alert('Bitte Aktion wählen.'); return; }
    if(selected.size===0){ alert('Keine Projekte ausgewählt.'); return; }
    const ids = [...selected];
    if(action==='delete'){
      if(confirm('Ausgewählte Projekte in den Papierkorb verschieben?')){
        pushHistory();
        state.trash = state.trash || [];
        ids.forEach(id=>{
          const p = state.projects.find(x=>x.id===id);
          if(p){
            state.trash.unshift({...p, deletedAt: new Date().toISOString()});
            cleanupDispoItems(p)
          }
        });
        state.projects = state.projects.filter(x=>!selected.has(x.id));
        if(state.order) state.order = state.order.filter(id=>!selected.has(id));
        if(state.orderByTab && typeof state.orderByTab === 'object'){
          Object.keys(state.orderByTab).forEach(key => {
            const arr = state.orderByTab[key];
            if(Array.isArray(arr)) state.orderByTab[key] = arr.filter(id => !selected.has(id));
          });
          state.orderByTab['Alle'] = Array.isArray(state.order) ? state.order.slice() : [];
        }
        selected.clear(); setDirty(true); render();
      }
    }else if(action==='move'){
      const target = document.getElementById('bulkTarget').value || 'Alle';
      pushHistory();
      ids.forEach(id=>{ const p = state.projects.find(x=>x.id===id); if(p) p.tab = target; });
      selected.clear(); setDirty(true); render();
    }else if(action==='export_csv'){
      try{
        await exportCSV(state.projects.filter(p=>ids.includes(p.id)),'projekte_auswahl.csv');
        showToast('Ausgewählte Projekte als CSV heruntergeladen');
      }catch(err){
        console.error('CSV Export (Auswahl) fehlgeschlagen', err);
        alert('Ausgewählte Projekte konnten nicht exportiert werden: ' + (err && err.message ? err.message : err));
      }
    }else if(action==='export_ics'){
      openCalendarExportDialog(state.projects.filter(p=>ids.includes(p.id)), { fileName: 'todos_auswahl.ics' });
    }
  });

  // Papierkorb
  const trashDlg = document.getElementById('trashDlg'),
        trashList = document.getElementById('trashList');
  document.getElementById('trashOpenBtn').addEventListener('click', ()=>{ renderTrash(); trashDlg.showModal(); });
  document.getElementById('trashClose').addEventListener('click', ()=> trashDlg.close());
  document.getElementById('trashEmpty').addEventListener('click', ()=>{
    if(confirm('Papierkorb wirklich endgültig leeren?')){
      state.trash = []; setDirty(true); renderTrash();
    }
  });
  function renderTrash(){
    trashList.innerHTML = '';
    const items = state.trash || [];
    if(!items.length){
      const p=document.createElement('p'); p.textContent='Papierkorb ist leer'; p.style.color='var(--muted)';
      trashList.appendChild(p); return;
    }
    items.forEach((it,i)=>{
      const row=document.createElement('div');
      row.style.cssText='display:flex;justify-content:space-between;gap:10px;border:1px solid var(--border);border-radius:12px;padding:10px 12px;margin-bottom:10px;background:var(--chip)';
      const left=document.createElement('div'); left.textContent=`${it.number||'—'} · ${it.name||'Ohne Titel'} · gelöscht ${new Date(it.deletedAt).toLocaleString()}`;
      const right=document.createElement('div'); right.style.display='flex'; right.style.gap='8px';
      const restore=document.createElement('button'); restore.className='btn'; restore.textContent='Wiederherstellen';
      restore.addEventListener('click',()=>{
        pushHistory(); state.projects.unshift({...it}); state.trash.splice(i,1); setDirty(true); render(); renderTrash();
      });
      const drop=document.createElement('button'); drop.className='btn'; drop.textContent='Endgültig löschen';
      drop.addEventListener('click',()=>{
        if(confirm('Endgültig löschen?')){ state.trash.splice(i,1); setDirty(true); renderTrash(); }
      });
      right.appendChild(restore); right.appendChild(drop); row.appendChild(left); row.appendChild(right); trashList.appendChild(row);
    });
  }

  // Ansicht umschalten
  document.getElementById('viewTable').addEventListener('click', ()=>{ state.view='table'; render(); });
  const viewTimelineBtn = document.getElementById('viewTimeline');
  if(viewTimelineBtn){
    viewTimelineBtn.addEventListener('click', () => {
      state.view = 'timeline';
      if(state.tabs?.includes(state.currentTab)) state.timelineTab = state.currentTab;
      else state.timelineTab = 'Alle';
      render();
    });
  }
  const viewSummaryBtn = document.getElementById('viewSummary');
  if(viewSummaryBtn){
    viewSummaryBtn.addEventListener('click', () => {
      state.view = 'summary';
      render();
    });
  }
  const viewAssigneesBtn = document.getElementById('viewAssignees');
  if(viewAssigneesBtn){
    viewAssigneesBtn.addEventListener('click', () => { state.view = 'assignees'; render(); });
  }
  const viewDispoBtn = document.getElementById('viewDispo');
  if(viewDispoBtn){
    viewDispoBtn.addEventListener('click', () => { state.view = 'dispo'; render(); });
  }
  if(timelineTabSelect){
    timelineTabSelect.addEventListener('change', (e) => {
      state.timelineTab = e.target.value || 'Alle';
      setDirty(true);
      if(state.view === 'timeline'){ renderTimeline(); }
    });
  }
  if(timelineZoomInput){
    timelineZoomInput.addEventListener('input', () => {
      const idx = Math.max(0, Math.min(TIMELINE_ZOOMS.length - 1, parseInt(timelineZoomInput.value, 10) || 0));
      const next = TIMELINE_ZOOMS[idx]?.value || 'days';
      state.timelineZoom = next;
      updateTimelineZoomIndicator(next);
      setDirty(true);
      if(state.view === 'timeline'){ renderTimeline(); }
    });
  }

  if(dispoWeekInput){
    const info = parseWeekValue(dispoWeekInput.value);
    dispoWeekInput.value = formatWeekValue(info.year, info.week);
  }
  if(dispoAddWeekBtn){
    dispoAddWeekBtn.addEventListener('click', () => {
      const weekInfo = parseWeekValue(dispoWeekInput ? dispoWeekInput.value : '');
      pushHistory();
      ensureDispo();
      const entry = {
        id: uid(),
        year: weekInfo.year,
        week: weekInfo.week,
        title: (dispoTitleInput?.value || '').trim(),
        notes: '',
        items: [],
        collapsed: false
      };
      state.dispo.unshift(entry);
      setDirty(true);
      if(dispoTitleInput) dispoTitleInput.value = '';
      const { start } = weekRange(entry.year, entry.week);
      dispoNavigator.year = entry.year;
      dispoNavigator.month = start.getUTCMonth();
      render();
    });
  }

  // Light/Dark Regler
  const modeToggle = document.getElementById('modeToggle');
  modeToggle.addEventListener('change', e=>{
    pushHistory();
    state.theme = e.target.checked ? 'light' : 'dark';
    setDirty(true); render();
  });

  // Titel bearbeiten + Placeholder für contenteditable
  const titleEl = document.getElementById('titleText');
  // CSS-Regel für Placeholder (falls noch nicht vorhanden)
 (function ensureCEPlaceholderRule(){
  if (!document.getElementById('ce-placeholder-rule')) {
    const st = document.createElement('style');
    st.id = 'ce-placeholder-rule';
    st.textContent = '.title [contenteditable]:empty::before{content:attr(data-placeholder); color:var(--muted);}';
    document.head.appendChild(st);
  }
})();
  titleEl.setAttribute('data-placeholder','Titel hier ändern …');
  titleEl.addEventListener('input', ()=>{
    pushHistory();
    state.title = (titleEl.textContent || '').trim();
  document.title = state.title || 'XY-To-Dos';   // ← Tab-Titel live setzen
  setDirty(true);
  });

  // Shortcuts
    document.addEventListener('keydown', e=>{
      const key = e.key.toLowerCase();
      const isCtrlOrMeta = e.ctrlKey || e.metaKey;
      if(isCtrlOrMeta && key==='s'){ e.preventDefault(); save(); }
      if(isCtrlOrMeta && key==='z'){ e.preventDefault(); if(e.shiftKey) redo(); else undo(); }
      if(isCtrlOrMeta && key==='y'){ e.preventDefault(); redo(); }
      if(isCtrlOrMeta && key==='p'){ /* Druck: Standard */ }
  });

  // Initiale Anzeige
  // Beim ersten Laden wird die komplette Anzeige aufgebaut (inkl. Filter, Tabelle oder Timeline).
  applyTheme(); setTitle(); render();
</script><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div><div class="tab-menu"></div><div class="tab-submenu"></div><div class="color-palette"><div class="color-grid"></div><div class="custom-color"><span>Eigene Farbe</span><input type="color"><input type="text" placeholder="#RRGGBB" autocomplete="off" spellcheck="false"><button type="button">Übernehmen</button></div><button type="button" class="reset-btn">Standardfarbe verwenden</button></div>



<div class="datePicker" role="dialog" aria-modal="true" style="left: 897px; top: 416px;"><header><span class="navBtn">‹</span><div>Januar 2026</div><span class="navBtn">›</span></header><table><thead><tr><th>Mo</th><th>Di</th><th>Mi</th><th>Do</th><th>Fr</th><th>Sa</th><th>So</th></tr></thead><tbody><tr><td class="disabled">29</td><td class="disabled">30</td><td class="disabled">31</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td></tr><tr><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td></tr><tr><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>31</td><td class="disabled">1</td></tr><tr><td class="disabled">2</td><td class="disabled">3</td><td class="disabled">4</td><td class="disabled">5</td><td class="disabled">6</td><td class="disabled">7</td><td class="disabled">8</td></tr></tbody></table></div><div class="datePicker" role="dialog" aria-modal="true" style="left: 679px; top: 352px;"><header><span class="navBtn">‹</span><div>Januar 2026</div><span class="navBtn">›</span></header><table><thead><tr><th>Mo</th><th>Di</th><th>Mi</th><th>Do</th><th>Fr</th><th>Sa</th><th>So</th></tr></thead><tbody><tr><td class="disabled">29</td><td class="disabled">30</td><td class="disabled">31</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td></tr><tr><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td></tr><tr><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>31</td><td class="disabled">1</td></tr><tr><td class="disabled">2</td><td class="disabled">3</td><td class="disabled">4</td><td class="disabled">5</td><td class="disabled">6</td><td class="disabled">7</td><td class="disabled">8</td></tr></tbody></table></div></body></html>
